what,kind,bundleId,bundleVersion,description,time
executed,command,org.eclipse.ui.workbench.texteditor,3.7.0.v20110928-1504,"org.eclipse.ui.edit.text.goto.lineStart",1342848874171
executed,command,org.eclipse.ui.workbench.texteditor,3.7.0.v20110928-1504,"org.eclipse.ui.edit.text.goto.lineEnd",1342848874421
executed,command,org.eclipse.ui.workbench.texteditor,3.7.0.v20110928-1504,"org.eclipse.ui.edit.text.goto.lineStart",1342848882328
executed,command,org.eclipse.ui.workbench.texteditor,3.7.0.v20110928-1504,"org.eclipse.ui.edit.text.select.lineEnd",1342848882609
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.copy",1342848883453
executed,command,org.eclipse.ui.workbench.texteditor,3.7.0.v20110928-1504,"org.eclipse.ui.edit.text.goto.lineEnd",1342848883781
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342848886343
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342848887156
activated,editor,org.eclipse.jst.jsp.ui,1.1.602.v201112071516,"org.eclipse.jst.jsp.core.jspsource.source",1342848889140
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.copy",1342848891406
activated,editor,org.eclipse.jst.jsp.ui,1.1.602.v201112071516,"org.eclipse.jst.jsp.core.jspsource.source",1342848892234
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342848894171
activated,editor,org.eclipse.jst.jsp.ui,1.1.602.v201112071516,"org.eclipse.jst.jsp.core.jspsource.source",1342848895265
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.copy",1342848897406
activated,editor,org.eclipse.jst.jsp.ui,1.1.602.v201112071516,"org.eclipse.jst.jsp.core.jspsource.source",1342848898265
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342848900093
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342848949578
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342848950546
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342848951156
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342848955312
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342848956000
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342848957390
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342848959656
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342849003968
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342849008296
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342849008484
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.copy",1342849015562
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342849017937
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342849026156
activated,editor,org.eclipse.wst.html.ui,1.0.602.v201202091936,"org.eclipse.wst.html.core.htmlsource.source",1342849029375
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342849039968
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849040546
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849052062
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342849066515
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849067593
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849084812
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342849096109
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342849099578
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849101750
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.window.openEditorDropDown",1342849101765
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849102781
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.copy",1342849128468
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342849130859
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342849138203
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849139734
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849150953
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342849158593
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849163265
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849168187
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342849171250
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849171890
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849216953
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342849234656
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342849235734
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.copy",1342849260937
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.copy",1342849280656
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342849284015
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.copy",1342849306765
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342849309859
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.copy",1342849326687
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342849328187
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.copy",1342849366234
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342849368546
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342849369906
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342849436468
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849441750
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849443515
executed,command,org.eclipse.debug.ui,3.7.102.v20111129-1423_r372,"org.eclipse.debug.ui.commands.RunLast",1342849443531
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849443578
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849458625
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342849476000
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342849477921
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849478359
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849490250
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342849504437
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342849505671
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849506125
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849526687
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849573218
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849586578
activated,view,org.eclipse.ui.navigator.resources,3.4.300.v20110928-1505,"org.eclipse.ui.navigator.ProjectExplorer",1342849597078
activated,editor,org.eclipse.jst.jsp.ui,1.1.602.v201112071516,"org.eclipse.jst.jsp.core.jspsource.source",1342849597375
activated,view,org.eclipse.ui.navigator.resources,3.4.300.v20110928-1505,"org.eclipse.ui.navigator.ProjectExplorer",1342849613718
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849616609
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849618031
executed,command,org.eclipse.wst.server.ui,1.3.0.v20120210_1439,"org.eclipse.wst.server.launchShortcut.run",1342849618046
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849618093
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849658703
activated,editor,org.eclipse.jst.jsp.ui,1.1.602.v201112071516,"org.eclipse.jst.jsp.core.jspsource.source",1342849660593
activated,view,org.eclipse.ui.navigator.resources,3.4.300.v20110928-1505,"org.eclipse.ui.navigator.ProjectExplorer",1342849668234
activated,editor,org.eclipse.wst.html.ui,1.0.602.v201202091936,"org.eclipse.wst.html.core.htmlsource.source",1342849668484
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.copy",1342849683375
activated,view,org.eclipse.ui.navigator.resources,3.4.300.v20110928-1505,"org.eclipse.ui.navigator.ProjectExplorer",1342849685343
activated,editor,org.eclipse.jst.jsp.ui,1.1.602.v201112071516,"org.eclipse.jst.jsp.core.jspsource.source",1342849685515
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342849687906
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342849691875
activated,view,org.eclipse.ui.navigator.resources,3.4.300.v20110928-1505,"org.eclipse.ui.navigator.ProjectExplorer",1342849693046
activated,editor,org.eclipse.wst.html.ui,1.0.602.v201202091936,"org.eclipse.wst.html.core.htmlsource.source",1342849693234
activated,view,org.eclipse.ui.navigator.resources,3.4.300.v20110928-1505,"org.eclipse.ui.navigator.ProjectExplorer",1342849695421
activated,editor,org.eclipse.wst.html.ui,1.0.602.v201202091936,"org.eclipse.wst.html.core.htmlsource.source",1342849695640
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342849714343
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849718453
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849731906
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849735671
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849737984
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.copy",1342849742921
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342849745875
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342849751671
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849755187
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849781812
activated,editor,org.eclipse.jst.jsp.ui,1.1.602.v201112071516,"org.eclipse.jst.jsp.core.jspsource.source",1342849783875
activated,editor,org.eclipse.jst.jsp.ui,1.1.602.v201112071516,"org.eclipse.jst.jsp.core.jspsource.source",1342849785078
activated,editor,org.eclipse.wst.html.ui,1.0.602.v201202091936,"org.eclipse.wst.html.core.htmlsource.source",1342849791906
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849794328
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849797234
activated,editor,org.eclipse.wst.html.ui,1.0.602.v201202091936,"org.eclipse.wst.html.core.htmlsource.source",1342849811703
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342849853203
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849853953
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849856750
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849883593
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849904687
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849914062
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849914062
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849914125
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849944203
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.copy",1342849973921
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342849976390
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.saveAll",1342849989687
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342849990640
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342850008671
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342850037250
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342850038328
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342850059687
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342850071062
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342850071875
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342850121187
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342850139015
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342850145671
activated,view,org.eclipse.ui.navigator.resources,3.4.300.v20110928-1505,"org.eclipse.ui.navigator.ProjectExplorer",1342850151093
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.copy",1342850152187
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342850154843
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342850166484
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342850166500
activated,editor,org.eclipse.wst.html.ui,1.0.602.v201202091936,"org.eclipse.wst.html.core.htmlsource.source",1342850173890
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.undo",1342850184140
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.undo",1342850185093
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342850197000
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342850198156
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342850201234
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.copy",1342850205671
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342850209828
error,log,,,"IStructuredDocumentRegion management failed.",1342850218765
error,log,,,"IStructuredDocumentRegion management failed.",1342850219828
error,log,,,"IStructuredDocumentRegion management failed.",1342850222234
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342850223625
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.copy",1342850227453
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342850231359
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.copy",1342850233593
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342850235250
executed,command,org.eclipse.ui.workbench.texteditor,3.7.0.v20110928-1504,"org.eclipse.ui.edit.text.select.lineEnd",1342850236718
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342850239187
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342850243437
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342850244156
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342850251375
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.copy",1342850265796
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342850268437
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342850275734
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342850275921
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342850276843
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342850277000
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342850278281
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342850279562
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342850298656
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342850307890
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342850312390
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342850320937
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342850345296
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851040187
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851053328
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851054921
executed,command,org.eclipse.debug.ui,3.7.102.v20111129-1423_r372,"org.eclipse.debug.ui.commands.RunLast",1342851054937
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851055015
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851060093
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851065781
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.findReplace",1342851065796
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851071093
activated,editor,org.eclipse.jst.jsp.ui,1.1.602.v201112071516,"org.eclipse.jst.jsp.core.jspsource.source",1342851078000
activated,editor,org.eclipse.wst.html.ui,1.0.602.v201202091936,"org.eclipse.wst.html.core.htmlsource.source",1342851080468
activated,editor,org.eclipse.jst.jsp.ui,1.1.602.v201112071516,"org.eclipse.jst.jsp.core.jspsource.source",1342851082328
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.copy",1342851084625
activated,editor,org.eclipse.wst.html.ui,1.0.602.v201202091936,"org.eclipse.wst.html.core.htmlsource.source",1342851086015
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342851089718
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342851091781
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851093265
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851094046
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851095750
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851095750
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851095843
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851165765
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851168218
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851194765
activated,view,org.eclipse.ui.navigator.resources,3.4.300.v20110928-1505,"org.eclipse.ui.navigator.ProjectExplorer",1342851197609
opened,editor,org.eclipse.wst.html.ui,1.0.602.v201202091936,"org.eclipse.wst.html.core.htmlsource.source",1342851197859
activated,editor,org.eclipse.wst.html.ui,1.0.602.v201202091936,"org.eclipse.wst.html.core.htmlsource.source",1342851197875
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851230343
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851231859
executed,command,org.eclipse.debug.ui,3.7.102.v20111129-1423_r372,"org.eclipse.debug.ui.commands.RunLast",1342851231875
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851231968
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851267828
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.text.contentAssist.proposals",1342851275515
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851281265
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851296687
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.copy",1342851329812
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342851332562
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342851338093
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851340875
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851347375
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.cut",1342851391953
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342851395703
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.delete",1342851397921
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342851398984
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851399750
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851414156
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.saveAll",1342851422078
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851422828
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851429671
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.file.save",1342851434312
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851435593
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851460093
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851466984
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851487281
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342851493890
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342852279390
activated,view,org.eclipse.ui.navigator.resources,3.4.300.v20110928-1505,"org.eclipse.ui.navigator.ProjectExplorer",1342852282750
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342853269984
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342853353484
deactivated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342853357375
activated,workbench,org.eclipse.ui.workbench,3.7.1.v20120104-1859,"",1342853370906
executed,command,org.eclipse.ui,3.7.0.v20110928-1505,"org.eclipse.ui.edit.paste",1342853377000
opened,editor,org.eclipse.wst.jsdt.ui,1.1.102.v201201131900,"org.eclipse.wst.jsdt.ui.CompilationUnitEditor",1342853382734
activated,editor,org.eclipse.wst.jsdt.ui,1.1.102.v201201131900,"org.eclipse.wst.jsdt.ui.CompilationUnitEditor",1342853382765
error,log,,,"Exception occurred during problem detection:\n----------------------------------- SOURCE BEGIN -------------------------------------\n/*\n* jQuery Mobile Framework 1.1.0 db342b1f315c282692791aa870455901fdb46a55\n* http://jquerymobile.com\n*\n* Copyright 2011 (c) jQuery Project\n* Dual licensed under the MIT or GPL Version 2 licenses.\n* http://jquery.org/license\n*\n*/\n(function ( root, doc, factory ) {\n\tif ( typeof define === ""function"" && define.amd ) {\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine( [ ""jquery"" ], function ( $ ) {\n\t\t\tfactory( $, root, doc );\n\t\t\treturn $.mobile;\n\t\t});\n\t} else {\n\t\t// Browser globals\n\t\tfactory( root.jQuery, root, doc );\n\t}\n}( this, document, function ( $, window, document, undefined ) {\n\n\n// This plugin is an experiment for abstracting away the touch and mouse\n// events so that developers don't have to worry about which method of input\n// the device their document is loaded on supports.\n//\n// The idea here is to allow the developer to register listeners for the\n// basic mouse events, such as mousedown, mousemove, mouseup, and click,\n// and the plugin will take care of registering the correct listeners\n// behind the scenes to invoke the listener at the fastest possible time\n// for that device, while still retaining the order of event firing in\n// the traditional mouse environment, should multiple handlers be registered\n// on the same element for different events.\n//\n// The current version exposes the following virtual events to jQuery bind methods:\n// ""vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel""\n\n(function( $, window, document, undefined ) {\n\nvar dataPropertyName = ""virtualMouseBindings"",\n\ttouchTargetPropertyName = ""virtualTouchID"",\n\tvirtualEventNames = ""vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel"".split( "" "" ),\n\ttouchEventProps = ""clientX clientY pageX pageY screenX screenY"".split( "" "" ),\n\tmouseHookProps = $.event.mouseHooks ? $.event.mouseHooks.props : [],\n\tmouseEventProps = $.event.props.concat( mouseHookProps ),\n\tactiveDocHandlers = {},\n\tresetTimerID = 0,\n\tstartX = 0,\n\tstartY = 0,\n\tdidScroll = false,\n\tclickBlockList = [],\n\tblockMouseTriggers = false,\n\tblockTouchTriggers = false,\n\teventCaptureSupported = ""addEventListener"" in document,\n\t$document = $( document ),\n\tnextTouchID = 1,\n\tlastTouchID = 0;\n\n$.vmouse = {\n\tmoveDistanceThreshold: 10,\n\tclickDistanceThreshold: 10,\n\tresetTimerDuration: 1500\n};\n\nfunction getNativeEvent( event ) {\n\n\twhile ( event && typeof event.originalEvent !== ""undefined"" ) {\n\t\tevent = event.originalEvent;\n\t}\n\treturn event;\n}\n\nfunction createVirtualEvent( event, eventType ) {\n\n\tvar t = event.type,\n\t\toe, props, ne, prop, ct, touch, i, j;\n\n\tevent = $.Event(event);\n\tevent.type = eventType;\n\n\toe = event.originalEvent;\n\tprops = $.event.props;\n\n\t// addresses separation of $.event.props in to $.event.mouseHook.props and Issue 3280\n\t// https://github.com/jquery/jquery-mobile/issues/3280\n\tif ( t.search( /^(mouse|click)/ ) > -1 ) {\n\t\tprops = mouseEventProps;\n\t}\n\n\t// copy original event properties over to the new event\n\t// this would happen if we could call $.event.fix instead of $.Event\n\t// but we don't have a way to force an event to be fixed multiple times\n\tif ( oe ) {\n\t\tfor ( i = props.length, prop; i; ) {\n\t\t\tprop = props[ --i ];\n\t\t\tevent[ prop ] = oe[ prop ];\n\t\t}\n\t}\n\n\t// make sure that if the mouse and click virtual events are generated\n\t// without a .which one is defined\n\tif ( t.search(/mouse(down|up)|click/) > -1 && !event.which ){\n\t\tevent.which = 1;\n\t}\n\n\tif ( t.search(/^touch/) !== -1 ) {\n\t\tne = getNativeEvent( oe );\n\t\tt = ne.touches;\n\t\tct = ne.changedTouches;\n\t\ttouch = ( t && t.length ) ? t[0] : ( (ct && ct.length) ? ct[ 0 ] : undefined );\n\n\t\tif ( touch ) {\n\t\t\tfor ( j = 0, len = touchEventProps.length; j < len; j++){\n\t\t\t\tprop = touchEventProps[ j ];\n\t\t\t\tevent[ prop ] = touch[ prop ];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn event;\n}\n\nfunction getVirtualBindingFlags( element ) {\n\n\tvar flags = {},\n\t\tb, k;\n\n\twhile ( element ) {\n\n\t\tb = $.data( element, dataPropertyName );\n\n\t\tfor (  k in b ) {\n\t\t\tif ( b[ k ] ) {\n\t\t\t\tflags[ k ] = flags.hasVirtualBinding = true;\n\t\t\t}\n\t\t}\n\t\telement = element.parentNode;\n\t}\n\treturn flags;\n}\n\nfunction getClosestElementWithVirtualBinding( element, eventType ) {\n\tvar b;\n\twhile ( element ) {\n\n\t\tb = $.data( element, dataPropertyName );\n\n\t\tif ( b && ( !eventType || b[ eventType ] ) ) {\n\t\t\treturn element;\n\t\t}\n\t\telement = element.parentNode;\n\t}\n\treturn null;\n}\n\nfunction enableTouchBindings() {\n\tblockTouchTriggers = false;\n}\n\nfunction disableTouchBindings() {\n\tblockTouchTriggers = true;\n}\n\nfunction enableMouseBindings() {\n\tlastTouchID = 0;\n\tclickBlockList.length = 0;\n\tblockMouseTriggers = false;\n\n\t// When mouse bindings are enabled, our\n\t// touch bindings are disabled.\n\tdisableTouchBindings();\n}\n\nfunction disableMouseBindings() {\n\t// When mouse bindings are disabled, our\n\t// touch bindings are enabled.\n\tenableTouchBindings();\n}\n\nfunction startResetTimer() {\n\tclearResetTimer();\n\tresetTimerID = setTimeout(function(){\n\t\tresetTimerID = 0;\n\t\tenableMouseBindings();\n\t}, $.vmouse.resetTimerDuration );\n}\n\nfunction clearResetTimer() {\n\tif ( resetTimerID ){\n\t\tclearTimeout( resetTimerID );\n\t\tresetTimerID = 0;\n\t}\n}\n\nfunction triggerVirtualEvent( eventType, event, flags ) {\n\tvar ve;\n\n\tif ( ( flags && flags[ eventType ] ) ||\n\t\t\t\t( !flags && getClosestElementWithVirtualBinding( event.target, eventType ) ) ) {\n\n\t\tve = createVirtualEvent( event, eventType );\n\n\t\t$( event.target).trigger( ve );\n\t}\n\n\treturn ve;\n}\n\nfunction mouseEventCallback( event ) {\n\tvar touchID = $.data(event.target, touchTargetPropertyName);\n\n\tif ( !blockMouseTriggers && ( !lastTouchID || lastTouchID !== touchID ) ){\n\t\tvar ve = triggerVirtualEvent( ""v"" + event.type, event );\n\t\tif ( ve ) {\n\t\t\tif ( ve.isDefaultPrevented() ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t\tif ( ve.isPropagationStopped() ) {\n\t\t\t\tevent.stopPropagation();\n\t\t\t}\n\t\t\tif ( ve.isImmediatePropagationStopped() ) {\n\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction handleTouchStart( event ) {\n\n\tvar touches = getNativeEvent( event ).touches,\n\t\ttarget, flags;\n\n\tif ( touches && touches.length === 1 ) {\n\n\t\ttarget = event.target;\n\t\tflags = getVirtualBindingFlags( target );\n\n\t\tif ( flags.hasVirtualBinding ) {\n\n\t\t\tlastTouchID = nextTouchID++;\n\t\t\t$.data( target, touchTargetPropertyName, lastTouchID );\n\n\t\t\tclearResetTimer();\n\n\t\t\tdisableMouseBindings();\n\t\t\tdidScroll = false;\n\n\t\t\tvar t = getNativeEvent( event ).touches[ 0 ];\n\t\t\tstartX = t.pageX;\n\t\t\tstartY = t.pageY;\n\n\t\t\ttriggerVirtualEvent( ""vmouseover"", event, flags );\n\t\t\ttriggerVirtualEvent( ""vmousedown"", event, flags );\n\t\t}\n\t}\n}\n\nfunction handleScroll( event ) {\n\tif ( blockTouchTriggers ) {\n\t\treturn;\n\t}\n\n\tif ( !didScroll ) {\n\t\ttriggerVirtualEvent( ""vmousecancel"", event, getVirtualBindingFlags( event.target ) );\n\t}\n\n\tdidScroll = true;\n\tstartResetTimer();\n}\n\nfunction handleTouchMove( event ) {\n\tif ( blockTouchTriggers ) {\n\t\treturn;\n\t}\n\n\tvar t = getNativeEvent( event ).touches[ 0 ],\n\t\tdidCancel = didScroll,\n\t\tmoveThreshold = $.vmouse.moveDistanceThreshold;\n\t\tdidScroll = didScroll ||\n\t\t\t( Math.abs(t.pageX - startX) > moveThreshold ||\n\t\t\t\tMath.abs(t.pageY - startY) > moveThreshold ),\n\t\tflags = getVirtualBindingFlags( event.target );\n\n\tif ( didScroll && !didCancel ) {\n\t\ttriggerVirtualEvent( ""vmousecancel"", event, flags );\n\t}\n\n\ttriggerVirtualEvent( ""vmousemove"", event, flags );\n\tstartResetTimer();\n}\n\nfunction handleTouchEnd( event ) {\n\tif ( blockTouchTriggers ) {\n\t\treturn;\n\t}\n\n\tdisableTouchBindings();\n\n\tvar flags = getVirtualBindingFlags( event.target ),\n\t\tt;\n\ttriggerVirtualEvent( ""vmouseup"", event, flags );\n\n\tif ( !didScroll ) {\n\t\tvar ve = triggerVirtualEvent( ""vclick"", event, flags );\n\t\tif ( ve && ve.isDefaultPrevented() ) {\n\t\t\t// The target of the mouse events that follow the touchend\n\t\t\t// event don't necessarily match the target used during the\n\t\t\t// touch. This means we need to rely on coordinates for blocking\n\t\t\t// any click that is generated.\n\t\t\tt = getNativeEvent( event ).changedTouches[ 0 ];\n\t\t\tclickBlockList.push({\n\t\t\t\ttouchID: lastTouchID,\n\t\t\t\tx: t.clientX,\n\t\t\t\ty: t.clientY\n\t\t\t});\n\n\t\t\t// Prevent any mouse events that follow from triggering\n\t\t\t// virtual event notifications.\n\t\t\tblockMouseTriggers = true;\n\t\t}\n\t}\n\ttriggerVirtualEvent( ""vmouseout"", event, flags);\n\tdidScroll = false;\n\n\tstartResetTimer();\n}\n\nfunction hasVirtualBindings( ele ) {\n\tvar bindings = $.data( ele, dataPropertyName ),\n\t\tk;\n\n\tif ( bindings ) {\n\t\tfor ( k in bindings ) {\n\t\t\tif ( bindings[ k ] ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction dummyMouseHandler(){}\n\nfunction getSpecialEventObject( eventType ) {\n\tvar realType = eventType.substr( 1 );\n\n\treturn {\n\t\tsetup: function( data, namespace ) {\n\t\t\t// If this is the first virtual mouse binding for this element,\n\t\t\t// add a bindings object to its data.\n\n\t\t\tif ( !hasVirtualBindings( this ) ) {\n\t\t\t\t$.data( this, dataPropertyName, {});\n\t\t\t}\n\n\t\t\t// If setup is called, we know it is the first binding for this\n\t\t\t// eventType, so initialize the count for the eventType to zero.\n\t\t\tvar bindings = $.data( this, dataPropertyName );\n\t\t\tbindings[ eventType ] = true;\n\n\t\t\t// If this is the first virtual mouse event for this type,\n\t\t\t// register a global handler on the document.\n\n\t\t\tactiveDocHandlers[ eventType ] = ( activeDocHandlers[ eventType ] || 0 ) + 1;\n\n\t\t\tif ( activeDocHandlers[ eventType ] === 1 ) {\n\t\t\t\t$document.bind( realType, mouseEventCallback );\n\t\t\t}\n\n\t\t\t// Some browsers, like Opera Mini, won't dispatch mouse/click events\n\t\t\t// for elements unless they actually have handlers registered on them.\n\t\t\t// To get around this, we register dummy handlers on the elements.\n\n\t\t\t$( this ).bind( realType, dummyMouseHandler );\n\n\t\t\t// For now, if event capture is not supported, we rely on mouse handlers.\n\t\t\tif ( eventCaptureSupported ) {\n\t\t\t\t// If this is the first virtual mouse binding for the document,\n\t\t\t\t// register our touchstart handler on the document.\n\n\t\t\t\tactiveDocHandlers[ ""touchstart"" ] = ( activeDocHandlers[ ""touchstart"" ] || 0) + 1;\n\n\t\t\t\tif (activeDocHandlers[ ""touchstart"" ] === 1) {\n\t\t\t\t\t$document.bind( ""touchstart"", handleTouchStart )\n\t\t\t\t\t\t.bind( ""touchend"", handleTouchEnd )\n\n\t\t\t\t\t\t// On touch platforms, touching the screen and then dragging your finger\n\t\t\t\t\t\t// causes the window content to scroll after some distance threshold is\n\t\t\t\t\t\t// exceeded. On these platforms, a scroll prevents a click event from being\n\t\t\t\t\t\t// dispatched, and on some platforms, even the touchend is suppressed. To\n\t\t\t\t\t\t// mimic the suppression of the click event, we need to watch for a scroll\n\t\t\t\t\t\t// event. Unfortunately, some platforms like iOS don't dispatch scroll\n\t\t\t\t\t\t// events until *AFTER* the user lifts their finger (touchend). This means\n\t\t\t\t\t\t// we need to watch both scroll and touchmove events to figure out whether\n\t\t\t\t\t\t// or not a scroll happenens before the touchend event is fired.\n\n\t\t\t\t\t\t.bind( ""touchmove"", handleTouchMove )\n\t\t\t\t\t\t.bind( ""scroll"", handleScroll );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tteardown: function( data, namespace ) {\n\t\t\t// If this is the last virtual binding for this eventType,\n\t\t\t// remove its global handler from the document.\n\n\t\t\t--activeDocHandlers[ eventType ];\n\n\t\t\tif ( !activeDocHandlers[ eventType ] ) {\n\t\t\t\t$document.unbind( realType, mouseEventCallback );\n\t\t\t}\n\n\t\t\tif ( eventCaptureSupported ) {\n\t\t\t\t// If this is the last virtual mouse binding in existence,\n\t\t\t\t// remove our document touchstart listener.\n\n\t\t\t\t--activeDocHandlers[ ""touchstart"" ];\n\n\t\t\t\tif ( !activeDocHandlers[ ""touchstart"" ] ) {\n\t\t\t\t\t$document.unbind( ""touchstart"", handleTouchStart )\n\t\t\t\t\t\t.unbind( ""touchmove"", handleTouchMove )\n\t\t\t\t\t\t.unbind( ""touchend"", handleTouchEnd )\n\t\t\t\t\t\t.unbind( ""scroll"", handleScroll );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar $this = $( this ),\n\t\t\t\tbindings = $.data( this, dataPropertyName );\n\n\t\t\t// teardown may be called when an element was\n\t\t\t// removed from the DOM. If this is the case,\n\t\t\t// jQuery core may have already stripped the element\n\t\t\t// of any data bindings so we need to check it before\n\t\t\t// using it.\n\t\t\tif ( bindings ) {\n\t\t\t\tbindings[ eventType ] = false;\n\t\t\t}\n\n\t\t\t// Unregister the dummy event handler.\n\n\t\t\t$this.unbind( realType, dummyMouseHandler );\n\n\t\t\t// If this is the last virtual mouse binding on the\n\t\t\t// element, remove the binding data from the element.\n\n\t\t\tif ( !hasVirtualBindings( this ) ) {\n\t\t\t\t$this.removeData( dataPropertyName );\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Expose our custom events to the jQuery bind/unbind mechanism.\n\nfor ( var i = 0; i < virtualEventNames.length; i++ ){\n\t$.event.special[ virtualEventNames[ i ] ] = getSpecialEventObject( virtualEventNames[ i ] );\n}\n\n// Add a capture click handler to block clicks.\n// Note that we require event capture support for this so if the device\n// doesn't support it, we punt for now and rely solely on mouse events.\nif ( eventCaptureSupported ) {\n\tdocument.addEventListener( ""click"", function( e ){\n\t\tvar cnt = clickBlockList.length,\n\t\t\ttarget = e.target,\n\t\t\tx, y, ele, i, o, touchID;\n\n\t\tif ( cnt ) {\n\t\t\tx = e.clientX;\n\t\t\ty = e.clientY;\n\t\t\tthreshold = $.vmouse.clickDistanceThreshold;\n\n\t\t\t// The idea here is to run through the clickBlockList to see if\n\t\t\t// the current click event is in the proximity of one of our\n\t\t\t// vclick events that had preventDefault() called on it. If we find\n\t\t\t// one, then we block the click.\n\t\t\t//\n\t\t\t// Why do we have to rely on proximity?\n\t\t\t//\n\t\t\t// Because the target of the touch event that triggered the vclick\n\t\t\t// can be different from the target of the click event synthesized\n\t\t\t// by the browser. The target of a mouse/click event that is syntehsized\n\t\t\t// from a touch event seems to be implementation specific. For example,\n\t\t\t// some browsers will fire mouse/click events for a link that is near\n\t\t\t// a touch event, even though the target of the touchstart/touchend event\n\t\t\t// says the user touched outside the link. Also, it seems that with most\n\t\t\t// browsers, the target of the mouse/click event is not calculated until the\n\t\t\t// time it is dispatched, so if you replace an element that you touched\n\t\t\t// with another element, the target of the mouse/click will be the new\n\t\t\t// element underneath that point.\n\t\t\t//\n\t\t\t// Aside from proximity, we also check to see if the target and any\n\t\t\t// of its ancestors were the ones that blocked a click. This is necessary\n\t\t\t// because of the strange mouse/click target calculation done in the\n\t\t\t// Android 2.1 browser, where if you click on an element, and there is a\n\t\t\t// mouse/click handler on one of its ancestors, the target will be the\n\t\t\t// innermost child of the touched element, even if that child is no where\n\t\t\t// near the point of touch.\n\n\t\t\tele = target;\n\n\t\t\twhile ( ele ) {\n\t\t\t\tfor ( i = 0; i < cnt; i++ ) {\n\t\t\t\t\to = clickBlockList[ i ];\n\t\t\t\t\ttouchID = 0;\n\n\t\t\t\t\tif ( ( ele === target && Math.abs( o.x - x ) < threshold && Math.abs( o.y - y ) < threshold ) ||\n\t\t\t\t\t\t\t\t$.data( ele, touchTargetPropertyName ) === o.touchID ) {\n\t\t\t\t\t\t// XXX: We may want to consider removing matches from the block list\n\t\t\t\t\t\t//      instead of waiting for the reset timer to fire.\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tele = ele.parentNode;\n\t\t\t}\n\t\t}\n\t}, true);\n}\n})( jQuery, window, document );\n\n\n\n// Script: jQuery hashchange event\n// \n// *Version: 1.3, Last updated: 7/21/2010*\n// \n// Project Home - http://benalman.com/projects/jquery-hashchange-plugin/\n// GitHub       - http://github.com/cowboy/jquery-hashchange/\n// Source       - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.js\n// (Minified)   - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.min.js (0.8kb gzipped)\n// \n// About: License\n// \n// Copyright (c) 2010 ""Cowboy"" Ben Alman,\n// Dual licensed under the MIT and GPL licenses.\n// http://benalman.com/about/license/\n// \n// About: Examples\n// \n// These working examples, complete with fully commented code, illustrate a few\n// ways in which this plugin can be used.\n// \n// hashchange event - http://benalman.com/code/projects/jquery-hashchange/examples/hashchange/\n// document.domain - http://benalman.com/code/projects/jquery-hashchange/examples/document_domain/\n// \n// About: Support and Testing\n// \n// Information about what version or versions of jQuery this plugin has been\n// tested with, what browsers it has been tested in, and where the unit tests\n// reside (so you can test it yourself).\n// \n// jQuery Versions - 1.2.6, 1.3.2, 1.4.1, 1.4.2\n// Browsers Tested - Internet Explorer 6-8, Firefox 2-4, Chrome 5-6, Safari 3.2-5,\n//                   Opera 9.6-10.60, iPhone 3.1, Android 1.6-2.2, BlackBerry 4.6-5.\n// Unit Tests      - http://benalman.com/code/projects/jquery-hashchange/unit/\n// \n// About: Known issues\n// \n// While this jQuery hashchange event implementation is quite stable and\n// robust, there are a few unfortunate browser bugs surrounding expected\n// hashchange event-based behaviors, independent of any JavaScript\n// window.onhashchange abstraction. See the following examples for more\n// information:\n// \n// Chrome: Back Button - http://benalman.com/code/projects/jquery-hashchange/examples/bug-chrome-back-button/\n// Firefox: Remote XMLHttpRequest - http://benalman.com/code/projects/jquery-hashchange/examples/bug-firefox-remote-xhr/\n// WebKit: Back Button in an Iframe - http://benalman.com/code/projects/jquery-hashchange/examples/bug-webkit-hash-iframe/\n// Safari: Back Button from a different domain - http://benalman.com/code/projects/jquery-hashchange/examples/bug-safari-back-from-diff-domain/\n// \n// Also note that should a browser natively support the window.onhashchange \n// event, but not report that it does, the fallback polling loop will be used.\n// \n// About: Release History\n// \n// 1.3   - (7/21/2010) Reorganized IE6/7 Iframe code to make it more\n//         ""removable"" for mobile-only development. Added IE6/7 document.title\n//         support. Attempted to make Iframe as hidden as possible by using\n//         techniques from http://www.paciellogroup.com/blog/?p=604. Added \n//         support for the ""shortcut"" format $(window).hashchange( fn ) and\n//         $(window).hashchange() like jQuery provides for built-in events.\n//         Renamed jQuery.hashchangeDelay to <jQuery.fn.hashchange.delay> and\n//         lowered its default value to 50. Added <jQuery.fn.hashchange.domain>\n//         and <jQuery.fn.hashchange.src> properties plus document-domain.html\n//         file to address access denied issues when setting document.domain in\n//         IE6/7.\n// 1.2   - (2/11/2010) Fixed a bug where coming back to a page using this plugin\n//         from a page on another domain would cause an error in Safari 4. Also,\n//         IE6/7 Iframe is now inserted after the body (this actually works),\n//         which prevents the page from scrolling when the event is first bound.\n//         Event can also now be bound before DOM ready, but it won't be usable\n//         before then in IE6/7.\n// 1.1   - (1/21/2010) Incorporated document.documentMode test to fix IE8 bug\n//         where browser version is incorrectly reported as 8.0, despite\n//         inclusion of the X-UA-Compatible IE=EmulateIE7 meta tag.\n// 1.0   - (1/9/2010) Initial Release. Broke out the jQuery BBQ event.special\n//         window.onhashchange functionality into a separate plugin for users\n//         who want just the basic event & back button support, without all the\n//         extra awesomeness that BBQ provides. This plugin will be included as\n//         part of jQuery BBQ, but also be available separately.\n\n(function($,window,undefined){\n  // Reused string.\n  var str_hashchange = 'hashchange',\n    \n    // Method / object references.\n    doc = document,\n    fake_onhashchange,\n    special = $.event.special,\n    \n    // Does the browser support window.onhashchange? Note that IE8 running in\n    // IE7 compatibility mode reports true for 'onhashchange' in window, even\n    // though the event isn't supported, so also test document.documentMode.\n    doc_mode = doc.documentMode,\n    supports_onhashchange = 'on' + str_hashchange in window && ( doc_mode === undefined || doc_mode > 7 );\n  \n  // Get location.hash (or what you'd expect location.hash to be) sans any\n  // leading #. Thanks for making this necessary, Firefox!\n  function get_fragment( url ) {\n    url = url || location.href;\n    return '#' + url.replace( /^[^#]*#?(.*)$/, '$1' );\n  };\n  \n  // Method: jQuery.fn.hashchange\n  // \n  // Bind a handler to the window.onhashchange event or trigger all bound\n  // window.onhashchange event handlers. This behavior is consistent with\n  // jQuery's built-in event handlers.\n  // \n  // Usage:\n  // \n  // > jQuery(window).hashchange( [ handler ] );\n  // \n  // Arguments:\n  // \n  //  handler - (Function) Optional handler to be bound to the hashchange\n  //    event. This is a ""shortcut"" for the more verbose form:\n  //    jQuery(window).bind( 'hashchange', handler ). If handler is omitted,\n  //    all bound window.onhashchange event handlers will be triggered. This\n  //    is a shortcut for the more verbose\n  //    jQuery(window).trigger( 'hashchange' ). These forms are described in\n  //    the <hashchange event> section.\n  // \n  // Returns:\n  // \n  //  (jQuery) The initial jQuery collection of elements.\n  \n  // Allow the ""shortcut"" format $(elem).hashchange( fn ) for binding and\n  // $(elem).hashchange() for triggering, like jQuery does for built-in events.\n  $.fn[ str_hashchange ] = function( fn ) {\n    return fn ? this.bind( str_hashchange, fn ) : this.trigger( str_hashchange );\n  };\n  \n  // Property: jQuery.fn.hashchange.delay\n  // \n  // The numeric interval (in milliseconds) at which the <hashchange event>\n  // polling loop executes. Defaults to 50.\n  \n  // Property: jQuery.fn.hashchange.domain\n  // \n  // If you're setting document.domain in your JavaScript, and you want hash\n  // history to work in IE6/7, not only must this property be set, but you must\n  // also set document.domain BEFORE jQuery is loaded into the page. This\n  // property is only applicable if you are supporting IE6/7 (or IE8 operating\n  // in ""IE7 compatibility"" mode).\n  // \n  // In addition, the <jQuery.fn.hashchange.src> property must be set to the\n  // path of the included ""document-domain.html"" file, which can be renamed or\n  // modified if necessary (note that the document.domain specified must be the\n  // same in both your main JavaScript as well as in this file).\n  // \n  // Usage:\n  // \n  // jQuery.fn.hashchange.domain = document.domain;\n  \n  // Property: jQuery.fn.hashchange.src\n  // \n  // If, for some reason, you need to specify an Iframe src file (for example,\n  // when setting document.domain as in <jQuery.fn.hashchange.domain>), you can\n  // do so using this property. Note that when using this property, history\n  // won't be recorded in IE6/7 until the Iframe src file loads. This property\n  // is only applicable if you are supporting IE6/7 (or IE8 operating in ""IE7\n  // compatibility"" mode).\n  // \n  // Usage:\n  // \n  // jQuery.fn.hashchange.src = 'path/to/file.html';\n  \n  $.fn[ str_hashchange ].delay = 50;\n  /*\n  $.fn[ str_hashchange ].domain = null;\n  $.fn[ str_hashchange ].src = null;\n  */\n  \n  // Event: hashchange event\n  // \n  // Fired when location.hash changes. In browsers that support it, the native\n  // HTML5 window.onhashchange event is used, otherwise a polling loop is\n  // initialized, running every <jQuery.fn.hashchange.delay> milliseconds to\n  // see if the hash has changed. In IE6/7 (and IE8 operating in ""IE7\n  // compatibility"" mode), a hidden Iframe is created to allow the back button\n  // and hash-based history to work.\n  // \n  // Usage as described in <jQuery.fn.hashchange>:\n  // \n  // > // Bind an event handler.\n  // > jQuery(window).hashchange( function(e) {\n  // >   var hash = location.hash;\n  // >   ...\n  // > });\n  // > \n  // > // Manually trigger the event handler.\n  // > jQuery(window).hashchange();\n  // \n  // A more verbose usage that allows for event namespacing:\n  // \n  // > // Bind an event handler.\n  // > jQuery(window).bind( 'hashchange', function(e) {\n  // >   var hash = location.hash;\n  // >   ...\n  // > });\n  // > \n  // > // Manually trigger the event handler.\n  // > jQuery(window).trigger( 'hashchange' );\n  // \n  // Additional Notes:\n  // \n  // * The polling loop and Iframe are not created until at least one handler\n  //   is actually bound to the 'hashchange' event.\n  // * If you need the bound handler(s) to execute immediately, in cases where\n  //   a location.hash exists on page load, via bookmark or page refresh for\n  //   example, use jQuery(window).hashchange() or the more verbose \n  //   jQuery(window).trigger( 'hashchange' ).\n  // * The event can be bound before DOM ready, but since it won't be usable\n  //   before then in IE6/7 (due to the necessary Iframe), recommended usage is\n  //   to bind it inside a DOM ready handler.\n  \n  // Override existing $.event.special.hashchange methods (allowing this plugin\n  // to be defined after jQuery BBQ in BBQ's source code).\n  special[ str_hashchange ] = $.extend( special[ str_hashchange ], {\n    \n    // Called only when the first 'hashchange' event is bound to window.\n    setup: function() {\n      // If window.onhashchange is supported natively, there's nothing to do..\n      if ( supports_onhashchange ) { return false; }\n      \n      // Otherwise, we need to create our own. And we don't want to call this\n      // until the user binds to the event, just in case they never do, since it\n      // will create a polling loop and possibly even a hidden Iframe.\n      $( fake_onhashchange.start );\n    },\n    \n    // Called only when the last 'hashchange' event is unbound from window.\n    teardown: function() {\n      // If window.onhashchange is supported natively, there's nothing to do..\n      if ( supports_onhashchange ) { return false; }\n      \n      // Otherwise, we need to stop ours (if possible).\n      $( fake_onhashchange.stop );\n    }\n    \n  });\n  \n  // fake_onhashchange does all the work of triggering the window.onhashchange\n  // event for browsers that don't natively support it, including creating a\n  // polling loop to watch for hash changes and in IE 6/7 creating a hidden\n  // Iframe to enable back and forward.\n  fake_onhashchange = (function(){\n    var self = {},\n      timeout_id,\n      \n      // Remember the initial hash so it doesn't get triggered immediately.\n      last_hash = get_fragment(),\n      \n      fn_retval = function(val){ return val; },\n      history_set = fn_retval,\n      history_get = fn_retval;\n    \n    // Start the polling loop.\n    self.start = function() {\n      timeout_id || poll();\n    };\n    \n    // Stop the polling loop.\n    self.stop = function() {\n      timeout_id && clearTimeout( timeout_id );\n      timeout_id = undefined;\n    };\n    \n    // This polling loop checks every $.fn.hashchange.delay milliseconds to see\n    // if location.hash has changed, and triggers the 'hashchange' event on\n    // window when necessary.\n    function poll() {\n      var hash = get_fragment(),\n        history_hash = history_get( last_hash );\n      \n      if ( hash !== last_hash ) {\n        history_set( last_hash = hash, history_hash );\n        \n        $(window).trigger( str_hashchange );\n        \n      } else if ( history_hash !== last_hash ) {\n        location.href = location.href.replace( /#.*/, '' ) + history_hash;\n      }\n      \n      timeout_id = setTimeout( poll, $.fn[ str_hashchange ].delay );\n    };\n    \n    // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n    // vvvvvvvvvvvvvvvvvvv REMOVE IF NOT SUPPORTING IE6/7/8 vvvvvvvvvvvvvvvvvvv\n    // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n    $.browser.msie && !supports_onhashchange && (function(){\n      // Not only do IE6/7 need the ""magical"" Iframe treatment, but so does IE8\n      // when running in ""IE7 compatibility"" mode.\n      \n      var iframe,\n        iframe_src;\n      \n      // When the event is bound and polling starts in IE 6/7, create a hidden\n      // Iframe for history handling.\n      self.start = function(){\n        if ( !iframe ) {\n          iframe_src = $.fn[ str_hashchange ].src;\n          iframe_src = iframe_src && iframe_src + get_fragment();\n          \n          // Create hidden Iframe. Attempt to make Iframe as hidden as possible\n          // by using techniques from http://www.paciellogroup.com/blog/?p=604.\n          iframe = $('<iframe tabindex=""-1"" title=""empty""/>').hide()\n            \n            // When Iframe has completely loaded, initialize the history and\n            // start polling.\n            .one( 'load', function(){\n              iframe_src || history_set( get_fragment() );\n              poll();\n            })\n            \n            // Load Iframe src if specified, otherwise nothing.\n            .attr( 'src', iframe_src || 'javascript:0' )\n            \n            // Append Iframe after the end of the body to prevent unnecessary\n            // initial page scrolling (yes, this works).\n            .insertAfter( 'body' )[0].contentWindow;\n          \n          // Whenever `document.title` changes, update the Iframe's title to\n          // prettify the back/next history menu entries. Since IE sometimes\n          // errors with ""Unspecified error"" the very first time this is set\n          // (yes, very useful) wrap this with a try/catch block.\n          doc.onpropertychange = function(){\n            try {\n              if ( event.propertyName === 'title' ) {\n                iframe.document.title = doc.title;\n              }\n            } catch(e) {}\n          };\n          \n        }\n      };\n      \n      // Override the ""stop"" method since an IE6/7 Iframe was created. Even\n      // if there are no longer any bound event handlers, the polling loop\n      // is still necessary for back/next to work at all!\n      self.stop = fn_retval;\n      \n      // Get history by looking at the hidden Iframe's location.hash.\n      history_get = function() {\n        return get_fragment( iframe.location.href );\n      };\n      \n      // Set a new history item by opening and then closing the Iframe\n      // document, *then* setting its location.hash. If document.domain has\n      // been set, update that as well.\n      history_set = function( hash, history_hash ) {\n        var iframe_doc = iframe.document,\n          domain = $.fn[ str_hashchange ].domain;\n        \n        if ( hash !== history_hash ) {\n          // Update Iframe with any initial `document.title` that might be set.\n          iframe_doc.title = doc.title;\n          \n          // Opening the Iframe's document after it has been closed is what\n          // actually adds a history entry.\n          iframe_doc.open();\n          \n          // Set document.domain for the Iframe document as well, if necessary.\n          domain && iframe_doc.write( '<script>document.domain=""' + domain + '""</script>' );\n          \n          iframe_doc.close();\n          \n          // Update the Iframe's hash, for great justice.\n          iframe.location.hash = hash;\n        }\n      };\n      \n    })();\n    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    // ^^^^^^^^^^^^^^^^^^^ REMOVE IF NOT SUPPORTING IE6/7/8 ^^^^^^^^^^^^^^^^^^^\n    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    \n    return self;\n  })();\n  \n})(jQuery,this);\n\n/*!\n * jQuery UI Widget @VERSION\n *\n * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n *\n * http://docs.jquery.com/UI/Widget\n */\n\n(function( $, undefined ) {\n\n// jQuery 1.4+\nif ( $.cleanData ) {\n\tvar _cleanData = $.cleanData;\n\t$.cleanData = function( elems ) {\n\t\tfor ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {\n\t\t\t$( elem ).triggerHandler( ""remove"" );\n\t\t}\n\t\t_cleanData( elems );\n\t};\n} else {\n\tvar _remove = $.fn.remove;\n\t$.fn.remove = function( selector, keepData ) {\n\t\treturn this.each(function() {\n\t\t\tif ( !keepData ) {\n\t\t\t\tif ( !selector || $.filter( selector, [ this ] ).length ) {\n\t\t\t\t\t$( ""*"", this ).add( [ this ] ).each(function() {\n\t\t\t\t\t\t$( this ).triggerHandler( ""remove"" );\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn _remove.call( $(this), selector, keepData );\n\t\t});\n\t};\n}\n\n$.widget = function( name, base, prototype ) {\n\tvar namespace = name.split( ""."" )[ 0 ],\n\t\tfullName;\n\tname = name.split( ""."" )[ 1 ];\n\tfullName = namespace + ""-"" + name;\n\n\tif ( !prototype ) {\n\t\tprototype = base;\n\t\tbase = $.Widget;\n\t}\n\n\t// create selector for plugin\n\t$.expr[ "":"" ][ fullName ] = function( elem ) {\n\t\treturn !!$.data( elem, name );\n\t};\n\n\t$[ namespace ] = $[ namespace ] || {};\n\t$[ namespace ][ name ] = function( options, element ) {\n\t\t// allow instantiation without initializing for simple inheritance\n\t\tif ( arguments.length ) {\n\t\t\tthis._createWidget( options, element );\n\t\t}\n\t};\n\n\tvar basePrototype = new base();\n\t// we need to make the options hash a property directly on the new instance\n\t// otherwise we'll modify the options hash on the prototype that we're\n\t// inheriting from\n//\t$.each( basePrototype, function( key, val ) {\n//\t\tif ( $.isPlainObject(val) ) {\n//\t\t\tbasePrototype[ key ] = $.extend( {}, val );\n//\t\t}\n//\t});\n\tbasePrototype.options = $.extend( true, {}, basePrototype.options );\n\t$[ namespace ][ name ].prototype = $.extend( true, basePrototype, {\n\t\tnamespace: namespace,\n\t\twidgetName: name,\n\t\twidgetEventPrefix: $[ namespace ][ name ].prototype.widgetEventPrefix || name,\n\t\twidgetBaseClass: fullName\n\t}, prototype );\n\n\t$.widget.bridge( name, $[ namespace ][ name ] );\n};\n\n$.widget.bridge = function( name, object ) {\n\t$.fn[ name ] = function( options ) {\n\t\tvar isMethodCall = typeof options === ""string"",\n\t\t\targs = Array.prototype.slice.call( arguments, 1 ),\n\t\t\treturnValue = this;\n\n\t\t// allow multiple hashes to be passed on init\n\t\toptions = !isMethodCall && args.length ?\n\t\t\t$.extend.apply( null, [ true, options ].concat(args) ) :\n\t\t\toptions;\n\n\t\t// prevent calls to internal methods\n\t\tif ( isMethodCall && options.charAt( 0 ) === ""_"" ) {\n\t\t\treturn returnValue;\n\t\t}\n\n\t\tif ( isMethodCall ) {\n\t\t\tthis.each(function() {\n\t\t\t\tvar instance = $.data( this, name );\n\t\t\t\tif ( !instance ) {\n\t\t\t\t\tthrow ""cannot call methods on "" + name + "" prior to initialization; "" +\n\t\t\t\t\t\t""attempted to call method '"" + options + ""'"";\n\t\t\t\t}\n\t\t\t\tif ( !$.isFunction( instance[options] ) ) {\n\t\t\t\t\tthrow ""no such method '"" + options + ""' for "" + name + "" widget instance"";\n\t\t\t\t}\n\t\t\t\tvar methodValue = instance[ options ].apply( instance, args );\n\t\t\t\tif ( methodValue !== instance && methodValue !== undefined ) {\n\t\t\t\t\treturnValue = methodValue;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tthis.each(function() {\n\t\t\t\tvar instance = $.data( this, name );\n\t\t\t\tif ( instance ) {\n\t\t\t\t\tinstance.option( options || {} )._init();\n\t\t\t\t} else {\n\t\t\t\t\t$.data( this, name, new object( options, this ) );\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn returnValue;\n\t};\n};\n\n$.Widget = function( options, element ) {\n\t// allow instantiation without initializing for simple inheritance\n\tif ( arguments.length ) {\n\t\tthis._createWidget( options, element );\n\t}\n};\n\n$.Widget.prototype = {\n\twidgetName: ""widget"",\n\twidgetEventPrefix: """",\n\toptions: {\n\t\tdisabled: false\n\t},\n\t_createWidget: function( options, element ) {\n\t\t// $.widget.bridge stores the plugin instance, but we do it anyway\n\t\t// so that it's stored even before the _create function runs\n\t\t$.data( element, this.widgetName, this );\n\t\tthis.element = $( element );\n\t\tthis.options = $.extend( true, {},\n\t\t\tthis.options,\n\t\t\tthis._getCreateOptions(),\n\t\t\toptions );\n\n\t\tvar self = this;\n\t\tthis.element.bind( ""remove."" + this.widgetName, function() {\n\t\t\tself.destroy();\n\t\t});\n\n\t\tthis._create();\n\t\tthis._trigger( ""create"" );\n\t\tthis._init();\n\t},\n\t_getCreateOptions: function() {\n\t\tvar options = {};\n\t\tif ( $.metadata ) {\n\t\t\toptions = $.metadata.get( element )[ this.widgetName ];\n\t\t}\n\t\treturn options;\n\t},\n\t_create: function() {},\n\t_init: function() {},\n\n\tdestroy: function() {\n\t\tthis.element\n\t\t\t.unbind( ""."" + this.widgetName )\n\t\t\t.removeData( this.widgetName );\n\t\tthis.widget()\n\t\t\t.unbind( ""."" + this.widgetName )\n\t\t\t.removeAttr( ""aria-disabled"" )\n\t\t\t.removeClass(\n\t\t\t\tthis.widgetBaseClass + ""-disabled "" +\n\t\t\t\t""ui-state-disabled"" );\n\t},\n\n\twidget: function() {\n\t\treturn this.element;\n\t},\n\n\toption: function( key, value ) {\n\t\tvar options = key;\n\n\t\tif ( arguments.length === 0 ) {\n\t\t\t// don't return a reference to the internal hash\n\t\t\treturn $.extend( {}, this.options );\n\t\t}\n\n\t\tif  (typeof key === ""string"" ) {\n\t\t\tif ( value === undefined ) {\n\t\t\t\treturn this.options[ key ];\n\t\t\t}\n\t\t\toptions = {};\n\t\t\toptions[ key ] = value;\n\t\t}\n\n\t\tthis._setOptions( options );\n\n\t\treturn this;\n\t},\n\t_setOptions: function( options ) {\n\t\tvar self = this;\n\t\t$.each( options, function( key, value ) {\n\t\t\tself._setOption( key, value );\n\t\t});\n\n\t\treturn this;\n\t},\n\t_setOption: function( key, value ) {\n\t\tthis.options[ key ] = value;\n\n\t\tif ( key === ""disabled"" ) {\n\t\t\tthis.widget()\n\t\t\t\t[ value ? ""addClass"" : ""removeClass""](\n\t\t\t\t\tthis.widgetBaseClass + ""-disabled"" + "" "" +\n\t\t\t\t\t""ui-state-disabled"" )\n\t\t\t\t.attr( ""aria-disabled"", value );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tenable: function() {\n\t\treturn this._setOption( ""disabled"", false );\n\t},\n\tdisable: function() {\n\t\treturn this._setOption( ""disabled"", true );\n\t},\n\n\t_trigger: function( type, event, data ) {\n\t\tvar callback = this.options[ type ];\n\n\t\tevent = $.Event( event );\n\t\tevent.type = ( type === this.widgetEventPrefix ?\n\t\t\ttype :\n\t\t\tthis.widgetEventPrefix + type ).toLowerCase();\n\t\tdata = data || {};\n\n\t\t// copy original event properties over to the new event\n\t\t// this would happen if we could call $.event.fix instead of $.Event\n\t\t// but we don't have a way to force an event to be fixed multiple times\n\t\tif ( event.originalEvent ) {\n\t\t\tfor ( var i = $.event.props.length, prop; i; ) {\n\t\t\t\tprop = $.event.props[ --i ];\n\t\t\t\tevent[ prop ] = event.originalEvent[ prop ];\n\t\t\t}\n\t\t}\n\n\t\tthis.element.trigger( event, data );\n\n\t\treturn !( $.isFunction(callback) &&\n\t\t\tcallback.call( this.element[0], event, data ) === false ||\n\t\t\tevent.isDefaultPrevented() );\n\t}\n};\n\n})( jQuery );\n\n(function( $, undefined ) {\n\n$.widget( ""mobile.widget"", {\n\t// decorate the parent _createWidget to trigger `widgetinit` for users\n\t// who wish to do post post `widgetcreate` alterations/additions\n\t//\n\t// TODO create a pull request for jquery ui to trigger this event\n\t// in the original _createWidget\n\t_createWidget: function() {\n\t\t$.Widget.prototype._createWidget.apply( this, arguments );\n\t\tthis._trigger( 'init' );\n\t},\n\n\t_getCreateOptions: function() {\n\n\t\tvar elem = this.element,\n\t\t\toptions = {};\n\n\t\t$.each( this.options, function( option ) {\n\n\t\t\tvar value = elem.jqmData( option.replace( /[A-Z]/g, function( c ) {\n\t\t\t\t\t\t\treturn ""-"" + c.toLowerCase();\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\n\t\t\tif ( value !== undefined ) {\n\t\t\t\toptions[ option ] = value;\n\t\t\t}\n\t\t});\n\n\t\treturn options;\n\t},\n\n\tenhanceWithin: function( target, useKeepNative ) {\n\t\tthis.enhance( $( this.options.initSelector, $( target )), useKeepNative );\n\t},\n\n\tenhance: function( targets, useKeepNative ) {\n\t\tvar page, keepNative, $widgetElements = $( targets ), self = this;\n\n\t\t// if ignoreContentEnabled is set to true the framework should\n\t\t// only enhance the selected elements when they do NOT have a\n\t\t// parent with the data-namespace-ignore attribute\n\t\t$widgetElements = $.mobile.enhanceable( $widgetElements );\n\n\t\tif ( useKeepNative && $widgetElements.length ) {\n\t\t\t// TODO remove dependency on the page widget for the keepNative.\n\t\t\t// Currently the keepNative value is defined on the page prototype so\n\t\t\t// the method is as well\n\t\t\tpage = $.mobile.closestPageData( $widgetElements );\n\t\t\tkeepNative = (page && page.keepNativeSelector()) || """";\n\n\t\t\t$widgetElements = $widgetElements.not( keepNative );\n\t\t}\n\n\t\t$widgetElements[ this.widgetName ]();\n\t},\n\n\traise: function( msg ) {\n\t\tthrow ""Widget ["" + this.widgetName + ""]: "" + msg;\n\t}\n});\n\n})( jQuery );\n\n(function( $, window, undefined ) {\n\n\tvar nsNormalizeDict = {};\n\n\t// jQuery.mobile configurable options\n\t$.mobile = $.extend( {}, {\n\n\t\t// Version of the jQuery Mobile Framework\n\t\tversion: ""1.1.0"",\n\n\t\t// Namespace used framework-wide for data-attrs. Default is no namespace\n\t\tns: """",\n\n\t\t// Define the url parameter used for referencing widget-generated sub-pages.\n\t\t// Translates to to example.html&ui-page=subpageIdentifier\n\t\t// hash segment before &ui-page= is used to make Ajax request\n\t\tsubPageUrlKey: ""ui-page"",\n\n\t\t// Class assigned to page currently in view, and during transitions\n\t\tactivePageClass: ""ui-page-active"",\n\n\t\t// Class used for ""active"" button state, from CSS framework\n\t\tactiveBtnClass: ""ui-btn-active"",\n\n\t\t// Class used for ""focus"" form element state, from CSS framework\n\t\tfocusClass: ""ui-focus"",\n\n\t\t// Automatically handle clicks and form submissions through Ajax, when same-domain\n\t\tajaxEnabled: true,\n\n\t\t// Automatically load and show pages based on location.hash\n\t\thashListeningEnabled: true,\n\n\t\t// disable to prevent jquery from bothering with links\n\t\tlinkBindingEnabled: true,\n\n\t\t// Set default page transition - 'none' for no transitions\n\t\tdefaultPageTransition: ""fade"",\n\n\t\t// Set maximum window width for transitions to apply - 'false' for no limit\n\t\tmaxTransitionWidth: false,\n\n\t\t// Minimum scroll distance that will be remembered when returning to a page\n\t\tminScrollBack: 250,\n\n\t\t// DEPRECATED: the following property is no longer in use, but defined until 2.0 to prevent conflicts\n\t\ttouchOverflowEnabled: false,\n\n\t\t// Set default dialog transition - 'none' for no transitions\n\t\tdefaultDialogTransition: ""pop"",\n\n\t\t// Show loading message during Ajax requests\n\t\t// if false, message will not appear, but loading classes will still be toggled on html el\n\t\tloadingMessage: ""loading"",\n\n\t\t// Error response message - appears when an Ajax page request fails\n\t\tpageLoadErrorMessage: ""Error Loading Page"",\n\n\t\t// Should the text be visble in the loading message?\n\t\tloadingMessageTextVisible: false,\n\n\t\t// When the text is visible, what theme does the loading box use?\n\t\tloadingMessageTheme: ""a"",\n\n\t\t// For error messages, which theme does the box uses?\n\t\tpageLoadErrorMessageTheme: ""e"",\n\n\t\t//automatically initialize the DOM when it's ready\n\t\tautoInitializePage: true,\n\n\t\tpushStateEnabled: true,\n\n\t\t// allows users to opt in to ignoring content by marking a parent element as\n\t\t// data-ignored\n\t\tignoreContentEnabled: false,\n\n\t\t// turn of binding to the native orientationchange due to android orientation behavior\n\t\torientationChangeEnabled: true,\n\n\t\tbuttonMarkup: {\n\t\t\thoverDelay: 200\n\t\t},\n\n\t\t// TODO might be useful upstream in jquery itself ?\n\t\tkeyCode: {\n\t\t\tALT: 18,\n\t\t\tBACKSPACE: 8,\n\t\t\tCAPS_LOCK: 20,\n\t\t\tCOMMA: 188,\n\t\t\tCOMMAND: 91,\n\t\t\tCOMMAND_LEFT: 91, // COMMAND\n\t\t\tCOMMAND_RIGHT: 93,\n\t\t\tCONTROL: 17,\n\t\t\tDELETE: 46,\n\t\t\tDOWN: 40,\n\t\t\tEND: 35,\n\t\t\tENTER: 13,\n\t\t\tESCAPE: 27,\n\t\t\tHOME: 36,\n\t\t\tINSERT: 45,\n\t\t\tLEFT: 37,\n\t\t\tMENU: 93, // COMMAND_RIGHT\n\t\t\tNUMPAD_ADD: 107,\n\t\t\tNUMPAD_DECIMAL: 110,\n\t\t\tNUMPAD_DIVIDE: 111,\n\t\t\tNUMPAD_ENTER: 108,\n\t\t\tNUMPAD_MULTIPLY: 106,\n\t\t\tNUMPAD_SUBTRACT: 109,\n\t\t\tPAGE_DOWN: 34,\n\t\t\tPAGE_UP: 33,\n\t\t\tPERIOD: 190,\n\t\t\tRIGHT: 39,\n\t\t\tSHIFT: 16,\n\t\t\tSPACE: 32,\n\t\t\tTAB: 9,\n\t\t\tUP: 38,\n\t\t\tWINDOWS: 91 // COMMAND\n\t\t},\n\n\t\t// Scroll page vertically: scroll to 0 to hide iOS address bar, or pass a Y value\n\t\tsilentScroll: function( ypos ) {\n\t\t\tif ( $.type( ypos ) !== ""number"" ) {\n\t\t\t\typos = $.mobile.defaultHomeScroll;\n\t\t\t}\n\n\t\t\t// prevent scrollstart and scrollstop events\n\t\t\t$.event.special.scrollstart.enabled = false;\n\n\t\t\tsetTimeout(function() {\n\t\t\t\twindow.scrollTo( 0, ypos );\n\t\t\t\t$( document ).trigger( ""silentscroll"", { x: 0, y: ypos });\n\t\t\t}, 20 );\n\n\t\t\tsetTimeout(function() {\n\t\t\t\t$.event.special.scrollstart.enabled = true;\n\t\t\t}, 150 );\n\t\t},\n\n\t\t// Expose our cache for testing purposes.\n\t\tnsNormalizeDict: nsNormalizeDict,\n\n\t\t// Take a data attribute property, prepend the namespace\n\t\t// and then camel case the attribute string. Add the result\n\t\t// to our nsNormalizeDict so we don't have to do this again.\n\t\tnsNormalize: function( prop ) {\n\t\t\tif ( !prop ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn nsNormalizeDict[ prop ] || ( nsNormalizeDict[ prop ] = $.camelCase( $.mobile.ns + prop ) );\n\t\t},\n\n\t\tgetInheritedTheme: function( el, defaultTheme ) {\n\n\t\t\t// Find the closest parent with a theme class on it. Note that\n\t\t\t// we are not using $.fn.closest() on purpose here because this\n\t\t\t// method gets called quite a bit and we need it to be as fast\n\t\t\t// as possible.\n\n\t\t\tvar e = el[ 0 ],\n\t\t\t\tltr = """",\n\t\t\t\tre = /ui-(bar|body|overlay)-([a-z])\\b/,\n\t\t\t\tc, m;\n\n\t\t\twhile ( e ) {\n\t\t\t\tvar c = e.className || """";\n\t\t\t\tif ( ( m = re.exec( c ) ) && ( ltr = m[ 2 ] ) ) {\n\t\t\t\t\t// We found a parent with a theme class\n\t\t\t\t\t// on it so bail from this loop.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\te = e.parentNode;\n\t\t\t}\n\n\t\t\t// Return the theme letter we found, if none, return the\n\t\t\t// specified default.\n\n\t\t\treturn ltr || defaultTheme || ""a"";\n\t\t},\n\n\t\t// TODO the following $ and $.fn extensions can/probably should be moved into jquery.mobile.core.helpers\n\t\t//\n\t\t// Find the closest javascript page element to gather settings data jsperf test\n\t\t// http://jsperf.com/single-complex-selector-vs-many-complex-selectors/edit\n\t\t// possibly naive, but it shows that the parsing overhead for *just* the page selector vs\n\t\t// the page and dialog selector is negligable. This could probably be speed up by\n\t\t// doing a similar parent node traversal to the one found in the inherited theme code above\n\t\tclosestPageData: function( $target ) {\n\t\t\treturn $target\n\t\t\t\t.closest(':jqmData(role=""page""), :jqmData(role=""dialog"")')\n\t\t\t\t.data(""page"");\n\t\t},\n\n\t\tenhanceable: function( $set ) {\n\t\t\treturn this.haveParents( $set, ""enhance"" );\n\t\t},\n\n\t\thijackable: function( $set ) {\n\t\t\treturn this.haveParents( $set, ""ajax"" );\n\t\t},\n\n\t\thaveParents: function( $set, attr ) {\n\t\t\tif( !$.mobile.ignoreContentEnabled ){\n\t\t\t\treturn $set;\n\t\t\t}\n\n\t\t\tvar count = $set.length,\n\t\t\t\t$newSet = $(),\n\t\t\t\te, $element, excluded;\n\n\t\t\tfor ( var i = 0; i < count; i++ ) {\n\t\t\t\t$element = $set.eq( i );\n\t\t\t\texcluded = false;\n\t\t\t\te = $set[ i ];\n\n\t\t\t\twhile ( e ) {\n\t\t\t\t\tvar c = e.getAttribute ? e.getAttribute( ""data-"" + $.mobile.ns + attr ) : """";\n\n\t\t\t\t\tif ( c === ""false"" ) {\n\t\t\t\t\t\texcluded = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\te = e.parentNode;\n\t\t\t\t}\n\n\t\t\t\tif ( !excluded ) {\n\t\t\t\t\t$newSet = $newSet.add( $element );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $newSet;\n\t\t}\n\t}, $.mobile );\n\n\t// Mobile version of data and removeData and hasData methods\n\t// ensures all data is set and retrieved using jQuery Mobile's data namespace\n\t$.fn.jqmData = function( prop, value ) {\n\t\tvar result;\n\t\tif ( typeof prop != ""undefined"" ) {\n\t\t\tif ( prop ) {\n\t\t\t\tprop = $.mobile.nsNormalize( prop );\n\t\t\t}\n\t\t\tresult = this.data.apply( this, arguments.length < 2 ? [ prop ] : [ prop, value ] );\n\t\t}\n\t\treturn result;\n\t};\n\n\t$.jqmData = function( elem, prop, value ) {\n\t\tvar result;\n\t\tif ( typeof prop != ""undefined"" ) {\n\t\t\tresult = $.data( elem, prop ? $.mobile.nsNormalize( prop ) : prop, value );\n\t\t}\n\t\treturn result;\n\t};\n\n\t$.fn.jqmRemoveData = function( prop ) {\n\t\treturn this.removeData( $.mobile.nsNormalize( prop ) );\n\t};\n\n\t$.jqmRemoveData = function( elem, prop ) {\n\t\treturn $.removeData( elem, $.mobile.nsNormalize( prop ) );\n\t};\n\n\t$.fn.removeWithDependents = function() {\n\t\t$.removeWithDependents( this );\n\t};\n\n\t$.removeWithDependents = function( elem ) {\n\t\tvar $elem = $( elem );\n\n\t\t( $elem.jqmData('dependents') || $() ).remove();\n\t\t$elem.remove();\n\t};\n\n\t$.fn.addDependents = function( newDependents ) {\n\t\t$.addDependents( $(this), newDependents );\n\t};\n\n\t$.addDependents = function( elem, newDependents ) {\n\t\tvar dependents = $(elem).jqmData( 'dependents' ) || $();\n\n\t\t$(elem).jqmData( 'dependents', $.merge(dependents, newDependents) );\n\t};\n\n\t// note that this helper doesn't attempt to handle the callback\n\t// or setting of an html elements text, its only purpose is\n\t// to return the html encoded version of the text in all cases. (thus the name)\n\t$.fn.getEncodedText = function() {\n\t\treturn $( ""<div/>"" ).text( $(this).text() ).html();\n\t};\n\n\t// fluent helper function for the mobile namespaced equivalent\n\t$.fn.jqmEnhanceable = function() {\n\t\treturn $.mobile.enhanceable( this );\n\t};\n\n\t$.fn.jqmHijackable = function() {\n\t\treturn $.mobile.hijackable( this );\n\t};\n\n\t// Monkey-patching Sizzle to filter the :jqmData selector\n\tvar oldFind = $.find,\n\t\tjqmDataRE = /:jqmData\\(([^)]*)\\)/g;\n\n\t$.find = function( selector, context, ret, extra ) {\n\t\tselector = selector.replace( jqmDataRE, ""[data-"" + ( $.mobile.ns || """" ) + ""$1]"" );\n\n\t\treturn oldFind.call( this, selector, context, ret, extra );\n\t};\n\n\t$.extend( $.find, oldFind );\n\n\t$.find.matches = function( expr, set ) {\n\t\treturn $.find( expr, null, null, set );\n\t};\n\n\t$.find.matchesSelector = function( node, expr ) {\n\t\treturn $.find( expr, null, null, [ node ] ).length > 0;\n\t};\n})( jQuery, this );\n\n\n(function( $, undefined ) {\n\nvar $window = $( window ),\n\t$html = $( ""html"" );\n\n/* $.mobile.media method: pass a CSS media type or query and get a bool return\n\tnote: this feature relies on actual media query support for media queries, though types will work most anywhere\n\texamples:\n\t\t$.mobile.media('screen') // tests for screen media type\n\t\t$.mobile.media('screen and (min-width: 480px)') // tests for screen media type with window width > 480px\n\t\t$.mobile.media('@media screen and (-webkit-min-device-pixel-ratio: 2)') // tests for webkit 2x pixel ratio (iPhone 4)\n*/\n$.mobile.media = (function() {\n\t// TODO: use window.matchMedia once at least one UA implements it\n\tvar cache = {},\n\t\ttestDiv = $( ""<div id='jquery-mediatest'>"" ),\n\t\tfakeBody = $( ""<body>"" ).append( testDiv );\n\n\treturn function( query ) {\n\t\tif ( !( query in cache ) ) {\n\t\t\tvar styleBlock = document.createElement( ""style"" ),\n\t\t\t\tcssrule = ""@media "" + query + "" { #jquery-mediatest { position:absolute; } }"";\n\n\t\t\t//must set type for IE!\n\t\t\tstyleBlock.type = ""text/css"";\n\n\t\t\tif ( styleBlock.styleSheet  ){\n\t\t\t\tstyleBlock.styleSheet.cssText = cssrule;\n\t\t\t} else {\n\t\t\t\tstyleBlock.appendChild( document.createTextNode(cssrule) );\n\t\t\t}\n\n\t\t\t$html.prepend( fakeBody ).prepend( styleBlock );\n\t\t\tcache[ query ] = testDiv.css( ""position"" ) === ""absolute"";\n\t\t\tfakeBody.add( styleBlock ).remove();\n\t\t}\n\t\treturn cache[ query ];\n\t};\n})();\n\n})(jQuery);\n\n(function( $, undefined ) {\n\nvar fakeBody = $( ""<body>"" ).prependTo( ""html"" ),\n\tfbCSS = fakeBody[ 0 ].style,\n\tvendors = [ ""Webkit"", ""Moz"", ""O"" ],\n\twebos = ""palmGetResource"" in window, //only used to rule out scrollTop\n\toperamini = window.operamini && ({}).toString.call( window.operamini ) === ""[object OperaMini]"",\n\tbb = window.blackberry; //only used to rule out box shadow, as it's filled opaque on BB\n\n// thx Modernizr\nfunction propExists( prop ) {\n\tvar uc_prop = prop.charAt( 0 ).toUpperCase() + prop.substr( 1 ),\n\t\tprops = ( prop + "" "" + vendors.join( uc_prop + "" "" ) + uc_prop ).split( "" "" );\n\n\tfor ( var v in props ){\n\t\tif ( fbCSS[ props[ v ] ] !== undefined ) {\n\t\t\treturn true;\n\t\t}\n\t}\n}\n\nfunction validStyle( prop, value, check_vend ) {\n\tvar div = document.createElement('div'),\n\t\tuc = function( txt ) {\n\t\t\treturn txt.charAt( 0 ).toUpperCase() + txt.substr( 1 )\n\t\t},\n\t\tvend_pref = function( vend ) {\n\t\t\treturn  ""-"" + vend.charAt( 0 ).toLowerCase() + vend.substr( 1 ) + ""-"";\n\t\t},\n\t\tcheck_style = function( vend ) {\n\t\t\tvar vend_prop = vend_pref( vend ) + prop + "": "" + value + "";"",\n\t\t\t\tuc_vend = uc( vend ),\n\t\t\t\tpropStyle = uc_vend + uc( prop );\n\t\t\n\t\t\tdiv.setAttribute( ""style"", vend_prop );\n\t\t\n\t\t\tif( !!div.style[ propStyle ] ) {\n\t\t\t\tret = true;\n\t\t\t}\n\t\t},\n\t\tcheck_vends = check_vend ? [ check_vend ] : vendors,\n\t\tret;\n\n\tfor( i = 0; i < check_vends.length; i++ ) {\n\t\tcheck_style( check_vends[i] );\n\t}\n\treturn !!ret;\n}\n\n// Thanks to Modernizr src for this test idea. `perspective` check is limited to Moz to prevent a false positive for 3D transforms on Android.\nfunction transform3dTest() {\n\tvar prop = ""transform-3d"";\n\treturn validStyle( 'perspective', '10px', 'moz' ) || $.mobile.media( ""(-"" + vendors.join( ""-"" + prop + ""),(-"" ) + ""-"" + prop + ""),("" + prop + "")"" );\n}\n\n// Test for dynamic-updating base tag support ( allows us to avoid href,src attr rewriting )\nfunction baseTagTest() {\n\tvar fauxBase = location.protocol + ""//"" + location.host + location.pathname + ""ui-dir/"",\n\t\tbase = $( ""head base"" ),\n\t\tfauxEle = null,\n\t\thref = """",\n\t\tlink, rebase;\n\n\tif ( !base.length ) {\n\t\tbase = fauxEle = $( ""<base>"", { ""href"": fauxBase }).appendTo( ""head"" );\n\t} else {\n\t\thref = base.attr( ""href"" );\n\t}\n\n\tlink = $( ""<a href='testurl' />"" ).prependTo( fakeBody );\n\trebase = link[ 0 ].href;\n\tbase[ 0 ].href = href || location.pathname;\n\n\tif ( fauxEle ) {\n\t\tfauxEle.remove();\n\t}\n\treturn rebase.indexOf( fauxBase ) === 0;\n}\n\n\n// non-UA-based IE version check by James Padolsey, modified by jdalton - from http://gist.github.com/527683\n// allows for inclusion of IE 6+, including Windows Mobile 7\n$.extend( $.mobile, { browser: {} } );\n$.mobile.browser.ie = (function() {\n\tvar v = 3,\n\tdiv = document.createElement( ""div"" ),\n\ta = div.all || [];\n\n\t// added {} to silence closure compiler warnings. registering my dislike of all things\n\t// overly clever here for future reference\n\twhile ( div.innerHTML = ""<!--[if gt IE "" + ( ++v ) + ""]><br><![endif]-->"", a[ 0 ] ){};\n\n\treturn v > 4 ? v : !v;\n})();\n\n\n$.extend( $.support, {\n\torientation: ""orientation"" in window && ""onorientationchange"" in window,\n\ttouch: ""ontouchend"" in document,\n\tcssTransitions: ""WebKitTransitionEvent"" in window || validStyle( 'transition', 'height 100ms linear' ),\n\tpushState: ""pushState"" in history && ""replaceState"" in history,\n\tmediaquery: $.mobile.media( ""only all"" ),\n\tcssPseudoElement: !!propExists( ""content"" ),\n\ttouchOverflow: !!propExists( ""overflowScrolling"" ),\n\tcssTransform3d: transform3dTest(),\n\tboxShadow: !!propExists( ""boxShadow"" ) && !bb,\n\tscrollTop: ( ""pageXOffset"" in window || ""scrollTop"" in document.documentElement || ""scrollTop"" in fakeBody[ 0 ] ) && !webos && !operamini,\n\tdynamicBaseTag: baseTagTest()\n});\n\nfakeBody.remove();\n\n\n// $.mobile.ajaxBlacklist is used to override ajaxEnabled on platforms that have known conflicts with hash history updates (BB5, Symbian)\n// or that generally work better browsing in regular http for full page refreshes (Opera Mini)\n// Note: This detection below is used as a last resort.\n// We recommend only using these detection methods when all other more reliable/forward-looking approaches are not possible\nvar nokiaLTE7_3 = (function(){\n\n\tvar ua = window.navigator.userAgent;\n\n\t//The following is an attempt to match Nokia browsers that are running Symbian/s60, with webkit, version 7.3 or older\n\treturn ua.indexOf( ""Nokia"" ) > -1 &&\n\t\t\t( ua.indexOf( ""Symbian/3"" ) > -1 || ua.indexOf( ""Series60/5"" ) > -1 ) &&\n\t\t\tua.indexOf( ""AppleWebKit"" ) > -1 &&\n\t\t\tua.match( /(BrowserNG|NokiaBrowser)\\/7\\.[0-3]/ );\n})();\n\n// Support conditions that must be met in order to proceed\n// default enhanced qualifications are media query support OR IE 7+\n$.mobile.gradeA = function(){\n\treturn $.support.mediaquery || $.mobile.browser.ie && $.mobile.browser.ie >= 7;\n};\n\n$.mobile.ajaxBlacklist =\n\t\t\t// BlackBerry browsers, pre-webkit\n\t\t\twindow.blackberry && !window.WebKitPoint ||\n\t\t\t// Opera Mini\n\t\t\toperamini ||\n\t\t\t// Symbian webkits pre 7.3\n\t\t\tnokiaLTE7_3;\n\n// Lastly, this workaround is the only way we've found so far to get pre 7.3 Symbian webkit devices\n// to render the stylesheets when they're referenced before this script, as we'd recommend doing.\n// This simply reappends the CSS in place, which for some reason makes it apply\nif ( nokiaLTE7_3 ) {\n\t$(function() {\n\t\t$( ""head link[rel='stylesheet']"" ).attr( ""rel"", ""alternate stylesheet"" ).attr( ""rel"", ""stylesheet"" );\n\t});\n}\n\n// For ruling out shadows via css\nif ( !$.support.boxShadow ) {\n\t$( ""html"" ).addClass( ""ui-mobile-nosupport-boxshadow"" );\n}\n\n})( jQuery );\n\n(function( $, window, undefined ) {\n\n// add new event shortcuts\n$.each( ( ""touchstart touchmove touchend orientationchange throttledresize "" +\n\t\t\t\t\t""tap taphold swipe swipeleft swiperight scrollstart scrollstop"" ).split( "" "" ), function( i, name ) {\n\n\t$.fn[ name ] = function( fn ) {\n\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t};\n\n\t$.attrFn[ name ] = true;\n});\n\nvar supportTouch = $.support.touch,\n\tscrollEvent = ""touchmove scroll"",\n\ttouchStartEvent = supportTouch ? ""touchstart"" : ""mousedown"",\n\ttouchStopEvent = supportTouch ? ""touchend"" : ""mouseup"",\n\ttouchMoveEvent = supportTouch ? ""touchmove"" : ""mousemove"";\n\nfunction triggerCustomEvent( obj, eventType, event ) {\n\tvar originalType = event.type;\n\tevent.type = eventType;\n\t$.event.handle.call( obj, event );\n\tevent.type = originalType;\n}\n\n// also handles scrollstop\n$.event.special.scrollstart = {\n\n\tenabled: true,\n\n\tsetup: function() {\n\n\t\tvar thisObject = this,\n\t\t\t$this = $( thisObject ),\n\t\t\tscrolling,\n\t\t\ttimer;\n\n\t\tfunction trigger( event, state ) {\n\t\t\tscrolling = state;\n\t\t\ttriggerCustomEvent( thisObject, scrolling ? ""scrollstart"" : ""scrollstop"", event );\n\t\t}\n\n\t\t// iPhone triggers scroll after a small delay; use touchmove instead\n\t\t$this.bind( scrollEvent, function( event ) {\n\n\t\t\tif ( !$.event.special.scrollstart.enabled ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( !scrolling ) {\n\t\t\t\ttrigger( event, true );\n\t\t\t}\n\n\t\t\tclearTimeout( timer );\n\t\t\ttimer = setTimeout(function() {\n\t\t\t\ttrigger( event, false );\n\t\t\t}, 50 );\n\t\t});\n\t}\n};\n\n// also handles taphold\n$.event.special.tap = {\n\tsetup: function() {\n\t\tvar thisObject = this,\n\t\t\t$this = $( thisObject );\n\n\t\t$this.bind( ""vmousedown"", function( event ) {\n\n\t\t\tif ( event.which && event.which !== 1 ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar origTarget = event.target,\n\t\t\t\torigEvent = event.originalEvent,\n\t\t\t\ttimer;\n\n\t\t\tfunction clearTapTimer() {\n\t\t\t\tclearTimeout( timer );\n\t\t\t}\n\n\t\t\tfunction clearTapHandlers() {\n\t\t\t\tclearTapTimer();\n\n\t\t\t\t$this.unbind( ""vclick"", clickHandler )\n\t\t\t\t\t.unbind( ""vmouseup"", clearTapTimer );\n\t\t\t\t$( document ).unbind( ""vmousecancel"", clearTapHandlers );\n\t\t\t}\n\n\t\t\tfunction clickHandler(event) {\n\t\t\t\tclearTapHandlers();\n\n\t\t\t\t// ONLY trigger a 'tap' event if the start target is\n\t\t\t\t// the same as the stop target.\n\t\t\t\tif ( origTarget == event.target ) {\n\t\t\t\t\ttriggerCustomEvent( thisObject, ""tap"", event );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$this.bind( ""vmouseup"", clearTapTimer )\n\t\t\t\t.bind( ""vclick"", clickHandler );\n\t\t\t$( document ).bind( ""vmousecancel"", clearTapHandlers );\n\n\t\t\ttimer = setTimeout(function() {\n\t\t\t\t\ttriggerCustomEvent( thisObject, ""taphold"", $.Event( ""taphold"", { target: origTarget } ) );\n\t\t\t}, 750 );\n\t\t});\n\t}\n};\n\n// also handles swipeleft, swiperight\n$.event.special.swipe = {\n\tscrollSupressionThreshold: 10, // More than this horizontal displacement, and we will suppress scrolling.\n\n\tdurationThreshold: 1000, // More time than this, and it isn't a swipe.\n\n\thorizontalDistanceThreshold: 30,  // Swipe horizontal displacement must be more than this.\n\n\tverticalDistanceThreshold: 75,  // Swipe vertical displacement must be less than this.\n\n\tsetup: function() {\n\t\tvar thisObject = this,\n\t\t\t$this = $( thisObject );\n\n\t\t$this.bind( touchStartEvent, function( event ) {\n\t\t\tvar data = event.originalEvent.touches ?\n\t\t\t\t\t\t\t\tevent.originalEvent.touches[ 0 ] : event,\n\t\t\t\tstart = {\n\t\t\t\t\ttime: ( new Date() ).getTime(),\n\t\t\t\t\tcoords: [ data.pageX, data.pageY ],\n\t\t\t\t\torigin: $( event.target )\n\t\t\t\t},\n\t\t\t\tstop;\n\n\t\t\tfunction moveHandler( event ) {\n\n\t\t\t\tif ( !start ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar data = event.originalEvent.touches ?\n\t\t\t\t\t\tevent.originalEvent.touches[ 0 ] : event;\n\n\t\t\t\tstop = {\n\t\t\t\t\ttime: ( new Date() ).getTime(),\n\t\t\t\t\tcoords: [ data.pageX, data.pageY ]\n\t\t\t\t};\n\n\t\t\t\t// prevent scrolling\n\t\t\t\tif ( Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.scrollSupressionThreshold ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$this.bind( touchMoveEvent, moveHandler )\n\t\t\t\t.one( touchStopEvent, function( event ) {\n\t\t\t\t\t$this.unbind( touchMoveEvent, moveHandler );\n\n\t\t\t\t\tif ( start && stop ) {\n\t\t\t\t\t\tif ( stop.time - start.time < $.event.special.swipe.durationThreshold &&\n\t\t\t\t\t\t\t\tMath.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.horizontalDistanceThreshold &&\n\t\t\t\t\t\t\t\tMath.abs( start.coords[ 1 ] - stop.coords[ 1 ] ) < $.event.special.swipe.verticalDistanceThreshold ) {\n\n\t\t\t\t\t\t\tstart.origin.trigger( ""swipe"" )\n\t\t\t\t\t\t\t\t.trigger( start.coords[0] > stop.coords[ 0 ] ? ""swipeleft"" : ""swiperight"" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstart = stop = undefined;\n\t\t\t\t});\n\t\t});\n\t}\n};\n\n(function( $, window ) {\n\t// ""Cowboy"" Ben Alman\n\n\tvar win = $( window ),\n\t\tspecial_event,\n\t\tget_orientation,\n\t\tlast_orientation,\n\t\tinitial_orientation_is_landscape,\n\t\tinitial_orientation_is_default,\n\t\tportrait_map = { ""0"": true, ""180"": true };\n\n\t// It seems that some device/browser vendors use window.orientation values 0 and 180 to\n\t// denote the ""default"" orientation. For iOS devices, and most other smart-phones tested,\n\t// the default orientation is always ""portrait"", but in some Android and RIM based tablets,\n\t// the default orientation is ""landscape"". The following code attempts to use the window\n\t// dimensions to figure out what the current orientation is, and then makes adjustments\n\t// to the to the portrait_map if necessary, so that we can properly decode the\n\t// window.orientation value whenever get_orientation() is called.\n\t//\n\t// Note that we used to use a media query to figure out what the orientation the browser\n\t// thinks it is in:\n\t//\n\t//     initial_orientation_is_landscape = $.mobile.media(""all and (orientation: landscape)"");\n\t//\n\t// but there was an iPhone/iPod Touch bug beginning with iOS 4.2, up through iOS 5.1,\n\t// where the browser *ALWAYS* applied the landscape media query. This bug does not\n\t// happen on iPad.\n\n\tif ( $.support.orientation ) {\n\n\t\t// Check the window width and height to figure out what the current orientation\n\t\t// of the device is at this moment. Note that we've initialized the portrait map\n\t\t// values to 0 and 180, *AND* we purposely check for landscape so that if we guess\n\t\t// wrong, , we default to the assumption that portrait is the default orientation.\n\t\t// We use a threshold check below because on some platforms like iOS, the iPhone\n\t\t// form-factor can report a larger width than height if the user turns on the\n\t\t// developer console. The actual threshold value is somewhat arbitrary, we just\n\t\t// need to make sure it is large enough to exclude the developer console case.\n\n\t\tvar ww = window.innerWidth || $( window ).width(),\n\t\t\twh = window.innerHeight || $( window ).height(),\n\t\t\tlandscape_threshold = 50;\n\n\t\tinitial_orientation_is_landscape = ww > wh && ( ww - wh ) > landscape_threshold;\n\n\n\t\t// Now check to see if the current window.orientation is 0 or 180.\n\t\tinitial_orientation_is_default = portrait_map[ window.orientation ];\n\n\t\t// If the initial orientation is landscape, but window.orientation reports 0 or 180, *OR*\n\t\t// if the initial orientation is portrait, but window.orientation reports 90 or -90, we\n\t\t// need to flip our portrait_map values because landscape is the default orientation for\n\t\t// this device/browser.\n\t\tif ( ( initial_orientation_is_landscape && initial_orientation_is_default ) || ( !initial_orientation_is_landscape && !initial_orientation_is_default ) ) {\n\t\t\tportrait_map = { ""-90"": true, ""90"": true };\n\t\t}\n\t}\n\n\t$.event.special.orientationchange = special_event = {\n\t\tsetup: function() {\n\t\t\t// If the event is supported natively, return false so that jQuery\n\t\t\t// will bind to the event using DOM methods.\n\t\t\tif ( $.support.orientation && $.mobile.orientationChangeEnabled ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Get the current orientation to avoid initial double-triggering.\n\t\t\tlast_orientation = get_orientation();\n\n\t\t\t// Because the orientationchange event doesn't exist, simulate the\n\t\t\t// event by testing window dimensions on resize.\n\t\t\twin.bind( ""throttledresize"", handler );\n\t\t},\n\t\tteardown: function(){\n\t\t\t// If the event is not supported natively, return false so that\n\t\t\t// jQuery will unbind the event using DOM methods.\n\t\t\tif ( $.support.orientation && $.mobile.orientationChangeEnabled ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Because the orientationchange event doesn't exist, unbind the\n\t\t\t// resize event handler.\n\t\t\twin.unbind( ""throttledresize"", handler );\n\t\t},\n\t\tadd: function( handleObj ) {\n\t\t\t// Save a reference to the bound event handler.\n\t\t\tvar old_handler = handleObj.handler;\n\n\n\t\t\thandleObj.handler = function( event ) {\n\t\t\t\t// Modify event object, adding the .orientation property.\n\t\t\t\tevent.orientation = get_orientation();\n\n\t\t\t\t// Call the originally-bound event handler and return its result.\n\t\t\t\treturn old_handler.apply( this, arguments );\n\t\t\t};\n\t\t}\n\t};\n\n\t// If the event is not supported natively, this handler will be bound to\n\t// the window resize event to simulate the orientationchange event.\n\tfunction handler() {\n\t\t// Get the current orientation.\n\t\tvar orientation = get_orientation();\n\n\t\tif ( orientation !== last_orientation ) {\n\t\t\t// The orientation has changed, so trigger the orientationchange event.\n\t\t\tlast_orientation = orientation;\n\t\t\twin.trigger( ""orientationchange"" );\n\t\t}\n\t}\n\n\t// Get the current page orientation. This method is exposed publicly, should it\n\t// be needed, as jQuery.event.special.orientationchange.orientation()\n\t$.event.special.orientationchange.orientation = get_orientation = function() {\n\t\tvar isPortrait = true, elem = document.documentElement;\n\n\t\t// prefer window orientation to the calculation based on screensize as\n\t\t// the actual screen resize takes place before or after the orientation change event\n\t\t// has been fired depending on implementation (eg android 2.3 is before, iphone after).\n\t\t// More testing is required to determine if a more reliable method of determining the new screensize\n\t\t// is possible when orientationchange is fired. (eg, use media queries + element + opacity)\n\t\tif ( $.support.orientation ) {\n\t\t\t// if the window orientation registers as 0 or 180 degrees report\n\t\t\t// portrait, otherwise landscape\n\t\t\tisPortrait = portrait_map[ window.orientation ];\n\t\t} else {\n\t\t\tisPortrait = elem && elem.clientWidth / elem.clientHeight < 1.1;\n\t\t}\n\n\t\treturn isPortrait ? ""portrait"" : ""landscape"";\n\t};\n\n})( jQuery, window );\n\n\n// throttled resize event\n(function() {\n\n\t$.event.special.throttledresize = {\n\t\tsetup: function() {\n\t\t\t$( this ).bind( ""resize"", handler );\n\t\t},\n\t\tteardown: function(){\n\t\t\t$( this ).unbind( ""resize"", handler );\n\t\t}\n\t};\n\n\tvar throttle = 250,\n\t\thandler = function() {\n\t\t\tcurr = ( new Date() ).getTime();\n\t\t\tdiff = curr - lastCall;\n\n\t\t\tif ( diff >= throttle ) {\n\n\t\t\t\tlastCall = curr;\n\t\t\t\t$( this ).trigger( ""throttledresize"" );\n\n\t\t\t} else {\n\n\t\t\t\tif ( heldCall ) {\n\t\t\t\t\tclearTimeout( heldCall );\n\t\t\t\t}\n\n\t\t\t\t// Promise a held call will still execute\n\t\t\t\theldCall = setTimeout( handler, throttle - diff );\n\t\t\t}\n\t\t},\n\t\tlastCall = 0,\n\t\theldCall,\n\t\tcurr,\n\t\tdiff;\n})();\n\n\n$.each({\n\tscrollstop: ""scrollstart"",\n\ttaphold: ""tap"",\n\tswipeleft: ""swipe"",\n\tswiperight: ""swipe""\n}, function( event, sourceEvent ) {\n\n\t$.event.special[ event ] = {\n\t\tsetup: function() {\n\t\t\t$( this ).bind( sourceEvent, $.noop );\n\t\t}\n\t};\n});\n\n})( jQuery, this );\n\n(function( $, undefined ) {\n\n$.widget( ""mobile.page"", $.mobile.widget, {\n\toptions: {\n\t\ttheme: ""c"",\n\t\tdomCache: false,\n\t\tkeepNativeDefault: "":jqmData(role='none'), :jqmData(role='nojs')""\n\t},\n\n\t_create: function() {\n\t\t\n\t\tvar self = this;\n\t\t\n\t\t// if false is returned by the callbacks do not create the page\n\t\tif( self._trigger( ""beforecreate"" ) === false ){\n\t\t\treturn false;\n\t\t}\n\n\t\tself.element\n\t\t\t.attr( ""tabindex"", ""0"" )\n\t\t\t.addClass( ""ui-page ui-body-"" + self.options.theme )\n\t\t\t.bind( ""pagebeforehide"", function(){\n\t\t\t\tself.removeContainerBackground();\n\t\t\t} )\n\t\t\t.bind( ""pagebeforeshow"", function(){\n\t\t\t\tself.setContainerBackground();\n\t\t\t} );\n\n\t},\n\t\n\tremoveContainerBackground: function(){\n\t\t$.mobile.pageContainer.removeClass( ""ui-overlay-"" + $.mobile.getInheritedTheme( this.element.parent() ) );\n\t},\n\t\n\t// set the page container background to the page theme\n\tsetContainerBackground: function( theme ){\n\t\tif( this.options.theme ){\n\t\t\t$.mobile.pageContainer.addClass( ""ui-overlay-"" + ( theme || this.options.theme ) );\n\t\t}\n\t},\n\n\tkeepNativeSelector: function() {\n\t\tvar options = this.options,\n\t\t\tkeepNativeDefined = options.keepNative && $.trim(options.keepNative);\n\n\t\tif( keepNativeDefined && options.keepNative !== options.keepNativeDefault ){\n\t\t\treturn [options.keepNative, options.keepNativeDefault].join("", "");\n\t\t}\n\n\t\treturn options.keepNativeDefault;\n\t}\n});\n})( jQuery );\n\n\n(function( $, window, undefined ) {\n\nvar createHandler = function( sequential ){\n\t\n\t// Default to sequential\n\tif( sequential === undefined ){\n\t\tsequential = true;\n\t}\n\t\n\treturn function( name, reverse, $to, $from ) {\n\n\t\tvar deferred = new $.Deferred(),\n\t\t\treverseClass = reverse ? "" reverse"" : """",\n\t\t\tactive\t= $.mobile.urlHistory.getActive(),\n\t\t\ttoScroll = active.lastScroll || $.mobile.defaultHomeScroll,\n\t\t\tscreenHeight = $.mobile.getScreenHeight(),\n\t\t\tmaxTransitionOverride = $.mobile.maxTransitionWidth !== false && $( window ).width() > $.mobile.maxTransitionWidth,\n\t\t\tnone = !$.support.cssTransitions || maxTransitionOverride || !name || name === ""none"",\n\t\t\ttoggleViewportClass = function(){\n\t\t\t\t$.mobile.pageContainer.toggleClass( ""ui-mobile-viewport-transitioning viewport-"" + name );\n\t\t\t},\n\t\t\tscrollPage = function(){\n\t\t\t\t// By using scrollTo instead of silentScroll, we can keep things better in order\n\t\t\t\t// Just to be precautios, disable scrollstart listening like silentScroll would\n\t\t\t\t$.event.special.scrollstart.enabled = false;\n\t\t\t\t\n\t\t\t\twindow.scrollTo( 0, toScroll );\n\t\t\t\t\n\t\t\t\t// reenable scrollstart listening like silentScroll would\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t$.event.special.scrollstart.enabled = true;\n\t\t\t\t}, 150 );\n\t\t\t},\n\t\t\tcleanFrom = function(){\n\t\t\t\t$from\n\t\t\t\t\t.removeClass( $.mobile.activePageClass + "" out in reverse "" + name )\n\t\t\t\t\t.height( """" );\n\t\t\t},\n\t\t\tstartOut = function(){\n\t\t\t\t// if it's not sequential, call the doneOut transition to start the TO page animating in simultaneously\n\t\t\t\tif( !sequential ){\n\t\t\t\t\tdoneOut();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$from.animationComplete( doneOut );\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Set the from page's height and start it transitioning out\n\t\t\t\t// Note: setting an explicit height helps eliminate tiling in the transitions\n\t\t\t\t$from\n\t\t\t\t\t.height( screenHeight + $(window ).scrollTop() )\n\t\t\t\t\t.addClass( name + "" out"" + reverseClass );\n\t\t\t},\n\t\t\t\n\t\t\tdoneOut = function() {\n\n\t\t\t\tif ( $from && sequential ) {\n\t\t\t\t\tcleanFrom();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstartIn();\n\t\t\t},\n\t\t\t\n\t\t\tstartIn = function(){\t\n\t\t\t\n\t\t\t\t$to.addClass( $.mobile.activePageClass );\t\t\t\t\n\t\t\t\n\t\t\t\t// Send focus to page as it is now display: block\n\t\t\t\t$.mobile.focusPage( $to );\n\n\t\t\t\t// Set to page height\n\t\t\t\t$to.height( screenHeight + toScroll );\n\t\t\t\t\n\t\t\t\tscrollPage();\n\t\t\t\t\n\t\t\t\tif( !none ){\n\t\t\t\t\t$to.animationComplete( doneIn );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$to.addClass( name + "" in"" + reverseClass );\n\t\t\t\t\n\t\t\t\tif( none ){\n\t\t\t\t\tdoneIn();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t},\n\t\t\n\t\t\tdoneIn = function() {\n\t\t\t\n\t\t\t\tif ( !sequential ) {\n\t\t\t\t\t\n\t\t\t\t\tif( $from ){\n\t\t\t\t\t\tcleanFrom();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t\t$to\n\t\t\t\t\t.removeClass( ""out in reverse "" + name )\n\t\t\t\t\t.height( """" );\n\t\t\t\t\n\t\t\t\ttoggleViewportClass();\n\t\t\t\t\n\t\t\t\t// In some browsers (iOS5), 3D transitions block the ability to scroll to the desired location during transition\n\t\t\t\t// This ensures we jump to that spot after the fact, if we aren't there already.\n\t\t\t\tif( $( window ).scrollTop() !== toScroll ){\n\t\t\t\t\tscrollPage();\n\t\t\t\t}\n\n\t\t\t\tdeferred.resolve( name, reverse, $to, $from, true );\n\t\t\t};\n\n\t\ttoggleViewportClass();\n\t\n\t\tif ( $from && !none ) {\n\t\t\tstartOut();\n\t\t}\n\t\telse {\n\t\t\tdoneOut();\n\t\t}\n\n\t\treturn deferred.promise();\n\t};\n}\n\n// generate the handlers from the above\nvar sequentialHandler = createHandler(),\n\tsimultaneousHandler = createHandler( false );\n\n// Make our transition handler the public default.\n$.mobile.defaultTransitionHandler = sequentialHandler;\n\n//transition handler dictionary for 3rd party transitions\n$.mobile.transitionHandlers = {\n\t""default"": $.mobile.defaultTransitionHandler,\n\t""sequential"": sequentialHandler,\n\t""simultaneous"": simultaneousHandler\n};\n\n$.mobile.transitionFallbacks = {};\n\n})( jQuery, this );\n\n( function( $, undefined ) {\n\n\t//define vars for interal use\n\tvar $window = $( window ),\n\t\t$html = $( 'html' ),\n\t\t$head = $( 'head' ),\n\n\t\t//url path helpers for use in relative url management\n\t\tpath = {\n\n\t\t\t// This scary looking regular expression parses an absolute URL or its relative\n\t\t\t// variants (protocol, site, document, query, and hash), into the various\n\t\t\t// components (protocol, host, path, query, fragment, etc that make up the\n\t\t\t// URL as well as some other commonly used sub-parts. When used with RegExp.exec()\n\t\t\t// or String.match, it parses the URL into a results array that looks like this:\n\t\t\t//\n\t\t\t//     [0]: http://jblas:password@mycompany.com:8080/mail/inbox?msg=1234&type=unread#msg-content\n\t\t\t//     [1]: http://jblas:password@mycompany.com:8080/mail/inbox?msg=1234&type=unread\n\t\t\t//     [2]: http://jblas:password@mycompany.com:8080/mail/inbox\n\t\t\t//     [3]: http://jblas:password@mycompany.com:8080\n\t\t\t//     [4]: http:\n\t\t\t//     [5]: //\n\t\t\t//     [6]: jblas:password@mycompany.com:8080\n\t\t\t//     [7]: jblas:password\n\t\t\t//     [8]: jblas\n\t\t\t//     [9]: password\n\t\t\t//    [10]: mycompany.com:8080\n\t\t\t//    [11]: mycompany.com\n\t\t\t//    [12]: 8080\n\t\t\t//    [13]: /mail/inbox\n\t\t\t//    [14]: /mail/\n\t\t\t//    [15]: inbox\n\t\t\t//    [16]: ?msg=1234&type=unread\n\t\t\t//    [17]: #msg-content\n\t\t\t//\n\t\t\turlParseRE: /^(((([^:\\/#\\?]+:)?(?:(\\/\\/)((?:(([^:@\\/#\\?]+)(?:\\:([^:@\\/#\\?]+))?)@)?(([^:\\/#\\?\\]\\[]+|\\[[^\\/\\]@#?]+\\])(?:\\:([0-9]+))?))?)?)?((\\/?(?:[^\\/\\?#]+\\/+)*)([^\\?#]*)))?(\\?[^#]+)?)(#.*)?/,\n\n\t\t\t//Parse a URL into a structure that allows easy access to\n\t\t\t//all of the URL components by name.\n\t\t\tparseUrl: function( url ) {\n\t\t\t\t// If we're passed an object, we'll assume that it is\n\t\t\t\t// a parsed url object and just return it back to the caller.\n\t\t\t\tif ( $.type( url ) === ""object"" ) {\n\t\t\t\t\treturn url;\n\t\t\t\t}\n\n\t\t\t\tvar matches = path.urlParseRE.exec( url || """" ) || [];\n\n\t\t\t\t\t// Create an object that allows the caller to access the sub-matches\n\t\t\t\t\t// by name. Note that IE returns an empty string instead of undefined,\n\t\t\t\t\t// like all other browsers do, so we normalize everything so its consistent\n\t\t\t\t\t// no matter what browser we're running on.\n\t\t\t\t\treturn {\n\t\t\t\t\t\thref:         matches[  0 ] || """",\n\t\t\t\t\t\threfNoHash:   matches[  1 ] || """",\n\t\t\t\t\t\threfNoSearch: matches[  2 ] || """",\n\t\t\t\t\t\tdomain:       matches[  3 ] || """",\n\t\t\t\t\t\tprotocol:     matches[  4 ] || """",\n\t\t\t\t\t\tdoubleSlash:  matches[  5 ] || """",\n\t\t\t\t\t\tauthority:    matches[  6 ] || """",\n\t\t\t\t\t\tusername:     matches[  8 ] || """",\n\t\t\t\t\t\tpassword:     matches[  9 ] || """",\n\t\t\t\t\t\thost:         matches[ 10 ] || """",\n\t\t\t\t\t\thostname:     matches[ 11 ] || """",\n\t\t\t\t\t\tport:         matches[ 12 ] || """",\n\t\t\t\t\t\tpathname:     matches[ 13 ] || """",\n\t\t\t\t\t\tdirectory:    matches[ 14 ] || """",\n\t\t\t\t\t\tfilename:     matches[ 15 ] || """",\n\t\t\t\t\t\tsearch:       matches[ 16 ] || """",\n\t\t\t\t\t\thash:         matches[ 17 ] || """"\n\t\t\t\t\t};\n\t\t\t},\n\n\t\t\t//Turn relPath into an asbolute path. absPath is\n\t\t\t//an optional absolute path which describes what\n\t\t\t//relPath is relative to.\n\t\t\tmakePathAbsolute: function( relPath, absPath ) {\n\t\t\t\tif ( relPath && relPath.charAt( 0 ) === ""/"" ) {\n\t\t\t\t\treturn relPath;\n\t\t\t\t}\n\n\t\t\t\trelPath = relPath || """";\n\t\t\t\tabsPath = absPath ? absPath.replace( /^\\/|(\\/[^\\/]*|[^\\/]+)$/g, """" ) : """";\n\n\t\t\t\tvar absStack = absPath ? absPath.split( ""/"" ) : [],\n\t\t\t\t\trelStack = relPath.split( ""/"" );\n\t\t\t\tfor ( var i = 0; i < relStack.length; i++ ) {\n\t\t\t\t\tvar d = relStack[ i ];\n\t\t\t\t\tswitch ( d ) {\n\t\t\t\t\t\tcase ""."":\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase "".."":\n\t\t\t\t\t\t\tif ( absStack.length ) {\n\t\t\t\t\t\t\t\tabsStack.pop();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tabsStack.push( d );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ""/"" + absStack.join( ""/"" );\n\t\t\t},\n\n\t\t\t//Returns true if both urls have the same domain.\n\t\t\tisSameDomain: function( absUrl1, absUrl2 ) {\n\t\t\t\treturn path.parseUrl( absUrl1 ).domain === path.parseUrl( absUrl2 ).domain;\n\t\t\t},\n\n\t\t\t//Returns true for any relative variant.\n\t\t\tisRelativeUrl: function( url ) {\n\t\t\t\t// All relative Url variants have one thing in common, no protocol.\n\t\t\t\treturn path.parseUrl( url ).protocol === """";\n\t\t\t},\n\n\t\t\t//Returns true for an absolute url.\n\t\t\tisAbsoluteUrl: function( url ) {\n\t\t\t\treturn path.parseUrl( url ).protocol !== """";\n\t\t\t},\n\n\t\t\t//Turn the specified realtive URL into an absolute one. This function\n\t\t\t//can handle all relative variants (protocol, site, document, query, fragment).\n\t\t\tmakeUrlAbsolute: function( relUrl, absUrl ) {\n\t\t\t\tif ( !path.isRelativeUrl( relUrl ) ) {\n\t\t\t\t\treturn relUrl;\n\t\t\t\t}\n\n\t\t\t\tvar relObj = path.parseUrl( relUrl ),\n\t\t\t\t\tabsObj = path.parseUrl( absUrl ),\n\t\t\t\t\tprotocol = relObj.protocol || absObj.protocol,\n\t\t\t\t\tdoubleSlash = relObj.protocol ? relObj.doubleSlash : ( relObj.doubleSlash || absObj.doubleSlash ),\n\t\t\t\t\tauthority = relObj.authority || absObj.authority,\n\t\t\t\t\thasPath = relObj.pathname !== """",\n\t\t\t\t\tpathname = path.makePathAbsolute( relObj.pathname || absObj.filename, absObj.pathname ),\n\t\t\t\t\tsearch = relObj.search || ( !hasPath && absObj.search ) || """",\n\t\t\t\t\thash = relObj.hash;\n\n\t\t\t\treturn protocol + doubleSlash + authority + pathname + search + hash;\n\t\t\t},\n\n\t\t\t//Add search (aka query) params to the specified url.\n\t\t\taddSearchParams: function( url, params ) {\n\t\t\t\tvar u = path.parseUrl( url ),\n\t\t\t\t\tp = ( typeof params === ""object"" ) ? $.param( params ) : params,\n\t\t\t\t\ts = u.search || ""?"";\n\t\t\t\treturn u.hrefNoSearch + s + ( s.charAt( s.length - 1 ) !== ""?"" ? ""&"" : """" ) + p + ( u.hash || """" );\n\t\t\t},\n\n\t\t\tconvertUrlToDataUrl: function( absUrl ) {\n\t\t\t\tvar u = path.parseUrl( absUrl );\n\t\t\t\tif ( path.isEmbeddedPage( u ) ) {\n\t\t\t\t    // For embedded pages, remove the dialog hash key as in getFilePath(),\n\t\t\t\t    // otherwise the Data Url won't match the id of the embedded Page.\n\t\t\t\t\treturn u.hash.split( dialogHashKey )[0].replace( /^#/, """" );\n\t\t\t\t} else if ( path.isSameDomain( u, documentBase ) ) {\n\t\t\t\t\treturn u.hrefNoHash.replace( documentBase.domain, """" );\n\t\t\t\t}\n\t\t\t\treturn absUrl;\n\t\t\t},\n\n\t\t\t//get path from current hash, or from a file path\n\t\t\tget: function( newPath ) {\n\t\t\t\tif( newPath === undefined ) {\n\t\t\t\t\tnewPath = location.hash;\n\t\t\t\t}\n\t\t\t\treturn path.stripHash( newPath ).replace( /[^\\/]*\\.[^\\/*]+$/, '' );\n\t\t\t},\n\n\t\t\t//return the substring of a filepath before the sub-page key, for making a server request\n\t\t\tgetFilePath: function( path ) {\n\t\t\t\tvar splitkey = '&' + $.mobile.subPageUrlKey;\n\t\t\t\treturn path && path.split( splitkey )[0].split( dialogHashKey )[0];\n\t\t\t},\n\n\t\t\t//set location hash to path\n\t\t\tset: function( path ) {\n\t\t\t\tlocation.hash = path;\n\t\t\t},\n\n\t\t\t//test if a given url (string) is a path\n\t\t\t//NOTE might be exceptionally naive\n\t\t\tisPath: function( url ) {\n\t\t\t\treturn ( /\\// ).test( url );\n\t\t\t},\n\n\t\t\t//return a url path with the window's location protocol/hostname/pathname removed\n\t\t\tclean: function( url ) {\n\t\t\t\treturn url.replace( documentBase.domain, """" );\n\t\t\t},\n\n\t\t\t//just return the url without an initial #\n\t\t\tstripHash: function( url ) {\n\t\t\t\treturn url.replace( /^#/, """" );\n\t\t\t},\n\n\t\t\t//remove the preceding hash, any query params, and dialog notations\n\t\t\tcleanHash: function( hash ) {\n\t\t\t\treturn path.stripHash( hash.replace( /\\?.*$/, """" ).replace( dialogHashKey, """" ) );\n\t\t\t},\n\n\t\t\t//check whether a url is referencing the same domain, or an external domain or different protocol\n\t\t\t//could be mailto, etc\n\t\t\tisExternal: function( url ) {\n\t\t\t\tvar u = path.parseUrl( url );\n\t\t\t\treturn u.protocol && u.domain !== documentUrl.domain ? true : false;\n\t\t\t},\n\n\t\t\thasProtocol: function( url ) {\n\t\t\t\treturn ( /^(:?\\w+:)/ ).test( url );\n\t\t\t},\n\n\t\t\t//check if the specified url refers to the first page in the main application document.\n\t\t\tisFirstPageUrl: function( url ) {\n\t\t\t\t// We only deal with absolute paths.\n\t\t\t\tvar u = path.parseUrl( path.makeUrlAbsolute( url, documentBase ) ),\n\n\t\t\t\t\t// Does the url have the same path as the document?\n\t\t\t\t\tsamePath = u.hrefNoHash === documentUrl.hrefNoHash || ( documentBaseDiffers && u.hrefNoHash === documentBase.hrefNoHash ),\n\n\t\t\t\t\t// Get the first page element.\n\t\t\t\t\tfp = $.mobile.firstPage,\n\n\t\t\t\t\t// Get the id of the first page element if it has one.\n\t\t\t\t\tfpId = fp && fp[0] ? fp[0].id : undefined;\n\n\t\t\t\t\t// The url refers to the first page if the path matches the document and\n\t\t\t\t\t// it either has no hash value, or the hash is exactly equal to the id of the\n\t\t\t\t\t// first page element.\n\t\t\t\t\treturn samePath && ( !u.hash || u.hash === ""#"" || ( fpId && u.hash.replace( /^#/, """" ) === fpId ) );\n\t\t\t},\n\n\t\t\tisEmbeddedPage: function( url ) {\n\t\t\t\tvar u = path.parseUrl( url );\n\n\t\t\t\t//if the path is absolute, then we need to compare the url against\n\t\t\t\t//both the documentUrl and the documentBase. The main reason for this\n\t\t\t\t//is that links embedded within external documents will refer to the\n\t\t\t\t//application document, whereas links embedded within the application\n\t\t\t\t//document will be resolved against the document base.\n\t\t\t\tif ( u.protocol !== """" ) {\n\t\t\t\t\treturn ( u.hash && ( u.hrefNoHash === documentUrl.hrefNoHash || ( documentBaseDiffers && u.hrefNoHash === documentBase.hrefNoHash ) ) );\n\t\t\t\t}\n\t\t\t\treturn (/^#/).test( u.href );\n\t\t\t}\n\t\t},\n\n\t\t//will be defined when a link is clicked and given an active class\n\t\t$activeClickedLink = null,\n\n\t\t//urlHistory is purely here to make guesses at whether the back or forward button was clicked\n\t\t//and provide an appropriate transition\n\t\turlHistory = {\n\t\t\t// Array of pages that are visited during a single page load.\n\t\t\t// Each has a url and optional transition, title, and pageUrl (which represents the file path, in cases where URL is obscured, such as dialogs)\n\t\t\tstack: [],\n\n\t\t\t//maintain an index number for the active page in the stack\n\t\t\tactiveIndex: 0,\n\n\t\t\t//get active\n\t\t\tgetActive: function() {\n\t\t\t\treturn urlHistory.stack[ urlHistory.activeIndex ];\n\t\t\t},\n\n\t\t\tgetPrev: function() {\n\t\t\t\treturn urlHistory.stack[ urlHistory.activeIndex - 1 ];\n\t\t\t},\n\n\t\t\tgetNext: function() {\n\t\t\t\treturn urlHistory.stack[ urlHistory.activeIndex + 1 ];\n\t\t\t},\n\n\t\t\t// addNew is used whenever a new page is added\n\t\t\taddNew: function( url, transition, title, pageUrl, role ) {\n\t\t\t\t//if there's forward history, wipe it\n\t\t\t\tif( urlHistory.getNext() ) {\n\t\t\t\t\turlHistory.clearForward();\n\t\t\t\t}\n\n\t\t\t\turlHistory.stack.push( {url : url, transition: transition, title: title, pageUrl: pageUrl, role: role } );\n\n\t\t\t\turlHistory.activeIndex = urlHistory.stack.length - 1;\n\t\t\t},\n\n\t\t\t//wipe urls ahead of active index\n\t\t\tclearForward: function() {\n\t\t\t\turlHistory.stack = urlHistory.stack.slice( 0, urlHistory.activeIndex + 1 );\n\t\t\t},\n\n\t\t\tdirectHashChange: function( opts ) {\n\t\t\t\tvar back , forward, newActiveIndex, prev = this.getActive();\n\n\t\t\t\t// check if url isp in history and if it's ahead or behind current page\n\t\t\t\t$.each( urlHistory.stack, function( i, historyEntry ) {\n\n\t\t\t\t\t//if the url is in the stack, it's a forward or a back\n\t\t\t\t\tif( opts.currentUrl === historyEntry.url ) {\n\t\t\t\t\t\t//define back and forward by whether url is older or newer than current page\n\t\t\t\t\t\tback = i < urlHistory.activeIndex;\n\t\t\t\t\t\tforward = !back;\n\t\t\t\t\t\tnewActiveIndex = i;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// save new page index, null check to prevent falsey 0 result\n\t\t\t\tthis.activeIndex = newActiveIndex !== undefined ? newActiveIndex : this.activeIndex;\n\n\t\t\t\tif( back ) {\n\t\t\t\t\t( opts.either || opts.isBack )( true );\n\t\t\t\t} else if( forward ) {\n\t\t\t\t\t( opts.either || opts.isForward )( false );\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t//disable hashchange event listener internally to ignore one change\n\t\t\t//toggled internally when location.hash is updated to match the url of a successful page load\n\t\t\tignoreNextHashChange: false\n\t\t},\n\n\t\t//define first selector to receive focus when a page is shown\n\t\tfocusable = ""[tabindex],a,button:visible,select:visible,input"",\n\n\t\t//queue to hold simultanious page transitions\n\t\tpageTransitionQueue = [],\n\n\t\t//indicates whether or not page is in process of transitioning\n\t\tisPageTransitioning = false,\n\n\t\t//nonsense hash change key for dialogs, so they create a history entry\n\t\tdialogHashKey = ""&ui-state=dialog"",\n\n\t\t//existing base tag?\n\t\t$base = $head.children( ""base"" ),\n\n\t\t//tuck away the original document URL minus any fragment.\n\t\tdocumentUrl = path.parseUrl( location.href ),\n\n\t\t//if the document has an embedded base tag, documentBase is set to its\n\t\t//initial value. If a base tag does not exist, then we default to the documentUrl.\n\t\tdocumentBase = $base.length ? path.parseUrl( path.makeUrlAbsolute( $base.attr( ""href"" ), documentUrl.href ) ) : documentUrl,\n\n\t\t//cache the comparison once.\n\t\tdocumentBaseDiffers = ( documentUrl.hrefNoHash !== documentBase.hrefNoHash );\n\n\t\t//base element management, defined depending on dynamic base tag support\n\t\tvar base = $.support.dynamicBaseTag ? {\n\n\t\t\t//define base element, for use in routing asset urls that are referenced in Ajax-requested markup\n\t\t\telement: ( $base.length ? $base : $( ""<base>"", { href: documentBase.hrefNoHash } ).prependTo( $head ) ),\n\n\t\t\t//set the generated BASE element's href attribute to a new page's base path\n\t\t\tset: function( href ) {\n\t\t\t\tbase.element.attr( ""href"", path.makeUrlAbsolute( href, documentBase ) );\n\t\t\t},\n\n\t\t\t//set the generated BASE element's href attribute to a new page's base path\n\t\t\treset: function() {\n\t\t\t\tbase.element.attr( ""href"", documentBase.hrefNoHash );\n\t\t\t}\n\n\t\t} : undefined;\n\n/*\n\tinternal utility functions\n--------------------------------------*/\n\n\n\t//direct focus to the page title, or otherwise first focusable element\n\t$.mobile.focusPage = function ( page ) {\n\t\tvar autofocus = page.find(""[autofocus]""),\n\t\t\tpageTitle = page.find( "".ui-title:eq(0)"" );\n\n\t\tif( autofocus.length ) {\n\t\t\tautofocus.focus();\n\t\t\treturn;\n\t\t}\n\n\t\tif( pageTitle.length ) {\n\t\t\tpageTitle.focus();\n\t\t}\n\t\telse{\n\t\t\tpage.focus();\n\t\t}\n\t}\n\n\t//remove active classes after page transition or error\n\tfunction removeActiveLinkClass( forceRemoval ) {\n\t\tif( !!$activeClickedLink && ( !$activeClickedLink.closest( '.ui-page-active' ).length || forceRemoval ) ) {\n\t\t\t$activeClickedLink.removeClass( $.mobile.activeBtnClass );\n\t\t}\n\t\t$activeClickedLink = null;\n\t}\n\n\tfunction releasePageTransitionLock() {\n\t\tisPageTransitioning = false;\n\t\tif( pageTransitionQueue.length > 0 ) {\n\t\t\t$.mobile.changePage.apply( null, pageTransitionQueue.pop() );\n\t\t}\n\t}\n\n\t// Save the last scroll distance per page, before it is hidden\n\tvar setLastScrollEnabled = true,\n\t\tsetLastScroll, delayedSetLastScroll;\n\n\tsetLastScroll = function() {\n\t\t// this barrier prevents setting the scroll value based on the browser\n\t\t// scrolling the window based on a hashchange\n\t\tif( !setLastScrollEnabled ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar active = $.mobile.urlHistory.getActive();\n\n\t\tif( active ) {\n\t\t\tvar lastScroll = $window.scrollTop();\n\n\t\t\t// Set active page's lastScroll prop.\n\t\t\t// If the location we're scrolling to is less than minScrollBack, let it go.\n\t\t\tactive.lastScroll = lastScroll < $.mobile.minScrollBack ? $.mobile.defaultHomeScroll : lastScroll;\n\t\t}\n\t};\n\n\t// bind to scrollstop to gather scroll position. The delay allows for the hashchange\n\t// event to fire and disable scroll recording in the case where the browser scrolls\n\t// to the hash targets location (sometimes the top of the page). once pagechange fires\n\t// getLastScroll is again permitted to operate\n\tdelayedSetLastScroll = function() {\n\t\tsetTimeout( setLastScroll, 100 );\n\t};\n\n\t// disable an scroll setting when a hashchange has been fired, this only works\n\t// because the recording of the scroll position is delayed for 100ms after\n\t// the browser might have changed the position because of the hashchange\n\t$window.bind( $.support.pushState ? ""popstate"" : ""hashchange"", function() {\n\t \tsetLastScrollEnabled = false;\n\t});\n\n\t// handle initial hashchange from chrome :(\n\t$window.one( $.support.pushState ? ""popstate"" : ""hashchange"", function() {\n\t\tsetLastScrollEnabled = true;\n\t});\n\n\t// wait until the mobile page container has been determined to bind to pagechange\n\t$window.one( ""pagecontainercreate"", function(){\n\t\t// once the page has changed, re-enable the scroll recording\n\t\t$.mobile.pageContainer.bind( ""pagechange"", function() {\n\n\t \t\tsetLastScrollEnabled = true;\n\n\t\t\t// remove any binding that previously existed on the get scroll\n\t\t\t// which may or may not be different than the scroll element determined for\n\t\t\t// this page previously\n\t\t\t$window.unbind( ""scrollstop"", delayedSetLastScroll );\n\n\t\t\t// determine and bind to the current scoll element which may be the window\n\t\t\t// or in the case of touch overflow the element with touch overflow\n\t\t\t$window.bind( ""scrollstop"", delayedSetLastScroll );\n\t\t});\n\t});\n\n\t// bind to scrollstop for the first page as ""pagechange"" won't be fired in that case\n\t$window.bind( ""scrollstop"", delayedSetLastScroll );\n\n\t//function for transitioning between two existing pages\n\tfunction transitionPages( toPage, fromPage, transition, reverse ) {\n\n\t\tif( fromPage ) {\n\t\t\t//trigger before show/hide events\n\t\t\tfromPage.data( ""page"" )._trigger( ""beforehide"", null, { nextPage: toPage } );\n\t\t}\n\n\t\ttoPage.data( ""page"" )._trigger( ""beforeshow"", null, { prevPage: fromPage || $( """" ) } );\n\n\t\t//clear page loader\n\t\t$.mobile.hidePageLoadingMsg();\n\t\t\n\t\t// If transition is defined, check if css 3D transforms are supported, and if not, if a fallback is specified\n\t\tif( transition && !$.support.cssTransform3d && $.mobile.transitionFallbacks[ transition ] ){\n\t\t\ttransition = $.mobile.transitionFallbacks[ transition ];\n\t\t}\n\t\t\n\t\t//find the transition handler for the specified transition. If there\n\t\t//isn't one in our transitionHandlers dictionary, use the default one.\n\t\t//call the handler immediately to kick-off the transition.\n\t\tvar th = $.mobile.transitionHandlers[ transition || ""default"" ] || $.mobile.defaultTransitionHandler,\n\t\t\tpromise = th( transition, reverse, toPage, fromPage );\n\n\t\tpromise.done(function() {\n\n\t\t\t//trigger show/hide events\n\t\t\tif( fromPage ) {\n\t\t\t\tfromPage.data( ""page"" )._trigger( ""hide"", null, { nextPage: toPage } );\n\t\t\t}\n\n\t\t\t//trigger pageshow, define prevPage as either fromPage or empty jQuery obj\n\t\t\ttoPage.data( ""page"" )._trigger( ""show"", null, { prevPage: fromPage || $( """" ) } );\n\t\t});\n\n\t\treturn promise;\n\t}\n\n\t//simply set the active page's minimum height to screen height, depending on orientation\n\tfunction getScreenHeight(){\n\t\t// Native innerHeight returns more accurate value for this across platforms, \n\t\t// jQuery version is here as a normalized fallback for platforms like Symbian\n\t\treturn window.innerHeight || $( window ).height();\n\t}\n\n\t$.mobile.getScreenHeight = getScreenHeight;\n\n\t//simply set the active page's minimum height to screen height, depending on orientation\n\tfunction resetActivePageHeight(){\n\t\tvar aPage = $( ""."" + $.mobile.activePageClass ),\n\t\t\taPagePadT = parseFloat( aPage.css( ""padding-top"" ) ),\n\t\t\taPagePadB = parseFloat( aPage.css( ""padding-bottom"" ) );\n\t\t\t\t\n\t\taPage.css( ""min-height"", getScreenHeight() - aPagePadT - aPagePadB );\n\t}\n\n\t//shared page enhancements\n\tfunction enhancePage( $page, role ) {\n\t\t// If a role was specified, make sure the data-role attribute\n\t\t// on the page element is in sync.\n\t\tif( role ) {\n\t\t\t$page.attr( ""data-"" + $.mobile.ns + ""role"", role );\n\t\t}\n\n\t\t//run page plugin\n\t\t$page.page();\n\t}\n\n/* exposed $.mobile methods\t */\n\n\t//animation complete callback\n\t$.fn.animationComplete = function( callback ) {\n\t\tif( $.support.cssTransitions ) {\n\t\t\treturn $( this ).one( 'webkitAnimationEnd animationend', callback );\n\t\t}\n\t\telse{\n\t\t\t// defer execution for consistency between webkit/non webkit\n\t\t\tsetTimeout( callback, 0 );\n\t\t\treturn $( this );\n\t\t}\n\t};\n\n\t//expose path object on $.mobile\n\t$.mobile.path = path;\n\n\t//expose base object on $.mobile\n\t$.mobile.base = base;\n\n\t//history stack\n\t$.mobile.urlHistory = urlHistory;\n\n\t$.mobile.dialogHashKey = dialogHashKey;\n\n\n\n\t//enable cross-domain page support\n\t$.mobile.allowCrossDomainPages = false;\n\n\t//return the original document url\n\t$.mobile.getDocumentUrl = function(asParsedObject) {\n\t\treturn asParsedObject ? $.extend( {}, documentUrl ) : documentUrl.href;\n\t};\n\n\t//return the original document base url\n\t$.mobile.getDocumentBase = function(asParsedObject) {\n\t\treturn asParsedObject ? $.extend( {}, documentBase ) : documentBase.href;\n\t};\n\n\t$.mobile._bindPageRemove = function() {\n\t\tvar page = $(this);\n\n\t\t// when dom caching is not enabled or the page is embedded bind to remove the page on hide\n\t\tif( !page.data(""page"").options.domCache\n\t\t\t\t&& page.is("":jqmData(external-page='true')"") ) {\n\n\t\t\tpage.bind( 'pagehide.remove', function() {\n\t\t\t\tvar $this = $( this ),\n\t\t\t\t\tprEvent = new $.Event( ""pageremove"" );\n\n\t\t\t\t$this.trigger( prEvent );\n\n\t\t\t\tif( !prEvent.isDefaultPrevented() ){\n\t\t\t\t\t$this.removeWithDependents();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\t// Load a page into the DOM.\n\t$.mobile.loadPage = function( url, options ) {\n\t\t// This function uses deferred notifications to let callers\n\t\t// know when the page is done loading, or if an error has occurred.\n\t\tvar deferred = $.Deferred(),\n\n\t\t\t// The default loadPage options with overrides specified by\n\t\t\t// the caller.\n\t\t\tsettings = $.extend( {}, $.mobile.loadPage.defaults, options ),\n\n\t\t\t// The DOM element for the page after it has been loaded.\n\t\t\tpage = null,\n\n\t\t\t// If the reloadPage option is true, and the page is already\n\t\t\t// in the DOM, dupCachedPage will be set to the page element\n\t\t\t// so that it can be removed after the new version of the\n\t\t\t// page is loaded off the network.\n\t\t\tdupCachedPage = null,\n\n\t\t\t// determine the current base url\n\t\t\tfindBaseWithDefault = function(){\n\t\t\t\tvar closestBase = ( $.mobile.activePage && getClosestBaseUrl( $.mobile.activePage ) );\n\t\t\t\treturn closestBase || documentBase.hrefNoHash;\n\t\t\t},\n\n\t\t\t// The absolute version of the URL passed into the function. This\n\t\t\t// version of the URL may contain dialog/subpage params in it.\n\t\t\tabsUrl = path.makeUrlAbsolute( url, findBaseWithDefault() );\n\n\n\t\t// If the caller provided data, and we're using ""get"" request,\n\t\t// append the data to the URL.\n\t\tif ( settings.data && settings.type === ""get"" ) {\n\t\t\tabsUrl = path.addSearchParams( absUrl, settings.data );\n\t\t\tsettings.data = undefined;\n\t\t}\n\n\t\t// If the caller is using a ""post"" request, reloadPage must be true\n\t\tif(  settings.data && settings.type === ""post"" ){\n\t\t\tsettings.reloadPage = true;\n\t\t}\n\n\t\t\t// The absolute version of the URL minus any dialog/subpage params.\n\t\t\t// In otherwords the real URL of the page to be loaded.\n\t\tvar fileUrl = path.getFilePath( absUrl ),\n\n\t\t\t// The version of the Url actually stored in the data-url attribute of\n\t\t\t// the page. For embedded pages, it is just the id of the page. For pages\n\t\t\t// within the same domain as the document base, it is the site relative\n\t\t\t// path. For cross-domain pages (Phone Gap only) the entire absolute Url\n\t\t\t// used to load the page.\n\t\t\tdataUrl = path.convertUrlToDataUrl( absUrl );\n\n\t\t// Make sure we have a pageContainer to work with.\n\t\tsettings.pageContainer = settings.pageContainer || $.mobile.pageContainer;\n\n\t\t// Check to see if the page already exists in the DOM.\n\t\tpage = settings.pageContainer.children( "":jqmData(url='"" + dataUrl + ""')"" );\n\n\t\t// If we failed to find the page, check to see if the url is a\n\t\t// reference to an embedded page. If so, it may have been dynamically\n\t\t// injected by a developer, in which case it would be lacking a data-url\n\t\t// attribute and in need of enhancement.\n\t\tif ( page.length === 0 && dataUrl && !path.isPath( dataUrl ) ) {\n\t\t\tpage = settings.pageContainer.children( ""#"" + dataUrl )\n\t\t\t\t.attr( ""data-"" + $.mobile.ns + ""url"", dataUrl );\n\t\t}\n\n\t\t// If we failed to find a page in the DOM, check the URL to see if it\n\t\t// refers to the first page in the application. If it isn't a reference\n\t\t// to the first page and refers to non-existent embedded page, error out.\n\t\tif ( page.length === 0 ) {\n\t\t\tif ( $.mobile.firstPage && path.isFirstPageUrl( fileUrl ) ) {\n\t\t\t\t// Check to make sure our cached-first-page is actually\n\t\t\t\t// in the DOM. Some user deployed apps are pruning the first\n\t\t\t\t// page from the DOM for various reasons, we check for this\n\t\t\t\t// case here because we don't want a first-page with an id\n\t\t\t\t// falling through to the non-existent embedded page error\n\t\t\t\t// case. If the first-page is not in the DOM, then we let\n\t\t\t\t// things fall through to the ajax loading code below so\n\t\t\t\t// that it gets reloaded.\n\t\t\t\tif ( $.mobile.firstPage.parent().length ) {\n\t\t\t\t\tpage = $( $.mobile.firstPage );\n\t\t\t\t}\n\t\t\t} else if ( path.isEmbeddedPage( fileUrl )  ) {\n\t\t\t\tdeferred.reject( absUrl, options );\n\t\t\t\treturn deferred.promise();\n\t\t\t}\n\t\t}\n\n\t\t// Reset base to the default document base.\n\t\tif ( base ) {\n\t\t\tbase.reset();\n\t\t}\n\n\t\t// If the page we are interested in is already in the DOM,\n\t\t// and the caller did not indicate that we should force a\n\t\t// reload of the file, we are done. Otherwise, track the\n\t\t// existing page as a duplicated.\n\t\tif ( page.length ) {\n\t\t\tif ( !settings.reloadPage ) {\n\t\t\t\tenhancePage( page, settings.role );\n\t\t\t\tdeferred.resolve( absUrl, options, page );\n\t\t\t\treturn deferred.promise();\n\t\t\t}\n\t\t\tdupCachedPage = page;\n\t\t}\n\n\t\tvar mpc = settings.pageContainer,\n\t\t\tpblEvent = new $.Event( ""pagebeforeload"" ),\n\t\t\ttriggerData = { url: url, absUrl: absUrl, dataUrl: dataUrl, deferred: deferred, options: settings };\n\n\t\t// Let listeners know we're about to load a page.\n\t\tmpc.trigger( pblEvent, triggerData );\n\n\t\t// If the default behavior is prevented, stop here!\n\t\tif( pblEvent.isDefaultPrevented() ){\n\t\t\treturn deferred.promise();\n\t\t}\n\n\t\tif ( settings.showLoadMsg ) {\n\n\t\t\t// This configurable timeout allows cached pages a brief delay to load without showing a message\n\t\t\tvar loadMsgDelay = setTimeout(function(){\n\t\t\t\t\t$.mobile.showPageLoadingMsg();\n\t\t\t\t}, settings.loadMsgDelay ),\n\n\t\t\t\t// Shared logic for clearing timeout and removing message.\n\t\t\t\thideMsg = function(){\n\n\t\t\t\t\t// Stop message show timer\n\t\t\t\t\tclearTimeout( loadMsgDelay );\n\n\t\t\t\t\t// Hide loading message\n\t\t\t\t\t$.mobile.hidePageLoadingMsg();\n\t\t\t\t};\n\t\t}\n\n\t\tif ( !( $.mobile.allowCrossDomainPages || path.isSameDomain( documentUrl, absUrl ) ) ) {\n\t\t\tdeferred.reject( absUrl, options );\n\t\t} else {\n\t\t\t// Load the new page.\n\t\t\t$.ajax({\n\t\t\t\turl: fileUrl,\n\t\t\t\ttype: settings.type,\n\t\t\t\tdata: settings.data,\n\t\t\t\tdataType: ""html"",\n\t\t\t\tsuccess: function( html, textStatus, xhr ) {\n\t\t\t\t\t//pre-parse html to check for a data-url,\n\t\t\t\t\t//use it as the new fileUrl, base path, etc\n\t\t\t\t\tvar all = $( ""<div></div>"" ),\n\n\t\t\t\t\t\t//page title regexp\n\t\t\t\t\t\tnewPageTitle = html.match( /<title[^>]*>([^<]*)/ ) && RegExp.$1,\n\n\t\t\t\t\t\t// TODO handle dialogs again\n\t\t\t\t\t\tpageElemRegex = new RegExp( ""(<[^>]+\\\\bdata-"" + $.mobile.ns + ""role=[\\""']?page[\\""']?[^>]*>)"" ),\n\t\t\t\t\t\tdataUrlRegex = new RegExp( ""\\\\bdata-"" + $.mobile.ns + ""url=[\\""']?([^\\""'>]*)[\\""']?"" );\n\n\n\t\t\t\t\t// data-url must be provided for the base tag so resource requests can be directed to the\n\t\t\t\t\t// correct url. loading into a temprorary element makes these requests immediately\n\t\t\t\t\tif( pageElemRegex.test( html )\n\t\t\t\t\t\t\t&& RegExp.$1\n\t\t\t\t\t\t\t&& dataUrlRegex.test( RegExp.$1 )\n\t\t\t\t\t\t\t&& RegExp.$1 ) {\n\t\t\t\t\t\turl = fileUrl = path.getFilePath( RegExp.$1 );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( base ) {\n\t\t\t\t\t\tbase.set( fileUrl );\n\t\t\t\t\t}\n\n\t\t\t\t\t//workaround to allow scripts to execute when included in page divs\n\t\t\t\t\tall.get( 0 ).innerHTML = html;\n\t\t\t\t\tpage = all.find( "":jqmData(role='page'), :jqmData(role='dialog')"" ).first();\n\n\t\t\t\t\t//if page elem couldn't be found, create one and insert the body element's contents\n\t\t\t\t\tif( !page.length ){\n\t\t\t\t\t\tpage = $( ""<div data-"" + $.mobile.ns + ""role='page'>"" + html.split( /<\\/?body[^>]*>/gmi )[1] + ""</div>"" );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( newPageTitle && !page.jqmData( ""title"" ) ) {\n\t\t\t\t\t\tif ( ~newPageTitle.indexOf( ""&"" ) ) {\n\t\t\t\t\t\t\tnewPageTitle = $( ""<div>"" + newPageTitle + ""</div>"" ).text();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpage.jqmData( ""title"", newPageTitle );\n\t\t\t\t\t}\n\n\t\t\t\t\t//rewrite src and href attrs to use a base url\n\t\t\t\t\tif( !$.support.dynamicBaseTag ) {\n\t\t\t\t\t\tvar newPath = path.get( fileUrl );\n\t\t\t\t\t\tpage.find( ""[src], link[href], a[rel='external'], :jqmData(ajax='false'), a[target]"" ).each(function() {\n\t\t\t\t\t\t\tvar thisAttr = $( this ).is( '[href]' ) ? 'href' :\n\t\t\t\t\t\t\t\t\t$(this).is('[src]') ? 'src' : 'action',\n\t\t\t\t\t\t\t\tthisUrl = $( this ).attr( thisAttr );\n\n\t\t\t\t\t\t\t// XXX_jblas: We need to fix this so that it removes the document\n\t\t\t\t\t\t\t//            base URL, and then prepends with the new page URL.\n\t\t\t\t\t\t\t//if full path exists and is same, chop it - helps IE out\n\t\t\t\t\t\t\tthisUrl = thisUrl.replace( location.protocol + '//' + location.host + location.pathname, '' );\n\n\t\t\t\t\t\t\tif( !/^(\\w+:|#|\\/)/.test( thisUrl ) ) {\n\t\t\t\t\t\t\t\t$( this ).attr( thisAttr, newPath + thisUrl );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t//append to page and enhance\n\t\t\t\t\t// TODO taging a page with external to make sure that embedded pages aren't removed\n\t\t\t\t\t//      by the various page handling code is bad. Having page handling code in many\n\t\t\t\t\t//      places is bad. Solutions post 1.0\n\t\t\t\t\tpage\n\t\t\t\t\t\t.attr( ""data-"" + $.mobile.ns + ""url"", path.convertUrlToDataUrl( fileUrl ) )\n\t\t\t\t\t\t.attr( ""data-"" + $.mobile.ns + ""external-page"", true )\n\t\t\t\t\t\t.appendTo( settings.pageContainer );\n\n\t\t\t\t\t// wait for page creation to leverage options defined on widget\n\t\t\t\t\tpage.one( 'pagecreate', $.mobile._bindPageRemove );\n\n\t\t\t\t\tenhancePage( page, settings.role );\n\n\t\t\t\t\t// Enhancing the page may result in new dialogs/sub pages being inserted\n\t\t\t\t\t// into the DOM. If the original absUrl refers to a sub-page, that is the\n\t\t\t\t\t// real page we are interested in.\n\t\t\t\t\tif ( absUrl.indexOf( ""&"" + $.mobile.subPageUrlKey ) > -1 ) {\n\t\t\t\t\t\tpage = settings.pageContainer.children( "":jqmData(url='"" + dataUrl + ""')"" );\n\t\t\t\t\t}\n\n\t\t\t\t\t//bind pageHide to removePage after it's hidden, if the page options specify to do so\n\n\t\t\t\t\t// Remove loading message.\n\t\t\t\t\tif ( settings.showLoadMsg ) {\n\t\t\t\t\t\thideMsg();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add the page reference and xhr to our triggerData.\n\t\t\t\t\ttriggerData.xhr = xhr;\n\t\t\t\t\ttriggerData.textStatus = textStatus;\n\t\t\t\t\ttriggerData.page = page;\n\n\t\t\t\t\t// Let listeners know the page loaded successfully.\n\t\t\t\t\tsettings.pageContainer.trigger( ""pageload"", triggerData );\n\n\t\t\t\t\tdeferred.resolve( absUrl, options, page, dupCachedPage );\n\t\t\t\t},\n\t\t\t\terror: function( xhr, textStatus, errorThrown ) {\n\t\t\t\t\t//set base back to current path\n\t\t\t\t\tif( base ) {\n\t\t\t\t\t\tbase.set( path.get() );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add error info to our triggerData.\n\t\t\t\t\ttriggerData.xhr = xhr;\n\t\t\t\t\ttriggerData.textStatus = textStatus;\n\t\t\t\t\ttriggerData.errorThrown = errorThrown;\n\n\t\t\t\t\tvar plfEvent = new $.Event( ""pageloadfailed"" );\n\n\t\t\t\t\t// Let listeners know the page load failed.\n\t\t\t\t\tsettings.pageContainer.trigger( plfEvent, triggerData );\n\n\t\t\t\t\t// If the default behavior is prevented, stop here!\n\t\t\t\t\t// Note that it is the responsibility of the listener/handler\n\t\t\t\t\t// that called preventDefault(), to resolve/reject the\n\t\t\t\t\t// deferred object within the triggerData.\n\t\t\t\t\tif( plfEvent.isDefaultPrevented() ){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove loading message.\n\t\t\t\t\tif ( settings.showLoadMsg ) {\n\n\t\t\t\t\t\t// Remove loading message.\n\t\t\t\t\t\thideMsg();\n\n\t\t\t\t\t\t// show error message\n\t\t\t\t\t\t$.mobile.showPageLoadingMsg( $.mobile.pageLoadErrorMessageTheme, $.mobile.pageLoadErrorMessage, true );\n\n\t\t\t\t\t\t// hide after delay\n\t\t\t\t\t\tsetTimeout( $.mobile.hidePageLoadingMsg, 1500 );\n\t\t\t\t\t}\n\n\t\t\t\t\tdeferred.reject( absUrl, options );\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn deferred.promise();\n\t};\n\n\t$.mobile.loadPage.defaults = {\n\t\ttype: ""get"",\n\t\tdata: undefined,\n\t\treloadPage: false,\n\t\trole: undefined, // By default we rely on the role defined by the @data-role attribute.\n\t\tshowLoadMsg: false,\n\t\tpageContainer: undefined,\n\t\tloadMsgDelay: 50 // This delay allows loads that pull from browser cache to occur without showing the loading message.\n\t};\n\n\t// Show a specific page in the page container.\n\t$.mobile.changePage = function( toPage, options ) {\n\t\t// If we are in the midst of a transition, queue the current request.\n\t\t// We'll call changePage() once we're done with the current transition to\n\t\t// service the request.\n\t\tif( isPageTransitioning ) {\n\t\t\tpageTransitionQueue.unshift( arguments );\n\t\t\treturn;\n\t\t}\n\n\t\tvar settings = $.extend( {}, $.mobile.changePage.defaults, options );\n\n\t\t// Make sure we have a pageContainer to work with.\n\t\tsettings.pageContainer = settings.pageContainer || $.mobile.pageContainer;\n\n\t\t// Make sure we have a fromPage.\n\t\tsettings.fromPage = settings.fromPage || $.mobile.activePage;\n\n\t\tvar mpc = settings.pageContainer,\n\t\t\tpbcEvent = new $.Event( ""pagebeforechange"" ),\n\t\t\ttriggerData = { toPage: toPage, options: settings };\n\n\t\t// Let listeners know we're about to change the current page.\n\t\tmpc.trigger( pbcEvent, triggerData );\n\n\t\t// If the default behavior is prevented, stop here!\n\t\tif( pbcEvent.isDefaultPrevented() ){\n\t\t\treturn;\n\t\t}\n\n\t\t// We allow ""pagebeforechange"" observers to modify the toPage in the trigger\n\t\t// data to allow for redirects. Make sure our toPage is updated.\n\n\t\ttoPage = triggerData.toPage;\n\n\t\t// Set the isPageTransitioning flag to prevent any requests from\n\t\t// entering this method while we are in the midst of loading a page\n\t\t// or transitioning.\n\n\t\tisPageTransitioning = true;\n\n\t\t// If the caller passed us a url, call loadPage()\n\t\t// to make sure it is loaded into the DOM. We'll listen\n\t\t// to the promise object it returns so we know when\n\t\t// it is done loading or if an error ocurred.\n\t\tif ( typeof toPage == ""string"" ) {\n\t\t\t$.mobile.loadPage( toPage, settings )\n\t\t\t\t.done(function( url, options, newPage, dupCachedPage ) {\n\t\t\t\t\tisPageTransitioning = false;\n\t\t\t\t\toptions.duplicateCachedPage = dupCachedPage;\n\t\t\t\t\t$.mobile.changePage( newPage, options );\n\t\t\t\t})\n\t\t\t\t.fail(function( url, options ) {\n\t\t\t\t\tisPageTransitioning = false;\n\n\t\t\t\t\t//clear out the active button state\n\t\t\t\t\tremoveActiveLinkClass( true );\n\n\t\t\t\t\t//release transition lock so navigation is free again\n\t\t\t\t\treleasePageTransitionLock();\n\t\t\t\t\tsettings.pageContainer.trigger( ""pagechangefailed"", triggerData );\n\t\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// If we are going to the first-page of the application, we need to make\n\t\t// sure settings.dataUrl is set to the application document url. This allows\n\t\t// us to avoid generating a document url with an id hash in the case where the\n\t\t// first-page of the document has an id attribute specified.\n\t\tif ( toPage[ 0 ] === $.mobile.firstPage[ 0 ] && !settings.dataUrl ) {\n\t\t\tsettings.dataUrl = documentUrl.hrefNoHash;\n\t\t}\n\n\t\t// The caller passed us a real page DOM element. Update our\n\t\t// internal state and then trigger a transition to the page.\n\t\tvar fromPage = settings.fromPage,\n\t\t\turl = ( settings.dataUrl && path.convertUrlToDataUrl( settings.dataUrl ) ) || toPage.jqmData( ""url"" ),\n\t\t\t// The pageUrl var is usually the same as url, except when url is obscured as a dialog url. pageUrl always contains the file path\n\t\t\tpageUrl = url,\n\t\t\tfileUrl = path.getFilePath( url ),\n\t\t\tactive = urlHistory.getActive(),\n\t\t\tactiveIsInitialPage = urlHistory.activeIndex === 0,\n\t\t\thistoryDir = 0,\n\t\t\tpageTitle = document.title,\n\t\t\tisDialog = settings.role === ""dialog"" || toPage.jqmData( ""role"" ) === ""dialog"";\n\n\t\t// By default, we prevent changePage requests when the fromPage and toPage\n\t\t// are the same element, but folks that generate content manually/dynamically\n\t\t// and reuse pages want to be able to transition to the same page. To allow\n\t\t// this, they will need to change the default value of allowSamePageTransition\n\t\t// to true, *OR*, pass it in as an option when they manually call changePage().\n\t\t// It should be noted that our default transition animations assume that the\n\t\t// formPage and toPage are different elements, so they may behave unexpectedly.\n\t\t// It is up to the developer that turns on the allowSamePageTransitiona option\n\t\t// to either turn off transition animations, or make sure that an appropriate\n\t\t// animation transition is used.\n\t\tif( fromPage && fromPage[0] === toPage[0] && !settings.allowSamePageTransition ) {\n\t\t\tisPageTransitioning = false;\n\t\t\tmpc.trigger( ""pagechange"", triggerData );\n\t\t\treturn;\n\t\t}\n\n\t\t// We need to make sure the page we are given has already been enhanced.\n\t\tenhancePage( toPage, settings.role );\n\n\t\t// If the changePage request was sent from a hashChange event, check to see if the\n\t\t// page is already within the urlHistory stack. If so, we'll assume the user hit\n\t\t// the forward/back button and will try to match the transition accordingly.\n\t\tif( settings.fromHashChange ) {\n\t\t\turlHistory.directHashChange({\n\t\t\t\tcurrentUrl:\turl,\n\t\t\t\tisBack:\t\tfunction() { historyDir = -1; },\n\t\t\t\tisForward:\tfunction() { historyDir = 1; }\n\t\t\t});\n\t\t}\n\n\t\t// Kill the keyboard.\n\t\t// XXX_jblas: We need to stop crawling the entire document to kill focus. Instead,\n\t\t//            we should be tracking focus with a delegate() handler so we already have\n\t\t//            the element in hand at this point.\n\t\t// Wrap this in a try/catch block since IE9 throw ""Unspecified error"" if document.activeElement\n\t\t// is undefined when we are in an IFrame.\n\t\ttry {\n\t\t\tif(document.activeElement && document.activeElement.nodeName.toLowerCase() != 'body') {\n\t\t\t\t$(document.activeElement).blur();\n\t\t\t} else {\n\t\t\t\t$( ""input:focus, textarea:focus, select:focus"" ).blur();\n\t\t\t}\n\t\t} catch(e) {}\n\n\t\t// If we're displaying the page as a dialog, we don't want the url\n\t\t// for the dialog content to be used in the hash. Instead, we want\n\t\t// to append the dialogHashKey to the url of the current page.\n\t\tif ( isDialog && active ) {\n\t\t\t// on the initial page load active.url is undefined and in that case should\n\t\t\t// be an empty string. Moving the undefined -> empty string back into\n\t\t\t// urlHistory.addNew seemed imprudent given undefined better represents\n\t\t\t// the url state\n\t\t\turl = ( active.url || """" ) + dialogHashKey;\n\t\t}\n\n\t\t// Set the location hash.\n\t\tif( settings.changeHash !== false && url ) {\n\t\t\t//disable hash listening temporarily\n\t\t\turlHistory.ignoreNextHashChange = true;\n\t\t\t//update hash and history\n\t\t\tpath.set( url );\n\t\t}\n\n\t\t// if title element wasn't found, try the page div data attr too\n\t\t// If this is a deep-link or a reload ( active === undefined ) then just use pageTitle\n\t\tvar newPageTitle = ( !active )? pageTitle : toPage.jqmData( ""title"" ) || toPage.children("":jqmData(role='header')"").find("".ui-title"" ).getEncodedText();\n\t\tif( !!newPageTitle && pageTitle == document.title ) {\n\t\t\tpageTitle = newPageTitle;\n\t\t}\n\t\tif ( !toPage.jqmData( ""title"" ) ) {\n\t\t\ttoPage.jqmData( ""title"", pageTitle );\n\t\t}\n\n\t\t// Make sure we have a transition defined.\n\t\tsettings.transition = settings.transition\n\t\t\t|| ( ( historyDir && !activeIsInitialPage ) ? active.transition : undefined )\n\t\t\t|| ( isDialog ? $.mobile.defaultDialogTransition : $.mobile.defaultPageTransition );\n\n\t\t//add page to history stack if it's not back or forward\n\t\tif( !historyDir ) {\n\t\t\turlHistory.addNew( url, settings.transition, pageTitle, pageUrl, settings.role );\n\t\t}\n\n\t\t//set page title\n\t\tdocument.title = urlHistory.getActive().title;\n\n\t\t//set ""toPage"" as activePage\n\t\t$.mobile.activePage = toPage;\n\n\t\t// If we're navigating back in the URL history, set reverse accordingly.\n\t\tsettings.reverse = settings.reverse || historyDir < 0;\n\n\t\ttransitionPages( toPage, fromPage, settings.transition, settings.reverse )\n\t\t\t.done(function( name, reverse, $to, $from, alreadyFocused ) {\n\t\t\t\tremoveActiveLinkClass();\n\n\t\t\t\t//if there's a duplicateCachedPage, remove it from the DOM now that it's hidden\n\t\t\t\tif ( settings.duplicateCachedPage ) {\n\t\t\t\t\tsettings.duplicateCachedPage.remove();\n\t\t\t\t}\n\n\t\t\t\t// Send focus to the newly shown page. Moved from promise .done binding in transitionPages\n\t\t\t\t// itself to avoid ie bug that reports offsetWidth as > 0 (core check for visibility)\n\t\t\t\t// despite visibility: hidden addresses issue #2965\n\t\t\t\t// https://github.com/jquery/jquery-mobile/issues/2965\n\t\t\t\tif( !alreadyFocused ){\n\t\t\t\t\t$.mobile.focusPage( toPage );\n\t\t\t\t}\n\n\t\t\t\treleasePageTransitionLock();\n\n\t\t\t\t// Let listeners know we're all done changing the current page.\n\t\t\t\tmpc.trigger( ""pagechange"", triggerData );\n\t\t\t});\n\t};\n\n\t$.mobile.changePage.defaults = {\n\t\ttransition: undefined,\n\t\treverse: false,\n\t\tchangeHash: true,\n\t\tfromHashChange: false,\n\t\trole: undefined, // By default we rely on the role defined by the @data-role attribute.\n\t\tduplicateCachedPage: undefined,\n\t\tpageContainer: undefined,\n\t\tshowLoadMsg: true, //loading message shows by default when pages are being fetched during changePage\n\t\tdataUrl: undefined,\n\t\tfromPage: undefined,\n\t\tallowSamePageTransition: false\n\t};\n\n/* Event Bindings - hashchange, submit, and click */\n\tfunction findClosestLink( ele )\n\t{\n\t\twhile ( ele ) {\n\t\t\t// Look for the closest element with a nodeName of ""a"".\n\t\t\t// Note that we are checking if we have a valid nodeName\n\t\t\t// before attempting to access it. This is because the\n\t\t\t// node we get called with could have originated from within\n\t\t\t// an embedded SVG document where some symbol instance elements\n\t\t\t// don't have nodeName defined on them, or strings are of type\n\t\t\t// SVGAnimatedString.\n\t\t\tif ( ( typeof ele.nodeName === ""string"" ) && ele.nodeName.toLowerCase() == ""a"" ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tele = ele.parentNode;\n\t\t}\n\t\treturn ele;\n\t}\n\n\t// The base URL for any given element depends on the page it resides in.\n\tfunction getClosestBaseUrl( ele )\n\t{\n\t\t// Find the closest page and extract out its url.\n\t\tvar url = $( ele ).closest( "".ui-page"" ).jqmData( ""url"" ),\n\t\t\tbase = documentBase.hrefNoHash;\n\n\t\tif ( !url || !path.isPath( url ) ) {\n\t\t\turl = base;\n\t\t}\n\n\t\treturn path.makeUrlAbsolute( url, base);\n\t}\n\n\n\t//The following event bindings should be bound after mobileinit has been triggered\n\t//the following function is called in the init file\n\t$.mobile._registerInternalEvents = function(){\n\n\t\t//bind to form submit events, handle with Ajax\n\t\t$( document ).delegate( ""form"", ""submit"", function( event ) {\n\t\t\tvar $this = $( this );\n\n\t\t\tif( !$.mobile.ajaxEnabled ||\n\t\t\t\t\t// test that the form is, itself, ajax false\n\t\t\t\t\t$this.is("":jqmData(ajax='false')"") ||\n\t\t\t\t\t// test that $.mobile.ignoreContentEnabled is set and\n\t\t\t\t\t// the form or one of it's parents is ajax=false\n\t\t\t\t\t!$this.jqmHijackable().length ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar type = $this.attr( ""method"" ),\n\t\t\t\ttarget = $this.attr( ""target"" ),\n\t\t\t\turl = $this.attr( ""action"" );\n\n\t\t\t// If no action is specified, browsers default to using the\n\t\t\t// URL of the document containing the form. Since we dynamically\n\t\t\t// pull in pages from external documents, the form should submit\n\t\t\t// to the URL for the source document of the page containing\n\t\t\t// the form.\n\t\t\tif ( !url ) {\n\t\t\t\t// Get the @data-url for the page containing the form.\n\t\t\t\turl = getClosestBaseUrl( $this );\n\t\t\t\tif ( url === documentBase.hrefNoHash ) {\n\t\t\t\t\t// The url we got back matches the document base,\n\t\t\t\t\t// which means the page must be an internal/embedded page,\n\t\t\t\t\t// so default to using the actual document url as a browser\n\t\t\t\t\t// would.\n\t\t\t\t\turl = documentUrl.hrefNoSearch;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\turl = path.makeUrlAbsolute(  url, getClosestBaseUrl($this) );\n\n\t\t\t//external submits use regular HTTP\n\t\t\tif( path.isExternal( url ) || target ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$.mobile.changePage(\n\t\t\t\turl,\n\t\t\t\t{\n\t\t\t\t\ttype:\t\ttype && type.length && type.toLowerCase() || ""get"",\n\t\t\t\t\tdata:\t\t$this.serialize(),\n\t\t\t\t\ttransition:\t$this.jqmData( ""transition"" ),\n\t\t\t\t\tdirection:\t$this.jqmData( ""direction"" ),\n\t\t\t\t\treloadPage:\ttrue\n\t\t\t\t}\n\t\t\t);\n\t\t\tevent.preventDefault();\n\t\t});\n\n\t\t//add active state on vclick\n\t\t$( document ).bind( ""vclick"", function( event ) {\n\t\t\t// if this isn't a left click we don't care. Its important to note\n\t\t\t// that when the virtual event is generated it will create the which attr\n\t\t\tif ( event.which > 1 || !$.mobile.linkBindingEnabled ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar link = findClosestLink( event.target );\n\n\t\t\t// split from the previous return logic to avoid find closest where possible\n\t\t\t// TODO teach $.mobile.hijackable to operate on raw dom elements so the link wrapping\n\t\t\t// can be avoided\n\t\t\tif ( !$(link).jqmHijackable().length ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( link ) {\n\t\t\t\tif ( path.parseUrl( link.getAttribute( ""href"" ) || ""#"" ).hash !== ""#"" ) {\n\t\t\t\t\tremoveActiveLinkClass( true );\n\t\t\t\t\t$activeClickedLink = $( link ).closest( "".ui-btn"" ).not( "".ui-disabled"" );\n\t\t\t\t\t$activeClickedLink.addClass( $.mobile.activeBtnClass );\n\t\t\t\t\t$( ""."" + $.mobile.activePageClass + "" .ui-btn"" ).not( link ).blur();\n\n\t\t\t\t\t// By caching the href value to data and switching the href to a #, we can avoid address bar showing in iOS. The click handler resets the href during its initial steps if this data is present\n\t\t\t\t\t$( link )\n\t\t\t\t\t\t.jqmData( ""href"", $( link  ).attr( ""href"" )  )\n\t\t\t\t\t\t.attr( ""href"", ""#"" );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// click routing - direct to HTTP or Ajax, accordingly\n\t\t$( document ).bind( ""click"", function( event ) {\n\t\t\tif( !$.mobile.linkBindingEnabled ){\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar link = findClosestLink( event.target ), $link = $( link ), httpCleanup;\n\n\t\t\t// If there is no link associated with the click or its not a left\n\t\t\t// click we want to ignore the click\n\t\t\t// TODO teach $.mobile.hijackable to operate on raw dom elements so the link wrapping\n\t\t\t// can be avoided\n\t\t\tif ( !link || event.which > 1 || !$link.jqmHijackable().length ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//remove active link class if external (then it won't be there if you come back)\n\t\t\thttpCleanup = function(){\n\t\t\t\twindow.setTimeout( function() { removeActiveLinkClass( true ); }, 200 );\n\t\t\t};\n\n\t\t\t// If there's data cached for the real href value, set the link's href back to it again. This pairs with an address bar workaround from the vclick handler\n\t\t\tif( $link.jqmData( ""href"" ) ){\n\t\t\t\t$link.attr( ""href"", $link.jqmData( ""href"" ) );\n\t\t\t}\n\n\t\t\t//if there's a data-rel=back attr, go back in history\n\t\t\tif( $link.is( "":jqmData(rel='back')"" ) ) {\n\t\t\t\twindow.history.back();\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar baseUrl = getClosestBaseUrl( $link ),\n\n\t\t\t\t//get href, if defined, otherwise default to empty hash\n\t\t\t\thref = path.makeUrlAbsolute( $link.attr( ""href"" ) || ""#"", baseUrl );\n\n\t\t\t//if ajax is disabled, exit early\n\t\t\tif( !$.mobile.ajaxEnabled && !path.isEmbeddedPage( href ) ){\n\t\t\t\thttpCleanup();\n\t\t\t\t//use default click handling\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// XXX_jblas: Ideally links to application pages should be specified as\n\t\t\t//            an url to the application document with a hash that is either\n\t\t\t//            the site relative path or id to the page. But some of the\n\t\t\t//            internal code that dynamically generates sub-pages for nested\n\t\t\t//            lists and select dialogs, just write a hash in the link they\n\t\t\t//            create. This means the actual URL path is based on whatever\n\t\t\t//            the current value of the base tag is at the time this code\n\t\t\t//            is called. For now we are just assuming that any url with a\n\t\t\t//            hash in it is an application page reference.\n\t\t\tif ( href.search( ""#"" ) != -1 ) {\n\t\t\t\thref = href.replace( /[^#]*#/, """" );\n\t\t\t\tif ( !href ) {\n\t\t\t\t\t//link was an empty hash meant purely\n\t\t\t\t\t//for interaction, so we ignore it.\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\treturn;\n\t\t\t\t} else if ( path.isPath( href ) ) {\n\t\t\t\t\t//we have apath so make it the href we want to load.\n\t\t\t\t\thref = path.makeUrlAbsolute( href, baseUrl );\n\t\t\t\t} else {\n\t\t\t\t\t//we have a simple id so use the documentUrl as its base.\n\t\t\t\t\thref = path.makeUrlAbsolute( ""#"" + href, documentUrl.hrefNoHash );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\t// Should we handle this link, or let the browser deal with it?\n\t\t\tvar useDefaultUrlHandling = $link.is( ""[rel='external']"" ) || $link.is( "":jqmData(ajax='false')"" ) || $link.is( ""[target]"" ),\n\n\t\t\t\t// Some embedded browsers, like the web view in Phone Gap, allow cross-domain XHR\n\t\t\t\t// requests if the document doing the request was loaded via the file:// protocol.\n\t\t\t\t// This is usually to allow the application to ""phone home"" and fetch app specific\n\t\t\t\t// data. We normally let the browser handle external/cross-domain urls, but if the\n\t\t\t\t// allowCrossDomainPages option is true, we will allow cross-domain http/https\n\t\t\t\t// requests to go through our page loading logic.\n\t\t\t\tisCrossDomainPageLoad = ( $.mobile.allowCrossDomainPages && documentUrl.protocol === ""file:"" && href.search( /^https?:/ ) != -1 ),\n\n\t\t\t\t//check for protocol or rel and its not an embedded page\n\t\t\t\t//TODO overlap in logic from isExternal, rel=external check should be\n\t\t\t\t//     moved into more comprehensive isExternalLink\n\t\t\t\tisExternal = useDefaultUrlHandling || ( path.isExternal( href ) && !isCrossDomainPageLoad );\n\n\t\t\tif( isExternal ) {\n\t\t\t\thttpCleanup();\n\t\t\t\t//use default click handling\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//use ajax\n\t\t\tvar transition = $link.jqmData( ""transition"" ),\n\t\t\t\tdirection = $link.jqmData( ""direction"" ),\n\t\t\t\treverse = ( direction && direction === ""reverse"" ) ||\n\t\t\t\t\t\t\t// deprecated - remove by 1.0\n\t\t\t\t\t\t\t$link.jqmData( ""back"" ),\n\n\t\t\t\t//this may need to be more specific as we use data-rel more\n\t\t\t\trole = $link.attr( ""data-"" + $.mobile.ns + ""rel"" ) || undefined;\n\n\t\t\t$.mobile.changePage( href, { transition: transition, reverse: reverse, role: role } );\n\t\t\tevent.preventDefault();\n\t\t});\n\n\t\t//prefetch pages when anchors with data-prefetch are encountered\n\t\t$( document ).delegate( "".ui-page"", ""pageshow.prefetch"", function() {\n\t\t\tvar urls = [];\n\t\t\t$( this ).find( ""a:jqmData(prefetch)"" ).each(function(){\n\t\t\t\tvar $link = $(this),\n\t\t\t\t\turl = $link.attr( ""href"" );\n\n\t\t\t\tif ( url && $.inArray( url, urls ) === -1 ) {\n\t\t\t\t\turls.push( url );\n\n\t\t\t\t\t$.mobile.loadPage( url, {role: $link.attr(""data-"" + $.mobile.ns + ""rel"")} );\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\t$.mobile._handleHashChange = function( hash ) {\n\t\t\t//find first page via hash\n\t\t\tvar to = path.stripHash( hash ),\n\t\t\t\t//transition is false if it's the first page, undefined otherwise (and may be overridden by default)\n\t\t\t\ttransition = $.mobile.urlHistory.stack.length === 0 ? ""none"" : undefined,\n\n\t\t\t\t// default options for the changPage calls made after examining the current state\n\t\t\t\t// of the page and the hash\n\t\t\t\tchangePageOptions = {\n\t\t\t\t\ttransition: transition,\n\t\t\t\t\tchangeHash: false,\n\t\t\t\t\tfromHashChange: true\n\t\t\t\t};\n\n\t\t\t//if listening is disabled (either globally or temporarily), or it's a dialog hash\n\t\t\tif( !$.mobile.hashListeningEnabled || urlHistory.ignoreNextHashChange ) {\n\t\t\t\turlHistory.ignoreNextHashChange = false;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// special case for dialogs\n\t\t\tif( urlHistory.stack.length > 1 && to.indexOf( dialogHashKey ) > -1 ) {\n\n\t\t\t\t// If current active page is not a dialog skip the dialog and continue\n\t\t\t\t// in the same direction\n\t\t\t\tif(!$.mobile.activePage.is( "".ui-dialog"" )) {\n\t\t\t\t\t//determine if we're heading forward or backward and continue accordingly past\n\t\t\t\t\t//the current dialog\n\t\t\t\t\turlHistory.directHashChange({\n\t\t\t\t\t\tcurrentUrl: to,\n\t\t\t\t\t\tisBack: function() { window.history.back(); },\n\t\t\t\t\t\tisForward: function() { window.history.forward(); }\n\t\t\t\t\t});\n\n\t\t\t\t\t// prevent changePage()\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\t// if the current active page is a dialog and we're navigating\n\t\t\t\t\t// to a dialog use the dialog objected saved in the stack\n\t\t\t\t\turlHistory.directHashChange({\n\t\t\t\t\t\tcurrentUrl: to,\n\n\t\t\t\t\t\t// regardless of the direction of the history change\n\t\t\t\t\t\t// do the following\n\t\t\t\t\t\teither: function( isBack ) {\n\t\t\t\t\t\t\tvar active = $.mobile.urlHistory.getActive();\n\n\t\t\t\t\t\t\tto = active.pageUrl;\n\n\t\t\t\t\t\t\t// make sure to set the role, transition and reversal\n\t\t\t\t\t\t\t// as most of this is lost by the domCache cleaning\n\t\t\t\t\t\t\t$.extend( changePageOptions, {\n\t\t\t\t\t\t\t\trole: active.role,\n\t\t\t\t\t\t\t\ttransition:\t active.transition,\n\t\t\t\t\t\t\t\treverse: isBack\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//if to is defined, load it\n\t\t\tif ( to ) {\n\t\t\t\t// At this point, 'to' can be one of 3 things, a cached page element from\n\t\t\t\t// a history stack entry, an id, or site-relative/absolute URL. If 'to' is\n\t\t\t\t// an id, we need to resolve it against the documentBase, not the location.href,\n\t\t\t\t// since the hashchange could've been the result of a forward/backward navigation\n\t\t\t\t// that crosses from an external page/dialog to an internal page/dialog.\n\t\t\t\tto = ( typeof to === ""string"" && !path.isPath( to ) ) ? ( path.makeUrlAbsolute( '#' + to, documentBase ) ) : to;\n\t\t\t\t$.mobile.changePage( to, changePageOptions );\n\t\t\t}\telse {\n\t\t\t\t//there's no hash, go to the first page in the dom\n\t\t\t\t$.mobile.changePage( $.mobile.firstPage, changePageOptions );\n\t\t\t}\n\t\t};\n\n\t\t//hashchange event handler\n\t\t$window.bind( ""hashchange"", function( e, triggered ) {\n\t\t\t$.mobile._handleHashChange( location.hash );\n\t\t});\n\n\t\t//set page min-heights to be device specific\n\t\t$( document ).bind( ""pageshow"", resetActivePageHeight );\n\t\t$( window ).bind( ""throttledresize"", resetActivePageHeight );\n\n\t};//_registerInternalEvents callback\n\n})( jQuery );\n\n( function( $, window ) {\n\t// For now, let's Monkeypatch this onto the end of $.mobile._registerInternalEvents\n\t// Scope self to pushStateHandler so we can reference it sanely within the\n\t// methods handed off as event handlers\n\tvar\tpushStateHandler = {},\n\t\tself = pushStateHandler,\n\t\t$win = $( window ),\n\t\turl = $.mobile.path.parseUrl( location.href );\n\n\t$.extend( pushStateHandler, {\n\t\t// TODO move to a path helper, this is rather common functionality\n\t\tinitialFilePath: (function() {\n\t\t\treturn url.pathname + url.search;\n\t\t})(),\n\n\t\tinitialHref: url.hrefNoHash,\n\n\t\tstate: function() {\n\t\t\treturn {\n\t\t\t\thash: location.hash || ""#"" + self.initialFilePath,\n\t\t\t\ttitle: document.title,\n\n\t\t\t\t// persist across refresh\n\t\t\t\tinitialHref: self.initialHref\n\t\t\t};\n\t\t},\n\n\t\tresetUIKeys: function( url ) {\n\t\t\tvar dialog = $.mobile.dialogHashKey,\n\t\t\t\tsubkey = ""&"" + $.mobile.subPageUrlKey,\n\t\t\t\tdialogIndex = url.indexOf( dialog );\n\n\t\t\tif( dialogIndex > -1 ) {\n\t\t\t\turl = url.slice( 0, dialogIndex ) + ""#"" + url.slice( dialogIndex );\n\t\t\t} else if( url.indexOf( subkey ) > -1 ) {\n\t\t\t\turl = url.split( subkey ).join( ""#"" + subkey );\n\t\t\t}\n\n\t\t\treturn url;\n\t\t},\n\n\t\thashValueAfterReset: function( url ) {\n\t\t\tvar resetUrl = self.resetUIKeys( url );\n\t\t\treturn $.mobile.path.parseUrl( resetUrl ).hash;\n\t\t},\n\n\t\t// TODO sort out a single barrier to hashchange functionality\n\t\tnextHashChangePrevented: function( value ) {\n\t\t\t$.mobile.urlHistory.ignoreNextHashChange = value;\n\t\t\tself.onHashChangeDisabled = value;\n\t\t},\n\n\t\t// on hash change we want to clean up the url\n\t\t// NOTE this takes place *after* the vanilla navigation hash change\n\t\t// handling has taken place and set the state of the DOM\n\t\tonHashChange: function( e ) {\n\t\t\t// disable this hash change\n\t\t\tif( self.onHashChangeDisabled ){\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar href, state,\n\t\t\t\thash = location.hash,\n\t\t\t\tisPath = $.mobile.path.isPath( hash ),\n\t\t\t\tresolutionUrl = isPath ? location.href : $.mobile.getDocumentUrl();\n\n\t\t\thash = isPath ? hash.replace( ""#"", """" ) : hash;\n\n\n\t\t\t// propulate the hash when its not available\n\t\t\tstate = self.state();\n\n\t\t\t// make the hash abolute with the current href\n\t\t\thref = $.mobile.path.makeUrlAbsolute( hash, resolutionUrl );\n\n\t\t\tif ( isPath ) {\n\t\t\t\thref = self.resetUIKeys( href );\n\t\t\t}\n\n\t\t\t// replace the current url with the new href and store the state\n\t\t\t// Note that in some cases we might be replacing an url with the\n\t\t\t// same url. We do this anyways because we need to make sure that\n\t\t\t// all of our history entries have a state object associated with\n\t\t\t// them. This allows us to work around the case where window.history.back()\n\t\t\t// is called to transition from an external page to an embedded page.\n\t\t\t// In that particular case, a hashchange event is *NOT* generated by the browser.\n\t\t\t// Ensuring each history entry has a state object means that onPopState()\n\t\t\t// will always trigger our hashchange callback even when a hashchange event\n\t\t\t// is not fired.\n\t\t\thistory.replaceState( state, document.title, href );\n\t\t},\n\n\t\t// on popstate (ie back or forward) we need to replace the hash that was there previously\n\t\t// cleaned up by the additional hash handling\n\t\tonPopState: function( e ) {\n\t\t\tvar poppedState = e.originalEvent.state,\n\t\t\t\ttimeout, fromHash, toHash, hashChanged;\n\n\t\t\t// if there's no state its not a popstate we care about, eg chrome's initial popstate\n\t\t\tif( poppedState ) {\n\t\t\t\t// the active url in the history stack will still be from the previous state\n\t\t\t\t// so we can use it to verify if a hashchange will be fired from the popstate\n\t\t\t\tfromHash = self.hashValueAfterReset( $.mobile.urlHistory.getActive().url );\n\n\t\t\t\t// the hash stored in the state popped off the stack will be our currenturl or\n\t\t\t\t// the url to which we wish to navigate\n\t\t\t\ttoHash = self.hashValueAfterReset( poppedState.hash.replace(""#"", """") );\n\n\t\t\t\t// if the hashes of the urls are different we must assume that the browser\n\t\t\t\t// will fire a hashchange\n\t\t\t\thashChanged = fromHash !== toHash;\n\n\t\t\t\t// unlock hash handling once the hashchange caused be the popstate has fired\n\t\t\t\tif( hashChanged ) {\n\t\t\t\t\t$win.one( ""hashchange.pushstate"", function() {\n\t\t\t\t\t\tself.nextHashChangePrevented( false );\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// enable hash handling for the the _handleHashChange call\n\t\t\t\tself.nextHashChangePrevented( false );\n\n\t\t\t\t// change the page based on the hash\n\t\t\t\t$.mobile._handleHashChange( poppedState.hash );\n\n\t\t\t\t// only prevent another hash change handling if a hash change will be fired\n\t\t\t\t// by the browser\n\t\t\t\tif( hashChanged ) {\n\t\t\t\t\t// disable hash handling until one of the above timers fires\n\t\t\t\t\tself.nextHashChangePrevented( true );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tinit: function() {\n\t\t\t$win.bind( ""hashchange"", self.onHashChange );\n\n\t\t\t// Handle popstate events the occur through history changes\n\t\t\t$win.bind( ""popstate"", self.onPopState );\n\n\t\t\t// if there's no hash, we need to replacestate for returning to home\n\t\t\tif ( location.hash === """" ) {\n\t\t\t\thistory.replaceState( self.state(), document.title, location.href );\n\t\t\t}\n\t\t}\n\t});\n\n\t$( function() {\n\t\tif( $.mobile.pushStateEnabled && $.support.pushState ){\n\t\t\tpushStateHandler.init();\n\t\t}\n\t});\n})( jQuery, this );\n\n/*\n* fallback transition for pop in non-3D supporting browsers (which tend to handle complex transitions poorly in general\n*/\n\n(function( $, window, undefined ) {\n\n$.mobile.transitionFallbacks.pop = ""fade"";\n\n})( jQuery, this );\n\n/*\n* fallback transition for slide in non-3D supporting browsers (which tend to handle complex transitions poorly in general\n*/\n\n(function( $, window, undefined ) {\n\n// Use the simultaneous transition handler for slide transitions\n$.mobile.transitionHandlers.slide = $.mobile.transitionHandlers.simultaneous;\n\n// Set the slide transition's fallback to ""fade""\n$.mobile.transitionFallbacks.slide = ""fade"";\n\n})( jQuery, this );\n\n/*\n* fallback transition for slidedown in non-3D supporting browsers (which tend to handle complex transitions poorly in general\n*/\n\n(function( $, window, undefined ) {\n\n$.mobile.transitionFallbacks.slidedown = ""fade"";\n\n})( jQuery, this );\n\n/*\n* fallback transition for slideup in non-3D supporting browsers (which tend to handle complex transitions poorly in general\n*/\n\n(function( $, window, undefined ) {\n\n$.mobile.transitionFallbacks.slideup = ""fade"";\n\n})( jQuery, this );\n\n/*\n* fallback transition for flip in non-3D supporting browsers (which tend to handle complex transitions poorly in general\n*/\n\n(function( $, window, undefined ) {\n\n$.mobile.transitionFallbacks.flip = ""fade"";\n\n})( jQuery, this );\n\n/*\n* fallback transition for flow in non-3D supporting browsers (which tend to handle complex transitions poorly in general\n*/\n\n(function( $, window, undefined ) {\n\n$.mobile.transitionFallbacks.flow = ""fade"";\n\n})( jQuery, this );\n\n/*\n* fallback transition for turn in non-3D supporting browsers (which tend to handle complex transitions poorly in general\n*/\n\n(function( $, window, undefined ) {\n\n$.mobile.transitionFallbacks.turn = ""fade"";\n\n})( jQuery, this );\n\n(function( $, undefined ) {\n\n$.mobile.page.prototype.options.degradeInputs = {\n\tcolor: false,\n\tdate: false,\n\tdatetime: false,\n\t""datetime-local"": false,\n\temail: false,\n\tmonth: false,\n\tnumber: false,\n\trange: ""number"",\n\tsearch: ""text"",\n\ttel: false,\n\ttime: false,\n\turl: false,\n\tweek: false\n};\n\n\n//auto self-init widgets\n$( document ).bind( ""pagecreate create"", function( e ){\n\n\tvar page = $.mobile.closestPageData($(e.target)), options;\n\n\tif( !page ) {\n\t\treturn;\n\t}\n\n\toptions = page.options;\n\n\t// degrade inputs to avoid poorly implemented native functionality\n\t$( e.target ).find( ""input"" ).not( page.keepNativeSelector() ).each(function() {\n\t\tvar $this = $( this ),\n\t\t\ttype = this.getAttribute( ""type"" ),\n\t\t\toptType = options.degradeInputs[ type ] || ""text"";\n\n\t\tif ( options.degradeInputs[ type ] ) {\n\t\t\tvar html = $( ""<div>"" ).html( $this.clone() ).html(),\n\t\t\t\t// In IE browsers, the type sometimes doesn't exist in the cloned markup, so we replace the closing tag instead\n\t\t\t\thasType = html.indexOf( "" type="" ) > -1,\n\t\t\t\tfindstr = hasType ? /\\s+type=[""']?\\w+['""]?/ : /\\/?>/,\n\t\t\t\trepstr = "" type=\\"""" + optType + ""\\"" data-"" + $.mobile.ns + ""type=\\"""" + type + ""\\"""" + ( hasType ? """" : "">"" );\n\n\t\t\t$this.replaceWith( html.replace( findstr, repstr ) );\n\t\t}\n\t});\n\n});\n\n})( jQuery );\n\n(function( $, window, undefined ) {\n\n$.widget( ""mobile.dialog"", $.mobile.widget, {\n\toptions: {\n\t\tcloseBtnText \t: ""Close"",\n\t\toverlayTheme\t: ""a"",\n\t\tinitSelector\t: "":jqmData(role='dialog')""\n\t},\n\t_create: function() {\n\t\tvar self = this,\n\t\t\t$el = this.element,\n\t\t\theaderCloseButton = $( ""<a href='#' data-"" + $.mobile.ns + ""icon='delete' data-"" + $.mobile.ns + ""iconpos='notext'>""+ this.options.closeBtnText + ""</a>"" ),\n\t\t\tdialogWrap = $(""<div/>"", {\n\t\t\t\t\t""role"" : ""dialog"",\n\t\t\t\t\t""class"" : ""ui-dialog-contain ui-corner-all ui-overlay-shadow""\n\t\t\t\t});\n\n\t\t$el.addClass( ""ui-dialog ui-overlay-"" + this.options.overlayTheme );\n\t\t\n\t\t// Class the markup for dialog styling\n\t\t// Set aria role\n\t\t$el\n\t\t\t.wrapInner( dialogWrap )\n\t\t\t.children()\n\t\t\t\t.find( "":jqmData(role='header')"" )\n\t\t\t\t\t.prepend( headerCloseButton )\n\t\t\t\t.end()\n\t\t\t\t.children( ':first-child')\n\t\t\t\t\t.addClass( ""ui-corner-top"" )\n\t\t\t\t.end()\n\t\t\t\t.children( "":last-child"" )\n\t\t\t\t\t.addClass( ""ui-corner-bottom"" );\n\n\t\t// this must be an anonymous function so that select menu dialogs can replace\n\t\t// the close method. This is a change from previously just defining data-rel=back\n\t\t// on the button and letting nav handle it\n\t\t//\n\t\t// Use click rather than vclick in order to prevent the possibility of unintentionally\n\t\t// reopening the dialog if the dialog opening item was directly under the close button.\n\t\theaderCloseButton.bind( ""click"", function() {\n\t\t\tself.close();\n\t\t});\n\n\t\t/* bind events\n\t\t\t- clicks and submits should use the closing transition that the dialog opened with\n\t\t\t  unless a data-transition is specified on the link/form\n\t\t\t- if the click was on the close button, or the link has a data-rel=""back"" it'll go back in history naturally\n\t\t*/\n\t\t$el.bind( ""vclick submit"", function( event ) {\n\t\t\tvar $target = $( event.target ).closest( event.type === ""vclick"" ? ""a"" : ""form"" ),\n\t\t\t\tactive;\n\n\t\t\tif ( $target.length && !$target.jqmData( ""transition"" ) ) {\n\n\t\t\t\tactive = $.mobile.urlHistory.getActive() || {};\n\n\t\t\t\t$target.attr( ""data-"" + $.mobile.ns + ""transition"", ( active.transition || $.mobile.defaultDialogTransition ) )\n\t\t\t\t\t.attr( ""data-"" + $.mobile.ns + ""direction"", ""reverse"" );\n\t\t\t}\n\t\t})\n\t\t.bind( ""pagehide"", function( e, ui ) {\n\t\t\t$( this ).find( ""."" + $.mobile.activeBtnClass ).removeClass( $.mobile.activeBtnClass );\n\t\t})\n\t\t// Override the theme set by the page plugin on pageshow\n\t\t.bind( ""pagebeforeshow"", function(){\n\t\t\tif( self.options.overlayTheme ){\n\t\t\t\tself.element\n\t\t\t\t\t.page( ""removeContainerBackground"" )\n\t\t\t\t\t.page( ""setContainerBackground"", self.options.overlayTheme );\n\t\t\t}\n\t\t});\n\t},\n\n\t// Close method goes back in history\n\tclose: function() {\n\t\twindow.history.back();\n\t}\n});\n\n//auto self-init widgets\n$( document ).delegate( $.mobile.dialog.prototype.options.initSelector, ""pagecreate"", function(){\n\t$.mobile.dialog.prototype.enhance( this );\n});\n\n})( jQuery, this );\n\n(function( $, undefined ) {\n\n$.fn.fieldcontain = function( options ) {\n\treturn this.addClass( ""ui-field-contain ui-body ui-br"" );\n};\n\n//auto self-init widgets\n$( document ).bind( ""pagecreate create"", function( e ){\n\t$( "":jqmData(role='fieldcontain')"", e.target ).jqmEnhanceable().fieldcontain();\n});\n\n})( jQuery );\n\n(function( $, undefined ) {\n\n$.fn.grid = function( options ) {\n\treturn this.each(function() {\n\n\t\tvar $this = $( this ),\n\t\t\to = $.extend({\n\t\t\t\tgrid: null\n\t\t\t},options),\n\t\t\t$kids = $this.children(),\n\t\t\tgridCols = {solo:1, a:2, b:3, c:4, d:5},\n\t\t\tgrid = o.grid,\n\t\t\titerator;\n\n\t\t\tif ( !grid ) {\n\t\t\t\tif ( $kids.length <= 5 ) {\n\t\t\t\t\tfor ( var letter in gridCols ) {\n\t\t\t\t\t\tif ( gridCols[ letter ] === $kids.length ) {\n\t\t\t\t\t\t\tgrid = letter;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgrid = ""a"";\n\t\t\t\t}\n\t\t\t}\n\t\t\titerator = gridCols[grid];\n\n\t\t$this.addClass( ""ui-grid-"" + grid );\n\n\t\t$kids.filter( "":nth-child("" + iterator + ""n+1)"" ).addClass( ""ui-block-a"" );\n\n\t\tif ( iterator > 1 ) {\n\t\t\t$kids.filter( "":nth-child("" + iterator + ""n+2)"" ).addClass( ""ui-block-b"" );\n\t\t}\n\t\tif ( iterator > 2 ) {\n\t\t\t$kids.filter( "":nth-child(3n+3)"" ).addClass( ""ui-block-c"" );\n\t\t}\n\t\tif ( iterator > 3 ) {\n\t\t\t$kids.filter( "":nth-child(4n+4)"" ).addClass( ""ui-block-d"" );\n\t\t}\n\t\tif ( iterator > 4 ) {\n\t\t\t$kids.filter( "":nth-child(5n+5)"" ).addClass( ""ui-block-e"" );\n\t\t}\n\t});\n};\n})( jQuery );\n\n(function( $, undefined ) {\n\n$( document ).bind( ""pagecreate create"", function( e ){\n\t$( "":jqmData(role='nojs')"", e.target ).addClass( ""ui-nojs"" );\n\t\n});\n\n})( jQuery );\n\n( function( $, undefined ) {\n\n$.fn.buttonMarkup = function( options ) {\n\tvar $workingSet = this;\n\n\t// Enforce options to be of type string\n\toptions = ( options && ( $.type( options ) == ""object"" ) )? options : {};\n\tfor ( var i = 0; i < $workingSet.length; i++ ) {\n\t\tvar el = $workingSet.eq( i ),\n\t\t\te = el[ 0 ],\n\t\t\to = $.extend( {}, $.fn.buttonMarkup.defaults, {\n\t\t\t\ticon:       options.icon       !== undefined ? options.icon       : el.jqmData( ""icon"" ),\n\t\t\t\ticonpos:    options.iconpos    !== undefined ? options.iconpos    : el.jqmData( ""iconpos"" ),\n\t\t\t\ttheme:      options.theme      !== undefined ? options.theme      : el.jqmData( ""theme"" ) || $.mobile.getInheritedTheme( el, ""c"" ),\n\t\t\t\tinline:     options.inline     !== undefined ? options.inline     : el.jqmData( ""inline"" ),\n\t\t\t\tshadow:     options.shadow     !== undefined ? options.shadow     : el.jqmData( ""shadow"" ),\n\t\t\t\tcorners:    options.corners    !== undefined ? options.corners    : el.jqmData( ""corners"" ),\n\t\t\t\ticonshadow: options.iconshadow !== undefined ? options.iconshadow : el.jqmData( ""iconshadow"" ),\n\t\t\t\tmini:       options.mini       !== undefined ? options.mini       : el.jqmData( ""mini"" )\n\t\t\t}, options ),\n\n\t\t\t// Classes Defined\n\t\t\tinnerClass = ""ui-btn-inner"",\n\t\t\ttextClass = ""ui-btn-text"",\n\t\t\tbuttonClass, iconClass,\n\t\t\t// Button inner markup\n\t\t\tbuttonInner,\n\t\t\tbuttonText,\n\t\t\tbuttonIcon,\n\t\t\tbuttonElements;\n\n\t\t$.each(o, function(key, value) {\n\t\t\te.setAttribute( ""data-"" + $.mobile.ns + key, value );\n\t\t\tel.jqmData(key, value);\n\t\t});\n\n\t\t// Check if this element is already enhanced\n\t\tbuttonElements = $.data(((e.tagName === ""INPUT"" || e.tagName === ""BUTTON"") ? e.parentNode : e), ""buttonElements"");\n\n\t\tif (buttonElements) {\n\t\t\te = buttonElements.outer;\n\t\t\tel = $(e);\n\t\t\tbuttonInner = buttonElements.inner;\n\t\t\tbuttonText = buttonElements.text;\n\t\t\t// We will recreate this icon below\n\t\t\t$(buttonElements.icon).remove();\n\t\t\tbuttonElements.icon = null;\n\t\t}\n\t\telse {\n\t\t\tbuttonInner = document.createElement( o.wrapperEls );\n\t\t\tbuttonText = document.createElement( o.wrapperEls );\n\t\t}\n\t\tbuttonIcon = o.icon ? document.createElement( ""span"" ) : null;\n\n\t\tif ( attachEvents && !buttonElements) {\n\t\t\tattachEvents();\n\t\t}\n\t\t\n\t\t// if not, try to find closest theme container\t\n\t\tif ( !o.theme ) {\n\t\t\to.theme = $.mobile.getInheritedTheme( el, ""c"" );\t\n\t\t}\t\t\n\n\t\tbuttonClass = ""ui-btn ui-btn-up-"" + o.theme;\n\t\tbuttonClass += o.inline ? "" ui-btn-inline"" : """";\n\t\tbuttonClass += o.shadow ? "" ui-shadow"" : """";\n\t\tbuttonClass += o.corners ? "" ui-btn-corner-all"" : """";\n\n\t\tif ( o.mini !== undefined ) {\n\t\t\t// Used to control styling in headers/footers, where buttons default to `mini` style.\n\t\t\tbuttonClass += o.mini ? "" ui-mini"" : "" ui-fullsize"";\n\t\t}\n\t\t\n\t\tif ( o.inline !== undefined ) {\t\t\t\n\t\t\t// Used to control styling in headers/footers, where buttons default to `mini` style.\n\t\t\tbuttonClass += o.inline === false ? "" ui-btn-block"" : "" ui-btn-inline"";\n\t\t}\n\t\t\n\t\t\n\t\tif ( o.icon ) {\n\t\t\to.icon = ""ui-icon-"" + o.icon;\n\t\t\to.iconpos = o.iconpos || ""left"";\n\n\t\t\ticonClass = ""ui-icon "" + o.icon;\n\n\t\t\tif ( o.iconshadow ) {\n\t\t\t\ticonClass += "" ui-icon-shadow"";\n\t\t\t}\n\t\t}\n\n\t\tif ( o.iconpos ) {\n\t\t\tbuttonClass += "" ui-btn-icon-"" + o.iconpos;\n\n\t\t\tif ( o.iconpos == ""notext"" && !el.attr( ""title"" ) ) {\n\t\t\t\tel.attr( ""title"", el.getEncodedText() );\n\t\t\t}\n\t\t}\n    \n\t\tinnerClass += o.corners ? "" ui-btn-corner-all"" : """";\n\n\t\tif ( o.iconpos && o.iconpos === ""notext"" && !el.attr( ""title"" ) ) {\n\t\t\tel.attr( ""title"", el.getEncodedText() );\n\t\t}\n\n\t\tif ( buttonElements ) {\n\t\t\tel.removeClass( buttonElements.bcls || """" );\n\t\t}\n\t\tel.removeClass( ""ui-link"" ).addClass( buttonClass );\n\n\t\tbuttonInner.className = innerClass;\n\n\t\tbuttonText.className = textClass;\n\t\tif ( !buttonElements ) {\n\t\t\tbuttonInner.appendChild( buttonText );\n\t\t}\n\t\tif ( buttonIcon ) {\n\t\t\tbuttonIcon.className = iconClass;\n\t\t\tif ( !(buttonElements && buttonElements.icon) ) {\n\t\t\t\tbuttonIcon.appendChild( document.createTextNode(""\\u00a0"") );\n\t\t\t\tbuttonInner.appendChild( buttonIcon );\n\t\t\t}\n\t\t}\n\n\t\twhile ( e.firstChild && !buttonElements) {\n\t\t\tbuttonText.appendChild( e.firstChild );\n\t\t}\n\n\t\tif ( !buttonElements ) {\n\t\t\te.appendChild( buttonInner );\n\t\t}\n\n\t\t// Assign a structure containing the elements of this button to the elements of this button. This\n\t\t// will allow us to recognize this as an already-enhanced button in future calls to buttonMarkup().\n\t\tbuttonElements = {\n\t\t\tbcls  : buttonClass,\n\t\t\touter : e,\n\t\t\tinner : buttonInner,\n\t\t\ttext  : buttonText,\n\t\t\ticon  : buttonIcon\n\t\t};\n\n\t\t$.data(e,           'buttonElements', buttonElements);\n\t\t$.data(buttonInner, 'buttonElements', buttonElements);\n\t\t$.data(buttonText,  'buttonElements', buttonElements);\n\t\tif (buttonIcon) {\n\t\t\t$.data(buttonIcon, 'buttonElements', buttonElements);\n\t\t}\n\t}\n\n\treturn this;\n};\n\n$.fn.buttonMarkup.defaults = {\n\tcorners: true,\n\tshadow: true,\n\ticonshadow: true,\n\twrapperEls: ""span""\n};\n\nfunction closestEnabledButton( element ) {\n    var cname;\n\n    while ( element ) {\n\t\t// Note that we check for typeof className below because the element we\n\t\t// handed could be in an SVG DOM where className on SVG elements is defined to\n\t\t// be of a different type (SVGAnimatedString). We only operate on HTML DOM\n\t\t// elements, so we look for plain ""string"".\n        cname = ( typeof element.className === 'string' ) && (element.className + ' ');\n        if ( cname && cname.indexOf(""ui-btn "") > -1 && cname.indexOf(""ui-disabled "") < 0 ) {\n            break;\n        }\n\n        element = element.parentNode;\n    }\n\n    return element;\n}\n\nvar attachEvents = function() {\n\tvar hoverDelay = $.mobile.buttonMarkup.hoverDelay, hov, foc;\n\n\t$( document ).bind( {\n\t\t""vmousedown vmousecancel vmouseup vmouseover vmouseout focus blur scrollstart"": function( event ) {\n\t\t\tvar theme,\n\t\t\t\t$btn = $( closestEnabledButton( event.target ) ),\n\t\t\t\tevt = event.type;\n\t\t\n\t\t\tif ( $btn.length ) {\n\t\t\t\ttheme = $btn.attr( ""data-"" + $.mobile.ns + ""theme"" );\n\t\t\n\t\t\t\tif ( evt === ""vmousedown"" ) {\n\t\t\t\t\tif ( $.support.touch ) {\n\t\t\t\t\t\thov = setTimeout(function() {\n\t\t\t\t\t\t\t$btn.removeClass( ""ui-btn-up-"" + theme ).addClass( ""ui-btn-down-"" + theme );\n\t\t\t\t\t\t}, hoverDelay );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$btn.removeClass( ""ui-btn-up-"" + theme ).addClass( ""ui-btn-down-"" + theme );\n\t\t\t\t\t}\n\t\t\t\t} else if ( evt === ""vmousecancel"" || evt === ""vmouseup"" ) {\n\t\t\t\t\t$btn.removeClass( ""ui-btn-down-"" + theme ).addClass( ""ui-btn-up-"" + theme );\n\t\t\t\t} else if ( evt === ""vmouseover"" || evt === ""focus"" ) {\n\t\t\t\t\tif ( $.support.touch ) {\n\t\t\t\t\t\tfoc = setTimeout(function() {\n\t\t\t\t\t\t\t$btn.removeClass( ""ui-btn-up-"" + theme ).addClass( ""ui-btn-hover-"" + theme );\n\t\t\t\t\t\t}, hoverDelay );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$btn.removeClass( ""ui-btn-up-"" + theme ).addClass( ""ui-btn-hover-"" + theme );\n\t\t\t\t\t}\n\t\t\t\t} else if ( evt === ""vmouseout"" || evt === ""blur"" || evt === ""scrollstart"" ) {\n\t\t\t\t\t$btn.removeClass( ""ui-btn-hover-"" + theme  + "" ui-btn-down-"" + theme ).addClass( ""ui-btn-up-"" + theme );\n\t\t\t\t\tif ( hov ) {\n\t\t\t\t\t\tclearTimeout( hov );\n\t\t\t\t\t}\n\t\t\t\t\tif ( foc ) {\n\t\t\t\t\t\tclearTimeout( foc );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t""focusin focus"": function( event ){\n\t\t\t$( closestEnabledButton( event.target ) ).addClass( $.mobile.focusClass );\n\t\t},\n\t\t""focusout blur"": function( event ){\n\t\t\t$( closestEnabledButton( event.target ) ).removeClass( $.mobile.focusClass );\n\t\t}\n\t});\n\n\tattachEvents = null;\n};\n\n//links in bars, or those with  data-role become buttons\n//auto self-init widgets\n$( document ).bind( ""pagecreate create"", function( e ){\n\n\t$( "":jqmData(role='button'), .ui-bar > a, .ui-header > a, .ui-footer > a, .ui-bar > :jqmData(role='controlgroup') > a"", e.target )\n\t\t.not( "".ui-btn, :jqmData(role='none'), :jqmData(role='nojs')"" )\n\t\t.buttonMarkup();\n});\n\n})( jQuery );\n\n\n(function( $, undefined ) {\n\n$.mobile.page.prototype.options.backBtnText  = ""Back"";\n$.mobile.page.prototype.options.addBackBtn   = false;\n$.mobile.page.prototype.options.backBtnTheme = null;\n$.mobile.page.prototype.options.headerTheme  = ""a"";\n$.mobile.page.prototype.options.footerTheme  = ""a"";\n$.mobile.page.prototype.options.contentTheme = null;\n\n$( document ).delegate( "":jqmData(role='page'), :jqmData(role='dialog')"", ""pagecreate"", function( e ) {\n\n\tvar $page = $( this ),\n\t\to = $page.data( ""page"" ).options,\n\t\tpageRole = $page.jqmData( ""role"" ),\n\t\tpageTheme = o.theme;\n\n\t$( "":jqmData(role='header'), :jqmData(role='footer'), :jqmData(role='content')"", this )\n\t\t.jqmEnhanceable()\n\t\t.each(function() {\n\n\t\tvar $this = $( this ),\n\t\t\trole = $this.jqmData( ""role"" ),\n\t\t\ttheme = $this.jqmData( ""theme"" ),\n\t\t\tcontentTheme = theme || o.contentTheme || ( pageRole === ""dialog"" && pageTheme ),\n\t\t\t$headeranchors,\n\t\t\tleftbtn,\n\t\t\trightbtn,\n\t\t\tbackBtn;\n\n\t\t$this.addClass( ""ui-"" + role );\n\n\t\t//apply theming and markup modifications to page,header,content,footer\n\t\tif ( role === ""header"" || role === ""footer"" ) {\n\n\t\t\tvar thisTheme = theme || ( role === ""header"" ? o.headerTheme : o.footerTheme ) || pageTheme;\n\n\t\t\t$this\n\t\t\t\t//add theme class\n\t\t\t\t.addClass( ""ui-bar-"" + thisTheme )\n\t\t\t\t// Add ARIA role\n\t\t\t\t.attr( ""role"", role === ""header"" ? ""banner"" : ""contentinfo"" );\n\n\t\t\tif( role === ""header"") {\n\t\t\t\t// Right,left buttons\n\t\t\t\t$headeranchors\t= $this.children( ""a"" );\n\t\t\t\tleftbtn\t= $headeranchors.hasClass( ""ui-btn-left"" );\n\t\t\t\trightbtn = $headeranchors.hasClass( ""ui-btn-right"" );\n\n\t\t\t\tleftbtn = leftbtn || $headeranchors.eq( 0 ).not( "".ui-btn-right"" ).addClass( ""ui-btn-left"" ).length;\n\n\t\t\t\trightbtn = rightbtn || $headeranchors.eq( 1 ).addClass( ""ui-btn-right"" ).length;\n\t\t\t}\n\n\t\t\t// Auto-add back btn on pages beyond first view\n\t\t\tif ( o.addBackBtn &&\n\t\t\t\trole === ""header"" &&\n\t\t\t\t$( "".ui-page"" ).length > 1 &&\n\t\t\t\t$page.jqmData( ""url"" ) !== $.mobile.path.stripHash( location.hash ) &&\n\t\t\t\t!leftbtn ) {\n\n\t\t\t\tbackBtn = $( ""<a href='#' class='ui-btn-left' data-""+ $.mobile.ns +""rel='back' data-""+ $.mobile.ns +""icon='arrow-l'>""+ o.backBtnText +""</a>"" )\n\t\t\t\t\t// If theme is provided, override default inheritance\n\t\t\t\t\t.attr( ""data-""+ $.mobile.ns +""theme"", o.backBtnTheme || thisTheme )\n\t\t\t\t\t.prependTo( $this );\n\t\t\t}\n\n\t\t\t// Page title\n\t\t\t$this.children( ""h1, h2, h3, h4, h5, h6"" )\n\t\t\t\t.addClass( ""ui-title"" )\n\t\t\t\t// Regardless of h element number in src, it becomes h1 for the enhanced page\n\t\t\t\t.attr({\n\t\t\t\t\t""role"": ""heading"",\n\t\t\t\t\t""aria-level"": ""1""\n\t\t\t\t});\n\n\t\t} else if ( role === ""content"" ) {\n\t\t\tif ( contentTheme ) {\n\t\t\t    $this.addClass( ""ui-body-"" + ( contentTheme ) );\n\t\t\t}\n\n\t\t\t// Add ARIA role\n\t\t\t$this.attr( ""role"", ""main"" );\n\t\t}\n\t});\n});\n\n})( jQuery );\n\n(function( $, undefined ) {\n\n$.widget( ""mobile.collapsible"", $.mobile.widget, {\n\toptions: {\n\t\texpandCueText: "" click to expand contents"",\n\t\tcollapseCueText: "" click to collapse contents"",\n\t\tcollapsed: true,\n\t\theading: ""h1,h2,h3,h4,h5,h6,legend"",\n\t\ttheme: null,\n\t\tcontentTheme: null,\n\t\ticonTheme: ""d"",\n\t\tmini: false,\n\t\tinitSelector: "":jqmData(role='collapsible')""\n\t},\n\t_create: function() {\n\n\t\tvar $el = this.element,\n\t\t\to = this.options,\n\t\t\tcollapsible = $el.addClass( ""ui-collapsible"" ),\n\t\t\tcollapsibleHeading = $el.children( o.heading ).first(),\n\t\t\tcollapsibleContent = collapsible.wrapInner( ""<div class='ui-collapsible-content'></div>"" ).find( "".ui-collapsible-content"" ),\n\t\t\tcollapsibleSet = $el.closest( "":jqmData(role='collapsible-set')"" ).addClass( ""ui-collapsible-set"" );\n\n\t\t// Replace collapsibleHeading if it's a legend\n\t\tif ( collapsibleHeading.is( ""legend"" ) ) {\n\t\t\tcollapsibleHeading = $( ""<div role='heading'>""+ collapsibleHeading.html() +""</div>"" ).insertBefore( collapsibleHeading );\n\t\t\tcollapsibleHeading.next().remove();\n\t\t}\n\n\t\t// If we are in a collapsible set\n\t\tif ( collapsibleSet.length ) {\n\t\t\t// Inherit the theme from collapsible-set\n\t\t\tif ( !o.theme ) {\n\t\t\t\to.theme = collapsibleSet.jqmData(""theme"") || $.mobile.getInheritedTheme( collapsibleSet, ""c"" );\n\t\t\t}\n\t\t\t// Inherit the content-theme from collapsible-set\n\t\t\tif ( !o.contentTheme ) {\n\t\t\t\to.contentTheme = collapsibleSet.jqmData( ""content-theme"" );\n\t\t\t}\n\n\t\t\t// Gets the preference icon position in the set\n\t\t\tif ( !o.iconPos ) {\n\t\t\t\to.iconPos = collapsibleSet.jqmData( ""iconpos"" );\n\t\t\t}\n\n\t\t\tif( !o.mini ) {\n\t\t\t\to.mini = collapsibleSet.jqmData( ""mini"" );\n\t\t\t}\n\t\t}\n\t\tcollapsibleContent.addClass( ( o.contentTheme ) ? ( ""ui-body-"" + o.contentTheme ) : """");\n\n\t\tcollapsibleHeading\n\t\t\t//drop heading in before content\n\t\t\t.insertBefore( collapsibleContent )\n\t\t\t//modify markup & attributes\n\t\t\t.addClass( ""ui-collapsible-heading"" )\n\t\t\t.append( ""<span class='ui-collapsible-heading-status'></span>"" )\n\t\t\t.wrapInner( ""<a href='#' class='ui-collapsible-heading-toggle'></a>"" )\n\t\t\t.find( ""a"" )\n\t\t\t\t.first()\n\t\t\t\t.buttonMarkup({\n\t\t\t\t\tshadow: false,\n\t\t\t\t\tcorners: false,\n\t\t\t\t\ticonpos: $el.jqmData( ""iconpos"" ) || o.iconPos || ""left"",\n\t\t\t\t\ticon: ""plus"",\n\t\t\t\t\tmini: o.mini,\n\t\t\t\t\ttheme: o.theme\n\t\t\t\t})\n\t\t\t.add( "".ui-btn-inner"", $el )\n\t\t\t\t.addClass( ""ui-corner-top ui-corner-bottom"" );\n\n\t\t//events\n\t\tcollapsible\n\t\t\t.bind( ""expand collapse"", function( event ) {\n\t\t\t\tif ( !event.isDefaultPrevented() ) {\n\n\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t\tvar $this = $( this ),\n\t\t\t\t\t\tisCollapse = ( event.type === ""collapse"" ),\n\t\t\t\t\t    contentTheme = o.contentTheme;\n\n\t\t\t\t\tcollapsibleHeading\n\t\t\t\t\t\t.toggleClass( ""ui-collapsible-heading-collapsed"", isCollapse)\n\t\t\t\t\t\t.find( "".ui-collapsible-heading-status"" )\n\t\t\t\t\t\t\t.text( isCollapse ? o.expandCueText : o.collapseCueText )\n\t\t\t\t\t\t.end()\n\t\t\t\t\t\t.find( "".ui-icon"" )\n\t\t\t\t\t\t\t.toggleClass( ""ui-icon-minus"", !isCollapse )\n\t\t\t\t\t\t\t.toggleClass( ""ui-icon-plus"", isCollapse );\n\n\t\t\t\t\t$this.toggleClass( ""ui-collapsible-collapsed"", isCollapse );\n\t\t\t\t\tcollapsibleContent.toggleClass( ""ui-collapsible-content-collapsed"", isCollapse ).attr( ""aria-hidden"", isCollapse );\n\n\t\t\t\t\tif ( contentTheme && ( !collapsibleSet.length || collapsible.jqmData( ""collapsible-last"" ) ) ) {\n\t\t\t\t\t\tcollapsibleHeading\n\t\t\t\t\t\t\t.find( ""a"" ).first().add( collapsibleHeading.find( "".ui-btn-inner"" ) )\n\t\t\t\t\t\t\t.toggleClass( ""ui-corner-bottom"", isCollapse );\n\t\t\t\t\t\tcollapsibleContent.toggleClass( ""ui-corner-bottom"", !isCollapse );\n\t\t\t\t\t}\n\t\t\t\t\tcollapsibleContent.trigger( ""updatelayout"" );\n\t\t\t\t}\n\t\t\t})\n\t\t\t.trigger( o.collapsed ? ""collapse"" : ""expand"" );\n\n\t\tcollapsibleHeading\n\t\t\t.bind( ""click"", function( event ) {\n\n\t\t\t\tvar type = collapsibleHeading.is( "".ui-collapsible-heading-collapsed"" ) ?\n\t\t\t\t\t\t\t\t\t\t""expand"" : ""collapse"";\n\n\t\t\t\tcollapsible.trigger( type );\n\n\t\t\t\tevent.preventDefault();\n\t\t\t});\n\t}\n});\n\n//auto self-init widgets\n$( document ).bind( ""pagecreate create"", function( e ){\n\t$.mobile.collapsible.prototype.enhanceWithin( e.target );\n});\n\n})( jQuery );\n\n(function( $, undefined ) {\n\n$.widget( ""mobile.collapsibleset"", $.mobile.widget, {\n\toptions: {\n\t\tinitSelector: "":jqmData(role='collapsible-set')""\n\t},\n\t_create: function() {\n\t\tvar $el = this.element.addClass( ""ui-collapsible-set"" ),\n\t\t\to = this.options;\n\n\t\t// Inherit the theme from collapsible-set\n\t\tif ( !o.theme ) {\n\t\t\to.theme = $.mobile.getInheritedTheme( $el, ""c"" );\n\t\t}\n\t\t// Inherit the content-theme from collapsible-set\n\t\tif ( !o.contentTheme ) {\n\t\t\to.contentTheme = $el.jqmData( ""content-theme"" );\n\t\t}\n\n\t\tif ( !o.corners ) {\n\t\t\to.corners = $el.jqmData( ""corners"" ) === undefined ? true : false;\n\t\t}\n\n\t\t// Initialize the collapsible set if it's not already initialized\n\t\tif ( !$el.jqmData( ""collapsiblebound"" ) ) {\n\t\t\t$el\n\t\t\t\t.jqmData( ""collapsiblebound"", true )\n\t\t\t\t.bind( ""expand collapse"", function( event ) {\n\t\t\t\t\tvar isCollapse = ( event.type === ""collapse"" ),\n\t\t\t\t\t\tcollapsible = $( event.target ).closest( "".ui-collapsible"" ),\n\t\t\t\t\t\twidget = collapsible.data( ""collapsible"" ),\n\t\t\t\t\t    contentTheme = widget.options.contentTheme;\n\t\t\t\t\tif ( contentTheme && collapsible.jqmData( ""collapsible-last"" ) ) {\n\t\t\t\t\t\tcollapsible.find( widget.options.heading ).first()\n\t\t\t\t\t\t\t.find( ""a"" ).first()\n\t\t\t\t\t\t\t.add( "".ui-btn-inner"" )\n\t\t\t\t\t\t\t.toggleClass( ""ui-corner-bottom"", isCollapse );\n\t\t\t\t\t\tcollapsible.find( "".ui-collapsible-content"" ).toggleClass( ""ui-corner-bottom"", !isCollapse );\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.bind( ""expand"", function( event ) {\n\t\t\t\t\t$( event.target )\n\t\t\t\t\t\t.closest( "".ui-collapsible"" )\n\t\t\t\t\t\t.siblings( "".ui-collapsible"" )\n\t\t\t\t\t\t.trigger( ""collapse"" );\n\t\t\t\t});\n\t\t}\n\t},\n\n\t_init: function() {\n\t\tthis.refresh();\n\t},\n\n\trefresh: function() {\n\t\tvar $el = this.element,\n\t\t\to = this.options,\n\t\t\tcollapsiblesInSet = $el.children( "":jqmData(role='collapsible')"" );\n\n\t\t$.mobile.collapsible.prototype.enhance( collapsiblesInSet.not( "".ui-collapsible"" ) );\n\n\t\t// clean up borders\n\t\tcollapsiblesInSet.each( function() {\n\t\t\t$( this ).find( $.mobile.collapsible.prototype.options.heading )\n\t\t\t\t.find( ""a"" ).first()\n\t\t\t\t.add( "".ui-btn-inner"" )\n\t\t\t\t.removeClass( ""ui-corner-top ui-corner-bottom"" );\n\t\t});\n\n\t\tcollapsiblesInSet.first()\n\t\t\t.find( ""a"" )\n\t\t\t\t.first()\n\t\t\t\t.addClass( o.corners ? ""ui-corner-top"" : """" )\n\t\t\t\t.find( "".ui-btn-inner"" )\n\t\t\t\t\t.addClass( ""ui-corner-top"" );\n\n\t\tcollapsiblesInSet.last()\n\t\t\t.jqmData( ""collapsible-last"", true )\n\t\t\t.find( ""a"" )\n\t\t\t\t.first()\n\t\t\t\t.addClass( o.corners ? ""ui-corner-bottom"" : """" )\n\t\t\t\t.find( "".ui-btn-inner"" )\n\t\t\t\t\t.addClass( ""ui-corner-bottom"" );\n\t}\n});\n\n//auto self-init widgets\n$( document ).bind( ""pagecreate create"", function( e ){\n\t$.mobile.collapsibleset.prototype.enhanceWithin( e.target );\n});\n\n})( jQuery );\n\n(function( $, undefined ) {\n\n$.widget( ""mobile.navbar"", $.mobile.widget, {\n\toptions: {\n\t\ticonpos: ""top"",\n\t\tgrid: null,\n\t\tinitSelector: "":jqmData(role='navbar')""\n\t},\n\n\t_create: function(){\n\n\t\tvar $navbar = this.element,\n\t\t\t$navbtns = $navbar.find( ""a"" ),\n\t\t\ticonpos = $navbtns.filter( "":jqmData(icon)"" ).length ?\n\t\t\t\t\t\t\t\t\tthis.options.iconpos : undefined;\n\n\t\t$navbar.addClass( ""ui-navbar"" )\n\t\t\t.attr( ""role"",""navigation"" )\n\t\t\t.find( ""ul"" )\n\t\t\t.jqmEnhanceable()\n\t\t\t.grid({ grid: this.options.grid });\n\n\t\tif ( !iconpos ) {\n\t\t\t$navbar.addClass( ""ui-navbar-noicons"" );\n\t\t}\n\n\t\t$navbtns.buttonMarkup({\n\t\t\tcorners:\tfalse,\n\t\t\tshadow:\t\tfalse,\n\t\t\tinline:     true,\n\t\t\ticonpos:\ticonpos\n\t\t});\n\n\t\t$navbar.delegate( ""a"", ""vclick"", function( event ) {\n\t\t\tif( !$(event.target).hasClass(""ui-disabled"") ) {\n\t\t\t\t$navbtns.removeClass( $.mobile.activeBtnClass );\n\t\t\t\t$( this ).addClass( $.mobile.activeBtnClass );\n\t\t\t}\n\t\t});\n\n\t\t// Buttons in the navbar with ui-state-persist class should regain their active state before page show\n\t\t$navbar.closest( "".ui-page"" ).bind( ""pagebeforeshow"", function() {\n\t\t\t$navbtns.filter( "".ui-state-persist"" ).addClass( $.mobile.activeBtnClass );\n\t\t});\n\t}\n});\n\n//auto self-init widgets\n$( document ).bind( ""pagecreate create"", function( e ){\n\t$.mobile.navbar.prototype.enhanceWithin( e.target );\n});\n\n})( jQuery );\n\n(function( $, undefined ) {\n\n//Keeps track of the number of lists per page UID\n//This allows support for multiple nested list in the same page\n//https://github.com/jquery/jquery-mobile/issues/1617\nvar listCountPerPage = {};\n\n$.widget( ""mobile.listview"", $.mobile.widget, {\n\n\toptions: {\n\t\ttheme: null,\n\t\tcountTheme: ""c"",\n\t\theaderTheme: ""b"",\n\t\tdividerTheme: ""b"",\n\t\tsplitIcon: ""arrow-r"",\n\t\tsplitTheme: ""b"",\n\t\tmini: false,\n\t\tinset: false,\n\t\tinitSelector: "":jqmData(role='listview')""\n\t},\n\n\t_create: function() {\n\t\tvar t = this,\n\t\t\tlistviewClasses = """";\n\t\t\t\n\t\tlistviewClasses += t.options.inset ? "" ui-listview-inset ui-corner-all ui-shadow "" : """";\n\t\tlistviewClasses += t.element.jqmData( ""mini"" ) || t.options.mini === true ? "" ui-mini"" : """";\n\t\t\n\t\t// create listview markup\n\t\tt.element.addClass(function( i, orig ) {\n\t\t\treturn orig + "" ui-listview "" + listviewClasses;\n\t\t});\n\n\t\tt.refresh( true );\n\t},\n\n\t_removeCorners: function( li, which ) {\n\t\tvar top = ""ui-corner-top ui-corner-tr ui-corner-tl"",\n\t\t\tbot = ""ui-corner-bottom ui-corner-br ui-corner-bl"";\n\n\t\tli = li.add( li.find( "".ui-btn-inner, .ui-li-link-alt, .ui-li-thumb"" ) );\n\n\t\tif ( which === ""top"" ) {\n\t\t\tli.removeClass( top );\n\t\t} else if ( which === ""bottom"" ) {\n\t\t\tli.removeClass( bot );\n\t\t} else {\n\t\t\tli.removeClass( top + "" "" + bot );\n\t\t}\n\t},\n\n\t_refreshCorners: function( create ) {\n\t\tvar $li,\n\t\t\t$visibleli,\n\t\t\t$topli,\n\t\t\t$bottomli;\n\n\t\tif ( this.options.inset ) {\n\t\t\t$li = this.element.children( ""li"" );\n\t\t\t// at create time the li are not visible yet so we need to rely on .ui-screen-hidden\n\t\t\t$visibleli = create?$li.not( "".ui-screen-hidden"" ):$li.filter( "":visible"" );\n\n\t\t\tthis._removeCorners( $li );\n\n\t\t\t// Select the first visible li element\n\t\t\t$topli = $visibleli.first()\n\t\t\t\t.addClass( ""ui-corner-top"" );\n\n\t\t\t$topli.add( $topli.find( "".ui-btn-inner"" )\n\t\t\t\t\t.not( "".ui-li-link-alt span:first-child"" ) )\n                                .addClass( ""ui-corner-top"" )\n                                .end()\n\t\t\t\t.find( "".ui-li-link-alt, .ui-li-link-alt span:first-child"" )\n\t\t\t\t\t.addClass( ""ui-corner-tr"" )\n\t\t\t\t.end()\n\t\t\t\t.find( "".ui-li-thumb"" )\n\t\t\t\t\t.not("".ui-li-icon"")\n\t\t\t\t\t.addClass( ""ui-corner-tl"" );\n\n\t\t\t// Select the last visible li element\n\t\t\t$bottomli = $visibleli.last()\n\t\t\t\t.addClass( ""ui-corner-bottom"" );\n\n\t\t\t$bottomli.add( $bottomli.find( "".ui-btn-inner"" ) )\n\t\t\t\t.find( "".ui-li-link-alt"" )\n\t\t\t\t\t.addClass( ""ui-corner-br"" )\n\t\t\t\t.end()\n\t\t\t\t.find( "".ui-li-thumb"" )\n\t\t\t\t\t.not("".ui-li-icon"")\n\t\t\t\t\t.addClass( ""ui-corner-bl"" );\n\t\t}\n\t\tif ( !create ) {\n\t\t\tthis.element.trigger( ""updatelayout"" );\n\t\t}\n\t},\n\n\t// This is a generic utility method for finding the first\n\t// node with a given nodeName. It uses basic DOM traversal\n\t// to be fast and is meant to be a substitute for simple\n\t// $.fn.closest() and $.fn.children() calls on a single\n\t// element. Note that callers must pass both the lowerCase\n\t// and upperCase version of the nodeName they are looking for.\n\t// The main reason for this is that this function will be\n\t// called many times and we want to avoid having to lowercase\n\t// the nodeName from the element every time to ensure we have\n\t// a match. Note that this function lives here for now, but may\n\t// be moved into $.mobile if other components need a similar method.\n\t_findFirstElementByTagName: function( ele, nextProp, lcName, ucName )\n\t{\n\t\tvar dict = {};\n\t\tdict[ lcName ] = dict[ ucName ] = true;\n\t\twhile ( ele ) {\n\t\t\tif ( dict[ ele.nodeName ] ) {\n\t\t\t\treturn ele;\n\t\t\t}\n\t\t\tele = ele[ nextProp ];\n\t\t}\n\t\treturn null;\n\t},\n\t_getChildrenByTagName: function( ele, lcName, ucName )\n\t{\n\t\tvar results = [],\n\t\t\tdict = {};\n\t\tdict[ lcName ] = dict[ ucName ] = true;\n\t\tele = ele.firstChild;\n\t\twhile ( ele ) {\n\t\t\tif ( dict[ ele.nodeName ] ) {\n\t\t\t\tresults.push( ele );\n\t\t\t}\n\t\t\tele = ele.nextSibling;\n\t\t}\n\t\treturn $( results );\n\t},\n\n\t_addThumbClasses: function( containers )\n\t{\n\t\tvar i, img, len = containers.length;\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\timg = $( this._findFirstElementByTagName( containers[ i ].firstChild, ""nextSibling"", ""img"", ""IMG"" ) );\n\t\t\tif ( img.length ) {\n\t\t\t\timg.addClass( ""ui-li-thumb"" );\n\t\t\t\t$( this._findFirstElementByTagName( img[ 0 ].parentNode, ""parentNode"", ""li"", ""LI"" ) ).addClass( img.is( "".ui-li-icon"" ) ? ""ui-li-has-icon"" : ""ui-li-has-thumb"" );\n\t\t\t}\n\t\t}\n\t},\n\n\trefresh: function( create ) {\n\t\tthis.parentPage = this.element.closest( "".ui-page"" );\n\t\tthis._createSubPages();\n\n\t\tvar o = this.options,\n\t\t\t$list = this.element,\n\t\t\tself = this,\n\t\t\tdividertheme = $list.jqmData( ""dividertheme"" ) || o.dividerTheme,\n\t\t\tlistsplittheme = $list.jqmData( ""splittheme"" ),\n\t\t\tlistspliticon = $list.jqmData( ""spliticon"" ),\n\t\t\tli = this._getChildrenByTagName( $list[ 0 ], ""li"", ""LI"" ),\n\t\t\tcounter = $.support.cssPseudoElement || !$.nodeName( $list[ 0 ], ""ol"" ) ? 0 : 1,\n\t\t\titemClassDict = {},\n\t\t\titem, itemClass, itemTheme,\n\t\t\ta, last, splittheme, countParent, icon, imgParents, img, linkIcon;\n\n\t\tif ( counter ) {\n\t\t\t$list.find( "".ui-li-dec"" ).remove();\n\t\t}\n\n\t\tif ( !o.theme ) {\n\t\t\to.theme = $.mobile.getInheritedTheme( this.element, ""c"" );\n\t\t}\n\n\t\tfor ( var pos = 0, numli = li.length; pos < numli; pos++ ) {\n\t\t\titem = li.eq( pos );\n\t\t\titemClass = ""ui-li"";\n\n\t\t\t// If we're creating the element, we update it regardless\n\t\t\tif ( create || !item.hasClass( ""ui-li"" ) ) {\n\t\t\t\titemTheme = item.jqmData(""theme"") || o.theme;\n\t\t\t\ta = this._getChildrenByTagName( item[ 0 ], ""a"", ""A"" );\n\n\t\t\t\tif ( a.length ) {\n\t\t\t\t\ticon = item.jqmData(""icon"");\n\n\t\t\t\t\titem.buttonMarkup({\n\t\t\t\t\t\twrapperEls: ""div"",\n\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\tcorners: false,\n\t\t\t\t\t\ticonpos: ""right"",\n\t\t\t\t\t\ticon: a.length > 1 || icon === false ? false : icon || ""arrow-r"",\n\t\t\t\t\t\ttheme: itemTheme\n\t\t\t\t\t});\n\n\t\t\t\t\tif ( ( icon != false ) && ( a.length == 1 ) ) {\n\t\t\t\t\t\titem.addClass( ""ui-li-has-arrow"" );\n\t\t\t\t\t}\n\n\t\t\t\t\ta.first().removeClass( ""ui-link"" ).addClass( ""ui-link-inherit"" );\n\n\t\t\t\t\tif ( a.length > 1 ) {\n\t\t\t\t\t\titemClass += "" ui-li-has-alt"";\n\n\t\t\t\t\t\tlast = a.last();\n\t\t\t\t\t\tsplittheme = listsplittheme || last.jqmData( ""theme"" ) || o.splitTheme;\n\t\t\t\t\t\tlinkIcon = last.jqmData(""icon"");\n\n\t\t\t\t\t\tlast.appendTo(item)\n\t\t\t\t\t\t\t.attr( ""title"", last.getEncodedText() )\n\t\t\t\t\t\t\t.addClass( ""ui-li-link-alt"" )\n\t\t\t\t\t\t\t.empty()\n\t\t\t\t\t\t\t.buttonMarkup({\n\t\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\t\tcorners: false,\n\t\t\t\t\t\t\t\ttheme: itemTheme,\n\t\t\t\t\t\t\t\ticon: false,\n\t\t\t\t\t\t\t\ticonpos: false\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.find( "".ui-btn-inner"" )\n\t\t\t\t\t\t\t\t.append(\n\t\t\t\t\t\t\t\t\t$( document.createElement( ""span"" ) ).buttonMarkup({\n\t\t\t\t\t\t\t\t\t\tshadow: true,\n\t\t\t\t\t\t\t\t\t\tcorners: true,\n\t\t\t\t\t\t\t\t\t\ttheme: splittheme,\n\t\t\t\t\t\t\t\t\t\ticonpos: ""notext"",\n\t\t\t\t\t\t\t\t\t\t// link icon overrides list item icon overrides ul element overrides options\n\t\t\t\t\t\t\t\t\t\ticon: linkIcon || icon || listspliticon || o.splitIcon\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else if ( item.jqmData( ""role"" ) === ""list-divider"" ) {\n\n\t\t\t\t\titemClass += "" ui-li-divider ui-bar-"" + dividertheme;\n\t\t\t\t\titem.attr( ""role"", ""heading"" );\n\n\t\t\t\t\t//reset counter when a divider heading is encountered\n\t\t\t\t\tif ( counter ) {\n\t\t\t\t\t\tcounter = 1;\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\titemClass += "" ui-li-static ui-body-"" + itemTheme;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( counter && itemClass.indexOf( ""ui-li-divider"" ) < 0 ) {\n\t\t\t\tcountParent = item.is( "".ui-li-static:first"" ) ? item : item.find( "".ui-link-inherit"" );\n\n\t\t\t\tcountParent.addClass( ""ui-li-jsnumbering"" )\n\t\t\t\t\t.prepend( ""<span class='ui-li-dec'>"" + (counter++) + "". </span>"" );\n\t\t\t}\n\n\t\t\t// Instead of setting item class directly on the list item and its\n\t\t\t// btn-inner at this point in time, push the item into a dictionary\n\t\t\t// that tells us what class to set on it so we can do this after this\n\t\t\t// processing loop is finished.\n\n\t\t\tif ( !itemClassDict[ itemClass ] ) {\n\t\t\t\titemClassDict[ itemClass ] = [];\n\t\t\t}\n\n\t\t\titemClassDict[ itemClass ].push( item[ 0 ] );\n\t\t}\n\n\t\t// Set the appropriate listview item classes on each list item\n\t\t// and their btn-inner elements. The main reason we didn't do this\n\t\t// in the for-loop above is because we can eliminate per-item function overhead\n\t\t// by calling addClass() and children() once or twice afterwards. This\n\t\t// can give us a significant boost on platforms like WP7.5.\n\n\t\tfor ( itemClass in itemClassDict ) {\n\t\t\t$( itemClassDict[ itemClass ] ).addClass( itemClass ).children( "".ui-btn-inner"" ).addClass( itemClass );\n\t\t}\n\n\t\t$list.find( ""h1, h2, h3, h4, h5, h6"" ).addClass( ""ui-li-heading"" )\n\t\t\t.end()\n\n\t\t\t.find( ""p, dl"" ).addClass( ""ui-li-desc"" )\n\t\t\t.end()\n\n\t\t\t.find( "".ui-li-aside"" ).each(function() {\n\t\t\t\t\tvar $this = $(this);\n\t\t\t\t\t$this.prependTo( $this.parent() ); //shift aside to front for css float\n\t\t\t\t})\n\t\t\t.end()\n\n\t\t\t.find( "".ui-li-count"" ).each( function() {\n\t\t\t\t\t$( this ).closest( ""li"" ).addClass( ""ui-li-has-count"" );\n\t\t\t\t}).addClass( ""ui-btn-up-"" + ( $list.jqmData( ""counttheme"" ) || this.options.countTheme) + "" ui-btn-corner-all"" );\n\n\t\t// The idea here is to look at the first image in the list item\n\t\t// itself, and any .ui-link-inherit element it may contain, so we\n\t\t// can place the appropriate classes on the image and list item.\n\t\t// Note that we used to use something like:\n\t\t//\n\t\t//    li.find("">img:eq(0), .ui-link-inherit>img:eq(0)"").each( ... );\n\t\t//\n\t\t// But executing a find() like that on Windows Phone 7.5 took a\n\t\t// really long time. Walking things manually with the code below\n\t\t// allows the 400 listview item page to load in about 3 seconds as\n\t\t// opposed to 30 seconds.\n\n\t\tthis._addThumbClasses( li );\n\t\tthis._addThumbClasses( $list.find( "".ui-link-inherit"" ) );\n\n\t\tthis._refreshCorners( create );\n\t},\n\n\t//create a string for ID/subpage url creation\n\t_idStringEscape: function( str ) {\n\t\treturn str.replace(/[^a-zA-Z0-9]/g, '-');\n\t},\n\n\t_createSubPages: function() {\n\t\tvar parentList = this.element,\n\t\t\tparentPage = parentList.closest( "".ui-page"" ),\n\t\t\tparentUrl = parentPage.jqmData( ""url"" ),\n\t\t\tparentId = parentUrl || parentPage[ 0 ][ $.expando ],\n\t\t\tparentListId = parentList.attr( ""id"" ),\n\t\t\to = this.options,\n\t\t\tdns = ""data-"" + $.mobile.ns,\n\t\t\tself = this,\n\t\t\tpersistentFooterID = parentPage.find( "":jqmData(role='footer')"" ).jqmData( ""id"" ),\n\t\t\thasSubPages;\n\n\t\tif ( typeof listCountPerPage[ parentId ] === ""undefined"" ) {\n\t\t\tlistCountPerPage[ parentId ] = -1;\n\t\t}\n\n\t\tparentListId = parentListId || ++listCountPerPage[ parentId ];\n\n\t\t$( parentList.find( ""li>ul, li>ol"" ).toArray().reverse() ).each(function( i ) {\n\t\t\tvar self = this,\n\t\t\t\tlist = $( this ),\n\t\t\t\tlistId = list.attr( ""id"" ) || parentListId + ""-"" + i,\n\t\t\t\tparent = list.parent(),\n\t\t\t\tnodeEls = $( list.prevAll().toArray().reverse() ),\n\t\t\t\tnodeEls = nodeEls.length ? nodeEls : $( ""<span>"" + $.trim(parent.contents()[ 0 ].nodeValue) + ""</span>"" ),\n\t\t\t\ttitle = nodeEls.first().getEncodedText(),//url limits to first 30 chars of text\n\t\t\t\tid = ( parentUrl || """" ) + ""&"" + $.mobile.subPageUrlKey + ""="" + listId,\n\t\t\t\ttheme = list.jqmData( ""theme"" ) || o.theme,\n\t\t\t\tcountTheme = list.jqmData( ""counttheme"" ) || parentList.jqmData( ""counttheme"" ) || o.countTheme,\n\t\t\t\tnewPage, anchor;\n\n\t\t\t//define hasSubPages for use in later removal\n\t\t\thasSubPages = true;\n\n\t\t\tnewPage = list.detach()\n\t\t\t\t\t\t.wrap( ""<div "" + dns + ""role='page' "" +\tdns + ""url='"" + id + ""' "" + dns + ""theme='"" + theme + ""' "" + dns + ""count-theme='"" + countTheme + ""'><div "" + dns + ""role='content'></div></div>"" )\n\t\t\t\t\t\t.parent()\n\t\t\t\t\t\t\t.before( ""<div "" + dns + ""role='header' "" + dns + ""theme='"" + o.headerTheme + ""'><div class='ui-title'>"" + title + ""</div></div>"" )\n\t\t\t\t\t\t\t.after( persistentFooterID ? $( ""<div "" + dns + ""role='footer' "" + dns + ""id='""+ persistentFooterID +""'>"") : """" )\n\t\t\t\t\t\t\t.parent()\n\t\t\t\t\t\t\t\t.appendTo( $.mobile.pageContainer );\n\n\t\t\tnewPage.page();\n\n\t\t\tanchor = parent.find('a:first');\n\n\t\t\tif ( !anchor.length ) {\n\t\t\t\tanchor = $( ""<a/>"" ).html( nodeEls || title ).prependTo( parent.empty() );\n\t\t\t}\n\n\t\t\tanchor.attr( ""href"", ""#"" + id );\n\n\t\t}).listview();\n\n\t\t// on pagehide, remove any nested pages along with the parent page, as long as they aren't active\n\t\t// and aren't embedded\n\t\tif( hasSubPages &&\n\t\t\tparentPage.is( "":jqmData(external-page='true')"" ) &&\n\t\t\tparentPage.data(""page"").options.domCache === false ) {\n\n\t\t\tvar newRemove = function( e, ui ){\n\t\t\t\tvar nextPage = ui.nextPage, npURL;\n\n\t\t\t\tif( ui.nextPage ){\n\t\t\t\t\tnpURL = nextPage.jqmData( ""url"" );\n\t\t\t\t\tif( npURL.indexOf( parentUrl + ""&"" + $.mobile.subPageUrlKey ) !== 0 ){\n\t\t\t\t\t\tself.childPages().remove();\n\t\t\t\t\t\tparentPage.remove();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// unbind the original page remove and replace with our specialized version\n\t\t\tparentPage\n\t\t\t\t.unbind( ""pagehide.remove"" )\n\t\t\t\t.bind( ""pagehide.remove"", newRemove);\n\t\t}\n\t},\n\n\t// TODO sort out a better way to track sub pages of the listview this is brittle\n\tchildPages: function(){\n\t\tvar parentUrl = this.parentPage.jqmData( ""url"" );\n\n\t\treturn $( "":jqmData(url^='""+  parentUrl + ""&"" + $.mobile.subPageUrlKey +""')"");\n\t}\n});\n\n//auto self-init widgets\n$( document ).bind( ""pagecreate create"", function( e ){\n\t$.mobile.listview.prototype.enhanceWithin( e.target );\n});\n\n})( jQuery );\n\n/*\n* ""checkboxradio"" plugin\n*/\n\n(function( $, undefined ) {\n\n$.widget( ""mobile.checkboxradio"", $.mobile.widget, {\n\toptions: {\n\t\ttheme: null,\n\t\tinitSelector: ""input[type='checkbox'],input[type='radio']""\n\t},\n\t_create: function() {\n\t\tvar self = this,\n\t\t\tinput = this.element,\n\t\t\tinheritAttr = function( input, dataAttr ) {\n\t\t\t\treturn input.jqmData( dataAttr ) || input.closest( ""form,fieldset"" ).jqmData( dataAttr )\n\t\t\t},\n\t\t\t// NOTE: Windows Phone could not find the label through a selector\n\t\t\t// filter works though.\n\t\t\tparentLabel = $( input ).closest( ""label"" ),\n\t\t\tlabel = parentLabel.length ? parentLabel : $( input ).closest( ""form,fieldset,:jqmData(role='page'),:jqmData(role='dialog')"" ).find( ""label"" ).filter( ""[for='"" + input[0].id + ""']"" ),\n\t\t\tinputtype = input[0].type,\n\t\t\tmini = inheritAttr( input, ""mini"" ),\n\t\t\tcheckedState = inputtype + ""-on"",\n\t\t\tuncheckedState = inputtype + ""-off"",\n\t\t\ticon = input.parents( "":jqmData(type='horizontal')"" ).length ? undefined : uncheckedState,\n\t\t\ticonpos = inheritAttr( input, ""iconpos"" ),\n\t\t\tactiveBtn = icon ? """" : "" "" + $.mobile.activeBtnClass,\n\t\t\tcheckedClass = ""ui-"" + checkedState + activeBtn,\n\t\t\tuncheckedClass = ""ui-"" + uncheckedState,\n\t\t\tcheckedicon = ""ui-icon-"" + checkedState,\n\t\t\tuncheckedicon = ""ui-icon-"" + uncheckedState;\n\n\t\tif ( inputtype !== ""checkbox"" && inputtype !== ""radio"" ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Expose for other methods\n\t\t$.extend( this, {\n\t\t\tlabel: label,\n\t\t\tinputtype: inputtype,\n\t\t\tcheckedClass: checkedClass,\n\t\t\tuncheckedClass: uncheckedClass,\n\t\t\tcheckedicon: checkedicon,\n\t\t\tuncheckedicon: uncheckedicon\n\t\t});\n\n\t\t// If there's no selected theme check the data attr\n\t\tif( !this.options.theme ) {\n\t\t\tthis.options.theme = $.mobile.getInheritedTheme( this.element, ""c"" );\n\t\t}\n\n\t\tlabel.buttonMarkup({\n\t\t\ttheme: this.options.theme,\n\t\t\ticon: icon,\n\t\t\tshadow: false,\n\t\t\tmini: mini,\n\t\t\ticonpos: iconpos\n\t\t});\n\n\t\t// Wrap the input + label in a div\n\t\tvar wrapper = document.createElement('div');\n\t\twrapper.className = 'ui-' + inputtype;\n\n\t\tinput.add( label ).wrapAll( wrapper );\n\n\t\tlabel.bind({\n\t\t\tvmouseover: function( event ) {\n\t\t\t\tif ( $( this ).parent().is( "".ui-disabled"" ) ) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tvclick: function( event ) {\n\t\t\t\tif ( input.is( "":disabled"" ) ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tself._cacheVals();\n\n\t\t\t\tinput.prop( ""checked"", inputtype === ""radio"" && true || !input.prop( ""checked"" ) );\n\n\t\t\t\t// trigger click handler's bound directly to the input as a substitute for\n\t\t\t\t// how label clicks behave normally in the browsers\n\t\t\t\t// TODO: it would be nice to let the browser's handle the clicks and pass them\n\t\t\t\t//       through to the associate input. we can swallow that click at the parent\n\t\t\t\t//       wrapper element level\n\t\t\t\tinput.triggerHandler( 'click' );\n\n\t\t\t\t// Input set for common radio buttons will contain all the radio\n\t\t\t\t// buttons, but will not for checkboxes. clearing the checked status\n\t\t\t\t// of other radios ensures the active button state is applied properly\n\t\t\t\tself._getInputSet().not( input ).prop( ""checked"", false );\n\n\t\t\t\tself._updateAll();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\n\t\tinput\n\t\t\t.bind({\n\t\t\t\tvmousedown: function() {\n\t\t\t\t\tself._cacheVals();\n\t\t\t\t},\n\n\t\t\t\tvclick: function() {\n\t\t\t\t\tvar $this = $(this);\n\n\t\t\t\t\t// Adds checked attribute to checked input when keyboard is used\n\t\t\t\t\tif ( $this.is( "":checked"" ) ) {\n\n\t\t\t\t\t\t$this.prop( ""checked"", true);\n\t\t\t\t\t\tself._getInputSet().not($this).prop( ""checked"", false );\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t$this.prop( ""checked"", false );\n\t\t\t\t\t}\n\n\t\t\t\t\tself._updateAll();\n\t\t\t\t},\n\n\t\t\t\tfocus: function() {\n\t\t\t\t\tlabel.addClass( $.mobile.focusClass );\n\t\t\t\t},\n\n\t\t\t\tblur: function() {\n\t\t\t\t\tlabel.removeClass( $.mobile.focusClass );\n\t\t\t\t}\n\t\t\t});\n\n\t\tthis.refresh();\n\t},\n\n\t_cacheVals: function() {\n\t\tthis._getInputSet().each(function() {\n\t\t\t$(this).jqmData( ""cacheVal"", this.checked );\n\t\t});\n\t},\n\n\t//returns either a set of radios with the same name attribute, or a single checkbox\n\t_getInputSet: function(){\n\t\tif(this.inputtype === ""checkbox"") {\n\t\t\treturn this.element;\n\t\t}\n\n\t\treturn this.element.closest( ""form,fieldset,:jqmData(role='page')"" )\n\t\t\t.find( ""input[name='""+ this.element[0].name +""'][type='""+ this.inputtype +""']"" );\n\t},\n\n\t_updateAll: function() {\n\t\tvar self = this;\n\n\t\tthis._getInputSet().each(function() {\n\t\t\tvar $this = $(this);\n\n\t\t\tif ( this.checked || self.inputtype === ""checkbox"" ) {\n\t\t\t\t$this.trigger( ""change"" );\n\t\t\t}\n\t\t})\n\t\t.checkboxradio( ""refresh"" );\n\t},\n\n\trefresh: function() {\n\t\tvar input = this.element[0],\n\t\t\tlabel = this.label,\n\t\t\ticon = label.find( "".ui-icon"" );\n\n\t\tif ( input.checked ) {\n\t\t\tlabel.addClass( this.checkedClass ).removeClass( this.uncheckedClass );\n\t\t\ticon.addClass( this.checkedicon ).removeClass( this.uncheckedicon );\n\t\t} else {\n\t\t\tlabel.removeClass( this.checkedClass ).addClass( this.uncheckedClass );\n\t\t\ticon.removeClass( this.checkedicon ).addClass( this.uncheckedicon );\n\t\t}\n\n\t\tif ( input.disabled ) {\n\t\t\tthis.disable();\n\t\t} else {\n\t\t\tthis.enable();\n\t\t}\n\t},\n\n\tdisable: function() {\n\t\tthis.element.prop( ""disabled"", true ).parent().addClass( ""ui-disabled"" );\n\t},\n\n\tenable: function() {\n\t\tthis.element.prop( ""disabled"", false ).parent().removeClass( ""ui-disabled"" );\n\t}\n});\n\n//auto self-init widgets\n$( document ).bind( ""pagecreate create"", function( e ){\n\t$.mobile.checkboxradio.prototype.enhanceWithin( e.target, true );\n});\n\n})( jQuery );\n\n(function( $, undefined ) {\n\n$.widget( ""mobile.button"", $.mobile.widget, {\n\toptions: {\n\t\ttheme: null,\n\t\ticon: null,\n\t\ticonpos: null,\n\t\tinline: false,\n\t\tcorners: true,\n\t\tshadow: true,\n\t\ticonshadow: true,\n\t\tinitSelector: ""button, [type='button'], [type='submit'], [type='reset'], [type='image']"",\n\t\tmini: false\n\t},\n\t_create: function() {\n\t\tvar $el = this.element,\n\t\t\t$button,\n\t\t\to = this.options,\n\t\t\ttype,\n\t\t\tname,\n\t\t\tclasses = """",\n\t\t\t$buttonPlaceholder;\n\n\t\t// if this is a link, check if it's been enhanced and, if not, use the right function\n\t\tif( $el[ 0 ].tagName === ""A"" ) {\n\t \t \t!$el.hasClass( ""ui-btn"" ) && $el.buttonMarkup();\n\t \t \treturn;\n \t \t}\n\n\t\t// get the inherited theme\n\t\t// TODO centralize for all widgets\n\t\tif ( !this.options.theme ) {\n\t\t\tthis.options.theme = $.mobile.getInheritedTheme( this.element, ""c"" );\n\t\t}\n\n\t\t// TODO: Post 1.1--once we have time to test thoroughly--any classes manually applied to the original element should be carried over to the enhanced element, with an `-enhanced` suffix. See https://github.com/jquery/jquery-mobile/issues/3577\n\t\t/* if( $el[0].className.length ) {\n\t\t\tclasses = $el[0].className;\n\t\t} */\n\t\tif( !!~$el[0].className.indexOf( ""ui-btn-left"" ) ) {\n\t\t\tclasses = ""ui-btn-left"";\n\t\t}\n\n\t\tif(  !!~$el[0].className.indexOf( ""ui-btn-right"" ) ) {\n\t\t\tclasses = ""ui-btn-right"";\n\t\t}\n\n\t\t// Add ARIA role\n\t\tthis.button = $( ""<div></div>"" )\n\t\t\t.text( $el.text() || $el.val() )\n\t\t\t.insertBefore( $el )\n\t\t\t.buttonMarkup({\n\t\t\t\ttheme: o.theme,\n\t\t\t\ticon: o.icon,\n\t\t\t\ticonpos: o.iconpos,\n\t\t\t\tinline: o.inline,\n\t\t\t\tcorners: o.corners,\n\t\t\t\tshadow: o.shadow,\n\t\t\t\ticonshadow: o.iconshadow,\n\t\t\t\tmini: o.mini\n\t\t\t})\n\t\t\t.addClass( classes )\n\t\t\t.append( $el.addClass( ""ui-btn-hidden"" ) );\n\n        $button = this.button;\n\t\ttype = $el.attr( ""type"" );\n\t\tname = $el.attr( ""name"" );\n\n\t\t// Add hidden input during submit if input type=""submit"" has a name.\n\t\tif ( type !== ""button"" && type !== ""reset"" && name ) {\n\t\t\t\t$el.bind( ""vclick"", function() {\n\t\t\t\t\t// Add hidden input if it doesn’t already exist.\n\t\t\t\t\tif( $buttonPlaceholder === undefined ) {\n\t\t\t\t\t\t$buttonPlaceholder = $( ""<input>"", {\n\t\t\t\t\t\t\ttype: ""hidden"",\n\t\t\t\t\t\t\tname: $el.attr( ""name"" ),\n\t\t\t\t\t\t\tvalue: $el.attr( ""value"" )\n\t\t\t\t\t\t}).insertBefore( $el );\n\n\t\t\t\t\t\t// Bind to doc to remove after submit handling\n\t\t\t\t\t\t$( document ).one(""submit"", function(){\n\t\t\t\t\t\t\t$buttonPlaceholder.remove();\n\n\t\t\t\t\t\t\t// reset the local var so that the hidden input\n\t\t\t\t\t\t\t// will be re-added on subsequent clicks\n\t\t\t\t\t\t\t$buttonPlaceholder = undefined;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\n        $el.bind({\n            focus: function() {\n                $button.addClass( $.mobile.focusClass );\n            },\n\n            blur: function() {\n                $button.removeClass( $.mobile.focusClass );\n            }\n        });\n\n\t\tthis.refresh();\n\t},\n\n\tenable: function() {\n\t\tthis.element.attr( ""disabled"", false );\n\t\tthis.button.removeClass( ""ui-disabled"" ).attr( ""aria-disabled"", false );\n\t\treturn this._setOption( ""disabled"", false );\n\t},\n\n\tdisable: function() {\n\t\tthis.element.attr( ""disabled"", true );\n\t\tthis.button.addClass( ""ui-disabled"" ).attr( ""aria-disabled"", true );\n\t\treturn this._setOption( ""disabled"", true );\n\t},\n\n\trefresh: function() {\n\t\tvar $el = this.element;\n\n\t\tif ( $el.prop(""disabled"") ) {\n\t\t\tthis.disable();\n\t\t} else {\n\t\t\tthis.enable();\n\t\t}\n\n\t\t// Grab the button's text element from its implementation-independent data item\n\t\t$( this.button.data( 'buttonElements' ).text ).text( $el.text() || $el.val() );\n\t}\n});\n\n//auto self-init widgets\n$( document ).bind( ""pagecreate create"", function( e ){\n\t$.mobile.button.prototype.enhanceWithin( e.target, true );\n});\n\n})( jQuery );\n\n(function( $, undefined ) {\n\n$.fn.controlgroup = function( options ) {\n\tfunction flipClasses( els, flCorners  ) {\n\t\tels.removeClass( ""ui-btn-corner-all ui-shadow"" )\n\t\t\t.eq( 0 ).addClass( flCorners[ 0 ] )\n\t\t\t.end()\n\t\t\t.last().addClass( flCorners[ 1 ] ).addClass( ""ui-controlgroup-last"" );\n\t}\n\n\treturn this.each(function() {\n\t\tvar $el = $( this ),\n\t\t\to = $.extend({\n\t\t\t\t\t\tdirection: $el.jqmData( ""type"" ) || ""vertical"",\n\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\texcludeInvisible: true,\n\t\t\t\t\t\tmini: $el.jqmData( ""mini"" )\n\t\t\t\t\t}, options ),\n\t\t\tgroupheading = $el.children( ""legend"" ),\n\t\t\tflCorners = o.direction == ""horizontal"" ? [ ""ui-corner-left"", ""ui-corner-right"" ] : [ ""ui-corner-top"", ""ui-corner-bottom"" ],\n\t\t\ttype = $el.find( ""input"" ).first().attr( ""type"" );\n\n\t\t// Replace legend with more stylable replacement div\n\t\tif ( groupheading.length ) {\n\t\t\t$el.wrapInner( ""<div class='ui-controlgroup-controls'></div>"" );\n\t\t\t$( ""<div role='heading' class='ui-controlgroup-label'>"" + groupheading.html() + ""</div>"" ).insertBefore( $el.children(0) );\n\t\t\tgroupheading.remove();\n\t\t}\n\n\t\t$el.addClass( ""ui-corner-all ui-controlgroup ui-controlgroup-"" + o.direction );\n\n\t\tflipClasses( $el.find( "".ui-btn"" + ( o.excludeInvisible ? "":visible"" : """" ) ).not('.ui-slider-handle'), flCorners );\n\t\tflipClasses( $el.find( "".ui-btn-inner"" ), flCorners );\n\n\t\tif ( o.shadow ) {\n\t\t\t$el.addClass( ""ui-shadow"" );\n\t\t}\n\n\t\tif ( o.mini ) {\n\t\t\t$el.addClass( ""ui-mini"" );\n\t\t}\n\n\t});\n};\n\n// The pagecreate handler for controlgroup is in jquery.mobile.init because of the soft-dependency on the wrapped widgets\n\n})(jQuery);\n\n(function( $, undefined ) {\n\n$( document ).bind( ""pagecreate create"", function( e ){\n\n\t//links within content areas, tests included with page\n\t$( e.target )\n\t\t.find( ""a"" )\n\t\t.jqmEnhanceable()\n\t\t.not( "".ui-btn, .ui-link-inherit, :jqmData(role='none'), :jqmData(role='nojs')"" )\n\t\t.addClass( ""ui-link"" );\n\n});\n\n})( jQuery );\n\n\n( function( $ ) {\n\tvar\tmeta = $( ""meta[name=viewport]"" ),\n        initialContent = meta.attr( ""content"" ),\n        disabledZoom = initialContent + "",maximum-scale=1, user-scalable=no"",\n        enabledZoom = initialContent + "",maximum-scale=10, user-scalable=yes"",\n\t\tdisabledInitially = /(user-scalable[\\s]*=[\\s]*no)|(maximum-scale[\\s]*=[\\s]*1)[$,\\s]/.test( initialContent );\n\t\n\t$.mobile.zoom = $.extend( {}, {\n\t\tenabled: !disabledInitially,\n\t\tlocked: false,\n\t\tdisable: function( lock ) {\n\t\t\tif( !disabledInitially && !$.mobile.zoom.locked ){\n\t        \tmeta.attr( ""content"", disabledZoom );\n\t        \t$.mobile.zoom.enabled = false;\n\t\t\t\t$.mobile.zoom.locked = lock || false;\n\t\t\t}\n\t\t},\n\t\tenable: function( unlock ) {\n\t\t\tif( !disabledInitially && ( !$.mobile.zoom.locked || unlock === true ) ){\n\t\t        meta.attr( ""content"", enabledZoom );\n\t\t        $.mobile.zoom.enabled = true;\n\t\t\t\t$.mobile.zoom.locked = false;\n\t\t\t}\n\t\t},\n\t\trestore: function() {\n\t\t\tif( !disabledInitially ){\n\t        \tmeta.attr( ""content"", initialContent );\n\t        \t$.mobile.zoom.enabled = true;\n\t\t\t}\n\t\t}\n\t});\n\n}( jQuery ));\n\n(function( $, undefined ) {\n\n$.widget( ""mobile.textinput"", $.mobile.widget, {\n\toptions: {\n\t\ttheme: null,\n\t\t// This option defaults to true on iOS devices.\n\t\tpreventFocusZoom: /iPhone|iPad|iPod/.test( navigator.platform ) && navigator.userAgent.indexOf( ""AppleWebKit"" ) > -1,\n\t\tinitSelector: ""input[type='text'], input[type='search'], :jqmData(type='search'), input[type='number'], :jqmData(type='number'), input[type='password'], input[type='email'], input[type='url'], input[type='tel'], textarea, input[type='time'], input[type='date'], input[type='month'], input[type='week'], input[type='datetime'], input[type='datetime-local'], input[type='color'], input:not([type])"",\n\t\tclearSearchButtonText: ""clear text""\n\t},\n\n\t_create: function() {\n\n\t\tvar input = this.element,\n\t\t\to = this.options,\n\t\t\ttheme = o.theme || $.mobile.getInheritedTheme( this.element, ""c"" ),\n\t\t\tthemeclass  = "" ui-body-"" + theme,\n\t\t\tmini = input.jqmData(""mini"") == true,\n\t\t\tminiclass = mini ? "" ui-mini"" : """",\n\t\t\tfocusedEl, clearbtn;\n\n\t\t$( ""label[for='"" + input.attr( ""id"" ) + ""']"" ).addClass( ""ui-input-text"" );\n\n\t\tfocusedEl = input.addClass(""ui-input-text ui-body-""+ theme );\n\n\t\t// XXX: Temporary workaround for issue 785 (Apple bug 8910589).\n\t\t//      Turn off autocorrect and autocomplete on non-iOS 5 devices\n\t\t//      since the popup they use can't be dismissed by the user. Note\n\t\t//      that we test for the presence of the feature by looking for\n\t\t//      the autocorrect property on the input element. We currently\n\t\t//      have no test for iOS 5 or newer so we're temporarily using\n\t\t//      the touchOverflow support flag for jQM 1.0. Yes, I feel dirty. - jblas\n\t\tif ( typeof input[0].autocorrect !== ""undefined"" && !$.support.touchOverflow ) {\n\t\t\t// Set the attribute instead of the property just in case there\n\t\t\t// is code that attempts to make modifications via HTML.\n\t\t\tinput[0].setAttribute( ""autocorrect"", ""off"" );\n\t\t\tinput[0].setAttribute( ""autocomplete"", ""off"" );\n\t\t}\n\n\n\t\t//""search"" input widget\n\t\tif ( input.is( ""[type='search'],:jqmData(type='search')"" ) ) {\n\n\t\t\tfocusedEl = input.wrap( ""<div class='ui-input-search ui-shadow-inset ui-btn-corner-all ui-btn-shadow ui-icon-searchfield"" + themeclass + miniclass + ""'></div>"" ).parent();\n\t\t\tclearbtn = $( ""<a href='#' class='ui-input-clear' title='"" + o.clearSearchButtonText + ""'>"" + o.clearSearchButtonText + ""</a>"" )\n\t\t\t\t.bind('click', function( event ) {\n\t\t\t\t\tinput\n\t\t\t\t\t\t.val( """" )\n\t\t\t\t\t\t.focus()\n\t\t\t\t\t\t.trigger( ""change"" );\n\t\t\t\t\tclearbtn.addClass( ""ui-input-clear-hidden"" );\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t})\n\t\t\t\t.appendTo( focusedEl )\n\t\t\t\t.buttonMarkup({\n\t\t\t\t\ticon: ""delete"",\n\t\t\t\t\ticonpos: ""notext"",\n\t\t\t\t\tcorners: true,\n\t\t\t\t\tshadow: true,\n\t\t\t\t\tmini: mini\n\t\t\t\t});\n\n\t\t\tfunction toggleClear() {\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tclearbtn.toggleClass( ""ui-input-clear-hidden"", !input.val() );\n\t\t\t\t}, 0);\n\t\t\t}\n\n\t\t\ttoggleClear();\n\n\t\t\tinput.bind('paste cut keyup focus change blur', toggleClear);\n\n\t\t} else {\n\t\t\tinput.addClass( ""ui-corner-all ui-shadow-inset"" + themeclass + miniclass );\n\t\t}\n\n\t\tinput.focus(function() {\n\t\t\t\tfocusedEl.addClass( $.mobile.focusClass );\n\t\t\t})\n\t\t\t.blur(function(){\n\t\t\t\tfocusedEl.removeClass( $.mobile.focusClass );\n\t\t\t})\n\t\t\t// In many situations, iOS will zoom into the select upon tap, this prevents that from happening\n\t\t\t.bind( ""focus"", function() {\n\t\t\t\tif( o.preventFocusZoom ){\n\t\t\t\t\t$.mobile.zoom.disable( true );\n\t\t\t\t}\n\t\t\t})\n\t\t\t.bind( ""blur"", function() {\n\t\t\t\tif( o.preventFocusZoom ){\n\t\t\t\t\t$.mobile.zoom.enable( true );\n\t\t\t\t}\n\t\t\t});\n\n\t\t// Autogrow\n\t\tif ( input.is( ""textarea"" ) ) {\n\t\t\tvar extraLineHeight = 15,\n\t\t\t\tkeyupTimeoutBuffer = 100,\n\t\t\t\tkeyup = function() {\n\t\t\t\t\tvar scrollHeight = input[ 0 ].scrollHeight,\n\t\t\t\t\t\tclientHeight = input[ 0 ].clientHeight;\n\n\t\t\t\t\tif ( clientHeight < scrollHeight ) {\n\t\t\t\t\t\tinput.height(scrollHeight + extraLineHeight);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tkeyupTimeout;\n\n\t\t\tinput.keyup(function() {\n\t\t\t\tclearTimeout( keyupTimeout );\n\t\t\t\tkeyupTimeout = setTimeout( keyup, keyupTimeoutBuffer );\n\t\t\t});\n\n\t\t\t// binding to pagechange here ensures that for pages loaded via\n\t\t\t// ajax the height is recalculated without user input\n\t\t\t$( document ).one( ""pagechange"", keyup );\n\n\t\t\t// Issue 509: the browser is not providing scrollHeight properly until the styles load\n\t\t\tif ( $.trim( input.val() ) ) {\n\t\t\t\t// bind to the window load to make sure the height is calculated based on BOTH\n\t\t\t\t// the DOM and CSS\n\t\t\t\t$( window ).load( keyup );\n\t\t\t}\n\t\t}\n\t},\n\n\tdisable: function(){\n\t\t( this.element.attr( ""disabled"", true ).is( ""[type='search'],:jqmData(type='search')"" ) ?\n\t\t\tthis.element.parent() : this.element ).addClass( ""ui-disabled"" );\n\t},\n\n\tenable: function(){\n\t\t( this.element.attr( ""disabled"", false).is( ""[type='search'],:jqmData(type='search')"" ) ?\n\t\t\tthis.element.parent() : this.element ).removeClass( ""ui-disabled"" );\n\t}\n});\n\n//auto self-init widgets\n$( document ).bind( ""pagecreate create"", function( e ){\n\t$.mobile.textinput.prototype.enhanceWithin( e.target, true );\n});\n\n})( jQuery );\n\n(function( $, undefined ) {\n\n$.mobile.listview.prototype.options.filter = false;\n$.mobile.listview.prototype.options.filterPlaceholder = ""Filter items..."";\n$.mobile.listview.prototype.options.filterTheme = ""c"";\n$.mobile.listview.prototype.options.filterCallback = function( text, searchValue ){\n\treturn text.toLowerCase().indexOf( searchValue ) === -1;\n};\n\n$( document ).delegate( "":jqmData(role='listview')"", ""listviewcreate"", function() {\n\n\tvar list = $( this ),\n\t\tlistview = list.data( ""listview"" );\n\n\tif ( !listview.options.filter ) {\n\t\treturn;\n\t}\n\n\tvar wrapper = $( ""<form>"", {\n\t\t\t""class"": ""ui-listview-filter ui-bar-"" + listview.options.filterTheme,\n\t\t\t""role"": ""search""\n\t\t}),\n\t\tsearch = $( ""<input>"", {\n\t\t\tplaceholder: listview.options.filterPlaceholder\n\t\t})\n\t\t.attr( ""data-"" + $.mobile.ns + ""type"", ""search"" )\n\t\t.jqmData( ""lastval"", """" )\n\t\t.bind( ""keyup change"", function() {\n\n\t\t\tvar $this = $(this),\n\t\t\t\tval = this.value.toLowerCase(),\n\t\t\t\tlistItems = null,\n\t\t\t\tlastval = $this.jqmData( ""lastval"" ) + """",\n\t\t\t\tchildItems = false,\n\t\t\t\titemtext = """",\n\t\t\t\titem;\n\n\t\t\t// Change val as lastval for next execution\n\t\t\t$this.jqmData( ""lastval"" , val );\n\t\t\tif ( val.length < lastval.length || val.indexOf(lastval) !== 0 ) {\n\n\t\t\t\t// Removed chars or pasted something totally different, check all items\n\t\t\t\tlistItems = list.children();\n\t\t\t} else {\n\n\t\t\t\t// Only chars added, not removed, only use visible subset\n\t\t\t\tlistItems = list.children( "":not(.ui-screen-hidden)"" );\n\t\t\t}\n\n\t\t\tif ( val ) {\n\n\t\t\t\t// This handles hiding regular rows without the text we search for\n\t\t\t\t// and any list dividers without regular rows shown under it\n\n\t\t\t\tfor ( var i = listItems.length - 1; i >= 0; i-- ) {\n\t\t\t\t\titem = $( listItems[ i ] );\n\t\t\t\t\titemtext = item.jqmData( ""filtertext"" ) || item.text();\n\n\t\t\t\t\tif ( item.is( ""li:jqmData(role=list-divider)"" ) ) {\n\n\t\t\t\t\t\titem.toggleClass( ""ui-filter-hidequeue"" , !childItems );\n\n\t\t\t\t\t\t// New bucket!\n\t\t\t\t\t\tchildItems = false;\n\n\t\t\t\t\t} else if ( listview.options.filterCallback( itemtext, val ) ) {\n\n\t\t\t\t\t\t//mark to be hidden\n\t\t\t\t\t\titem.toggleClass( ""ui-filter-hidequeue"" , true );\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// There's a shown item in the bucket\n\t\t\t\t\t\tchildItems = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Show items, not marked to be hidden\n\t\t\t\tlistItems\n\t\t\t\t\t.filter( "":not(.ui-filter-hidequeue)"" )\n\t\t\t\t\t.toggleClass( ""ui-screen-hidden"", false );\n\n\t\t\t\t// Hide items, marked to be hidden\n\t\t\t\tlistItems\n\t\t\t\t\t.filter( "".ui-filter-hidequeue"" )\n\t\t\t\t\t.toggleClass( ""ui-screen-hidden"", true )\n\t\t\t\t\t.toggleClass( ""ui-filter-hidequeue"", false );\n\n\t\t\t} else {\n\n\t\t\t\t//filtervalue is empty => show all\n\t\t\t\tlistItems.toggleClass( ""ui-screen-hidden"", false );\n\t\t\t}\n\t\t\tlistview._refreshCorners();\n\t\t})\n\t\t.appendTo( wrapper )\n\t\t.textinput();\n\n\tif ( listview.options.inset ) {\n\t\twrapper.addClass( ""ui-listview-filter-inset"" );\n\t}\n\n\twrapper.bind( ""submit"", function() {\n\t\treturn false;\n\t})\n\t.insertBefore( list );\n});\n\n})( jQuery );\n\n( function( $, undefined ) {\n\n$.widget( ""mobile.slider"", $.mobile.widget, {\n\toptions: {\n\t\ttheme: null,\n\t\ttrackTheme: null,\n\t\tdisabled: false,\n\t\tinitSelector: ""input[type='range'], :jqmData(type='range'), :jqmData(role='slider')"",\n\t\tmini: false\n\t},\n\n\t_create: function() {\n\n\t\t// TODO: Each of these should have comments explain what they're for\n\t\tvar self = this,\n\n\t\t\tcontrol = this.element,\n\n\t\t\tparentTheme = $.mobile.getInheritedTheme( control, ""c"" ),\n\n\t\t\ttheme = this.options.theme || parentTheme,\n\n\t\t\ttrackTheme = this.options.trackTheme || parentTheme,\n\n\t\t\tcType = control[ 0 ].nodeName.toLowerCase(),\n\n\t\t\tselectClass = ( cType == ""select"" ) ? ""ui-slider-switch"" : """",\n\n\t\t\tcontrolID = control.attr( ""id"" ),\n\n\t\t\tlabelID = controlID + ""-label"",\n\n\t\t\tlabel = $( ""[for='""+ controlID +""']"" ).attr( ""id"", labelID ),\n\n\t\t\tval = function() {\n\t\t\t\treturn  cType == ""input""  ? parseFloat( control.val() ) : control[0].selectedIndex;\n\t\t\t},\n\n\t\t\tmin =  cType == ""input"" ? parseFloat( control.attr( ""min"" ) ) : 0,\n\n\t\t\tmax =  cType == ""input"" ? parseFloat( control.attr( ""max"" ) ) : control.find( ""option"" ).length-1,\n\n\t\t\tstep = window.parseFloat( control.attr( ""step"" ) || 1 ),\n\n\t\t\tinlineClass = ( this.options.inline || control.jqmData(""inline"") == true ) ? "" ui-slider-inline"" : """",\n\n\t\t\tminiClass = ( this.options.mini || control.jqmData(""mini"") ) ? "" ui-slider-mini"" : """",\n\n\n\t\t\tdomHandle = document.createElement('a'),\n\t\t\thandle = $( domHandle ),\n\t\t\tdomSlider = document.createElement('div'),\n\t\t\tslider = $( domSlider ),\n\n\t\t\tvaluebg = control.jqmData(""highlight"") && cType != ""select"" ? (function() {\n\t\t\t\tvar bg = document.createElement('div');\n\t\t\t\tbg.className = 'ui-slider-bg ui-btn-active ui-btn-corner-all';\n\t\t\t\treturn $( bg ).prependTo( slider );\n\t\t\t})() : false,\n\n\t\t\toptions;\n\n        domHandle.setAttribute( 'href', ""#"" );\n\t\tdomSlider.setAttribute('role','application');\n\t\tdomSlider.className = ['ui-slider ',selectClass,"" ui-btn-down-"",trackTheme,' ui-btn-corner-all', inlineClass, miniClass].join("""");\n\t\tdomHandle.className = 'ui-slider-handle';\n\t\tdomSlider.appendChild(domHandle);\n\n\t\thandle.buttonMarkup({ corners: true, theme: theme, shadow: true })\n\t\t\t\t.attr({\n\t\t\t\t\t""role"": ""slider"",\n\t\t\t\t\t""aria-valuemin"": min,\n\t\t\t\t\t""aria-valuemax"": max,\n\t\t\t\t\t""aria-valuenow"": val(),\n\t\t\t\t\t""aria-valuetext"": val(),\n\t\t\t\t\t""title"": val(),\n\t\t\t\t\t""aria-labelledby"": labelID\n\t\t\t\t});\n\n\t\t$.extend( this, {\n\t\t\tslider: slider,\n\t\t\thandle: handle,\n\t\t\tvaluebg: valuebg,\n\t\t\tdragging: false,\n\t\t\tbeforeStart: null,\n\t\t\tuserModified: false,\n\t\t\tmouseMoved: false\n\t\t});\n\n\t\tif ( cType == ""select"" ) {\n\t\t\tvar wrapper = document.createElement('div');\n\t\t\twrapper.className = 'ui-slider-inneroffset';\n\n\t\t\tfor(var j = 0,length = domSlider.childNodes.length;j < length;j++){\n\t\t\t\twrapper.appendChild(domSlider.childNodes[j]);\n\t\t\t}\n\n\t\t\tdomSlider.appendChild(wrapper);\n\n\t\t\t// slider.wrapInner( ""<div class='ui-slider-inneroffset'></div>"" );\n\n\t\t\t// make the handle move with a smooth transition\n\t\t\thandle.addClass( ""ui-slider-handle-snapping"" );\n\n\t\t\toptions = control.find( ""option"" );\n\n\t\t\tfor(var i = 0, optionsCount = options.length; i < optionsCount; i++){\n\t\t\t\tvar side = !i ? ""b"":""a"",\n\t\t\t\t\tsliderTheme = !i ? "" ui-btn-down-"" + trackTheme :( "" "" + $.mobile.activeBtnClass ),\n\t\t\t\t\tsliderLabel = document.createElement('div'),\n\t\t\t\t\tsliderImg = document.createElement('span');\n\n\t\t\t\tsliderImg.className = ['ui-slider-label ui-slider-label-',side,sliderTheme,"" ui-btn-corner-all""].join("""");\n\t\t\t\tsliderImg.setAttribute('role','img');\n\t\t\t\tsliderImg.appendChild(document.createTextNode(options[i].innerHTML));\n\t\t\t\t$(sliderImg).prependTo( slider );\n\t\t\t}\n\n\t\t\tself._labels = $( "".ui-slider-label"", slider );\n\n\t\t}\n\n\t\tlabel.addClass( ""ui-slider"" );\n\n\t\t// monitor the input for updated values\n\t\tcontrol.addClass( cType === ""input"" ? ""ui-slider-input"" : ""ui-slider-switch"" )\n\t\t\t.change( function() {\n\t\t\t\t// if the user dragged the handle, the ""change"" event was triggered from inside refresh(); don't call refresh() again\n\t\t\t\tif (!self.mouseMoved) {\n\t\t\t\t\tself.refresh( val(), true );\n\t\t\t\t}\n\t\t\t})\n\t\t\t.keyup( function() { // necessary?\n\t\t\t\tself.refresh( val(), true, true );\n\t\t\t})\n\t\t\t.blur( function() {\n\t\t\t\tself.refresh( val(), true );\n\t\t\t});\n\n\t\t// prevent screen drag when slider activated\n\t\t$( document ).bind( ""vmousemove"", function( event ) {\n\t\t\tif ( self.dragging ) {\n\t\t\t\t// self.mouseMoved must be updated before refresh() because it will be used in the control ""change"" event\n\t\t\t\tself.mouseMoved = true;\n\n\t\t\t\tif ( cType === ""select"" ) {\n\t\t\t\t\t// make the handle move in sync with the mouse\n\t\t\t\t\thandle.removeClass( ""ui-slider-handle-snapping"" );\n\t\t\t\t}\n\n\t\t\t\tself.refresh( event );\n\n\t\t\t\t// only after refresh() you can calculate self.userModified\n\t\t\t\tself.userModified = self.beforeStart !== control[0].selectedIndex;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\n\t\tslider.bind( ""vmousedown"", function( event ) {\n\t\t\tself.dragging = true;\n\t\t\tself.userModified = false;\n\t\t\tself.mouseMoved = false;\n\n\t\t\tif ( cType === ""select"" ) {\n\t\t\t\tself.beforeStart = control[0].selectedIndex;\n\t\t\t}\n\n\t\t\tself.refresh( event );\n\t\t\treturn false;\n\t\t})\n\t\t.bind( ""vclick"", false );\n\n\t\tslider.add( document )\n\t\t\t.bind( ""vmouseup"", function() {\n\t\t\t\tif ( self.dragging ) {\n\n\t\t\t\t\tself.dragging = false;\n\n\t\t\t\t\tif ( cType === ""select"") {\n\n\t\t\t\t\t\t// make the handle move with a smooth transition\n\t\t\t\t\t\thandle.addClass( ""ui-slider-handle-snapping"" );\n\n\t\t\t\t\t\tif ( self.mouseMoved ) {\n\n\t\t\t\t\t\t\t// this is a drag, change the value only if user dragged enough\n\t\t\t\t\t\t\tif ( self.userModified ) {\n\t\t\t\t\t\t\t\tself.refresh( self.beforeStart == 0 ? 1 : 0 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tself.refresh( self.beforeStart );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// this is just a click, change the value\n\t\t\t\t\t\t\tself.refresh( self.beforeStart == 0 ? 1 : 0 );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tself.mouseMoved = false;\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\n\t\tslider.insertAfter( control );\n\n\t\t// Only add focus class to toggle switch, sliders get it automatically from ui-btn\n\t\tif( cType == 'select' ) {\n\t\t\tthis.handle.bind({\n\t\t\t\tfocus: function() {\n\t\t\t\t\tslider.addClass( $.mobile.focusClass );\n\t\t\t\t},\n\n\t\t\t\tblur: function() {\n\t\t\t\t\tslider.removeClass( $.mobile.focusClass );\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.handle.bind({\n\t\t\t// NOTE force focus on handle\n\t\t\tvmousedown: function() {\n\t\t\t\t$( this ).focus();\n\t\t\t},\n\n\t\t\tvclick: false,\n\n\t\t\tkeydown: function( event ) {\n\t\t\t\tvar index = val();\n\n\t\t\t\tif ( self.options.disabled ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// In all cases prevent the default and mark the handle as active\n\t\t\t\tswitch ( event.keyCode ) {\n\t\t\t\t\tcase $.mobile.keyCode.HOME:\n\t\t\t\t\tcase $.mobile.keyCode.END:\n\t\t\t\t\tcase $.mobile.keyCode.PAGE_UP:\n\t\t\t\t\tcase $.mobile.keyCode.PAGE_DOWN:\n\t\t\t\t\tcase $.mobile.keyCode.UP:\n\t\t\t\t\tcase $.mobile.keyCode.RIGHT:\n\t\t\t\t\tcase $.mobile.keyCode.DOWN:\n\t\t\t\t\tcase $.mobile.keyCode.LEFT:\n\t\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t\t\tif ( !self._keySliding ) {\n\t\t\t\t\t\t\tself._keySliding = true;\n\t\t\t\t\t\t\t$( this ).addClass( ""ui-state-active"" );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// move the slider according to the keypress\n\t\t\t\tswitch ( event.keyCode ) {\n\t\t\t\t\tcase $.mobile.keyCode.HOME:\n\t\t\t\t\t\tself.refresh( min );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase $.mobile.keyCode.END:\n\t\t\t\t\t\tself.refresh( max );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase $.mobile.keyCode.PAGE_UP:\n\t\t\t\t\tcase $.mobile.keyCode.UP:\n\t\t\t\t\tcase $.mobile.keyCode.RIGHT:\n\t\t\t\t\t\tself.refresh( index + step );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase $.mobile.keyCode.PAGE_DOWN:\n\t\t\t\t\tcase $.mobile.keyCode.DOWN:\n\t\t\t\t\tcase $.mobile.keyCode.LEFT:\n\t\t\t\t\t\tself.refresh( index - step );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}, // remove active mark\n\n\t\t\tkeyup: function( event ) {\n\t\t\t\tif ( self._keySliding ) {\n\t\t\t\t\tself._keySliding = false;\n\t\t\t\t\t$( this ).removeClass( ""ui-state-active"" );\n\t\t\t\t}\n\t\t\t}\n\t\t\t});\n\n\t\tthis.refresh(undefined, undefined, true);\n\t},\n\n\trefresh: function( val, isfromControl, preventInputUpdate ) {\n\n\t\tif ( this.options.disabled || this.element.attr('disabled')) {\n\t\t\tthis.disable();\n\t\t}\n\n\t\tvar control = this.element, percent,\n\t\t\tcType = control[0].nodeName.toLowerCase(),\n\t\t\tmin = cType === ""input"" ? parseFloat( control.attr( ""min"" ) ) : 0,\n\t\t\tmax = cType === ""input"" ? parseFloat( control.attr( ""max"" ) ) : control.find( ""option"" ).length - 1,\n\t\t\tstep = (cType === ""input"" && parseFloat( control.attr( ""step"" ) ) > 0) ? parseFloat(control.attr(""step"")) : 1;\n\n\t\tif ( typeof val === ""object"" ) {\n\t\t\tvar data = val,\n\t\t\t\t// a slight tolerance helped get to the ends of the slider\n\t\t\t\ttol = 8;\n\t\t\tif ( !this.dragging ||\n\t\t\t\t\tdata.pageX < this.slider.offset().left - tol ||\n\t\t\t\t\tdata.pageX > this.slider.offset().left + this.slider.width() + tol ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpercent = Math.round( ( ( data.pageX - this.slider.offset().left ) / this.slider.width() ) * 100 );\n\t\t} else {\n\t\t\tif ( val == null ) {\n\t\t\t\tval = cType === ""input"" ? parseFloat( control.val() || 0 ) : control[0].selectedIndex;\n\t\t\t}\n\t\t\tpercent = ( parseFloat( val ) - min ) / ( max - min ) * 100;\n\t\t}\n\n\t\tif ( isNaN( percent ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( percent < 0 ) {\n\t\t\tpercent = 0;\n\t\t}\n\n\t\tif ( percent > 100 ) {\n\t\t\tpercent = 100;\n\t\t}\n\n\t\tvar newval = ( percent / 100 ) * ( max - min ) + min;\n\n\t\t//from jQuery UI slider, the following source will round to the nearest step\n\t\tvar valModStep = ( newval - min ) % step;\n\t\tvar alignValue = newval - valModStep;\n\n\t\tif ( Math.abs( valModStep ) * 2 >= step ) {\n\t\t\talignValue += ( valModStep > 0 ) ? step : ( -step );\n\t\t}\n\t\t// Since JavaScript has problems with large floats, round\n\t\t// the final value to 5 digits after the decimal point (see jQueryUI: #4124)\n\t\tnewval = parseFloat( alignValue.toFixed(5) );\n\n\t\tif ( newval < min ) {\n\t\t\tnewval = min;\n\t\t}\n\n\t\tif ( newval > max ) {\n\t\t\tnewval = max;\n\t\t}\n\n\t\tthis.handle.css( ""left"", percent + ""%"" );\n\t\tthis.handle.attr( {\n\t\t\t\t""aria-valuenow"": cType === ""input"" ? newval : control.find( ""option"" ).eq( newval ).attr( ""value"" ),\n\t\t\t\t""aria-valuetext"": cType === ""input"" ? newval : control.find( ""option"" ).eq( newval ).getEncodedText(),\n\t\t\t\ttitle: cType === ""input"" ? newval : control.find( ""option"" ).eq( newval ).getEncodedText()\n\t\t\t});\n\t\tthis.valuebg && this.valuebg.css( ""width"", percent + ""%"" );\n\n\t\t// drag the label widths\n\t\tif ( this._labels ) {\n\t\t\tvar handlePercent = this.handle.width() / this.slider.width() * 100,\n\t\t\t\taPercent = percent && handlePercent + ( 100 - handlePercent ) * percent / 100,\n\t\t\t\tbPercent = percent === 100 ? 0 : Math.min( handlePercent + 100 - aPercent, 100 );\n\n\t\t\tthis._labels.each(function(){\n\t\t\t\tvar ab = $(this).is( "".ui-slider-label-a"" );\n\t\t\t\t$( this ).width( ( ab ? aPercent : bPercent  ) + ""%"" );\n\t\t\t});\n\t\t}\n\n\t\tif ( !preventInputUpdate ) {\n\t\t\tvar valueChanged = false;\n\n\t\t\t// update control""s value\n\t\t\tif ( cType === ""input"" ) {\n\t\t\t\tvalueChanged = control.val() !== newval;\n\t\t\t\tcontrol.val( newval );\n\t\t\t} else {\n\t\t\t\tvalueChanged = control[ 0 ].selectedIndex !== newval;\n\t\t\t\tcontrol[ 0 ].selectedIndex = newval;\n\t\t\t}\n\t\t\tif ( !isfromControl && valueChanged ) {\n\t\t\t\tcontrol.trigger( ""change"" );\n\t\t\t}\n\t\t}\n\t},\n\n\tenable: function() {\n\t\tthis.element.attr( ""disabled"", false );\n\t\tthis.slider.removeClass( ""ui-disabled"" ).attr( ""aria-disabled"", false );\n\t\treturn this._setOption( ""disabled"", false );\n\t},\n\n\tdisable: function() {\n\t\tthis.element.attr( ""disabled"", true );\n\t\tthis.slider.addClass( ""ui-disabled"" ).attr( ""aria-disabled"", true );\n\t\treturn this._setOption( ""disabled"", true );\n\t}\n\n});\n\n//auto self-init widgets\n$( document ).bind( ""pagecreate create"", function( e ){\n\t$.mobile.slider.prototype.enhanceWithin( e.target, true );\n});\n\n})( jQuery );\n\n(function( $, undefined ) {\n\n$.widget( ""mobile.selectmenu"", $.mobile.widget, {\n\toptions: {\n\t\ttheme: null,\n\t\tdisabled: false,\n\t\ticon: ""arrow-d"",\n\t\ticonpos: ""right"",\n\t\tinline: false,\n\t\tcorners: true,\n\t\tshadow: true,\n\t\ticonshadow: true,\n\t\toverlayTheme: ""a"",\n\t\thidePlaceholderMenuItems: true,\n\t\tcloseText: ""Close"",\n\t\tnativeMenu: true,\n\t\t// This option defaults to true on iOS devices.\n\t\tpreventFocusZoom: /iPhone|iPad|iPod/.test( navigator.platform ) && navigator.userAgent.indexOf( ""AppleWebKit"" ) > -1,\n\t\tinitSelector: ""select:not(:jqmData(role='slider'))"",\n\t\tmini: false\n\t},\n\n\t_button: function(){\n\t\treturn $( ""<div/>"" );\n\t},\n\n\t_setDisabled: function( value ) {\n\t\tthis.element.attr( ""disabled"", value );\n\t\tthis.button.attr( ""aria-disabled"", value );\n\t\treturn this._setOption( ""disabled"", value );\n\t},\n\n\t_focusButton : function() {\n\t\tvar self = this;\n\n\t\tsetTimeout( function() {\n\t\t\tself.button.focus();\n\t\t}, 40);\n\t},\n\n  _selectOptions: function() {\n    return this.select.find( ""option"" );\n  },\n\n\t// setup items that are generally necessary for select menu extension\n\t_preExtension: function(){\n\t\tvar classes = """";\n\t\t// TODO: Post 1.1--once we have time to test thoroughly--any classes manually applied to the original element should be carried over to the enhanced element, with an `-enhanced` suffix. See https://github.com/jquery/jquery-mobile/issues/3577\n\t\t/* if( $el[0].className.length ) {\n\t\t\tclasses = $el[0].className;\n\t\t} */\n\t\tif( !!~this.element[0].className.indexOf( ""ui-btn-left"" ) ) {\n\t\t\tclasses =  "" ui-btn-left"";\n\t\t}\n\t\t\n\t\tif(  !!~this.element[0].className.indexOf( ""ui-btn-right"" ) ) {\n\t\t\tclasses = "" ui-btn-right"";\n\t\t}\n\t\t\n\t\tthis.select = this.element.wrap( ""<div class='ui-select"" + classes + ""'>"" );\n\t\tthis.selectID  = this.select.attr( ""id"" );\n\t\tthis.label = $( ""label[for='""+ this.selectID +""']"" ).addClass( ""ui-select"" );\n\t\tthis.isMultiple = this.select[ 0 ].multiple;\n\t\tif ( !this.options.theme ) {\n\t\t\tthis.options.theme = $.mobile.getInheritedTheme( this.select, ""c"" );\n\t\t}\n\t},\n\n\t_create: function() {\n\t\tthis._preExtension();\n\n \t\t// Allows for extension of the native select for custom selects and other plugins\n\t\t// see select.custom for example extension\n\t\t// TODO explore plugin registration\n\t\tthis._trigger( ""beforeCreate"" );\n\n\t\tthis.button = this._button();\n\n\t\tvar self = this,\n\n\t\t\toptions = this.options,\n\n\t\t\t// IE throws an exception at options.item() function when\n\t\t\t// there is no selected item\n\t\t\t// select first in this case\n\t\t\tselectedIndex = this.select[ 0 ].selectedIndex == -1 ? 0 : this.select[ 0 ].selectedIndex,\n\n\t\t\t// TODO values buttonId and menuId are undefined here\n\t\t\tbutton = this.button\n\t\t\t\t.text( $( this.select[ 0 ].options.item( selectedIndex ) ).text() )\n\t\t\t\t.insertBefore( this.select )\n\t\t\t\t.buttonMarkup( {\n\t\t\t\t\ttheme: options.theme,\n\t\t\t\t\ticon: options.icon,\n\t\t\t\t\ticonpos: options.iconpos,\n\t\t\t\t\tinline: options.inline,\n\t\t\t\t\tcorners: options.corners,\n\t\t\t\t\tshadow: options.shadow,\n\t\t\t\t\ticonshadow: options.iconshadow,\n\t\t\t\t\tmini: options.mini\n\t\t\t\t});\n\n\t\t// Opera does not properly support opacity on select elements\n\t\t// In Mini, it hides the element, but not its text\n\t\t// On the desktop,it seems to do the opposite\n\t\t// for these reasons, using the nativeMenu option results in a full native select in Opera\n\t\tif ( options.nativeMenu && window.opera && window.opera.version ) {\n\t\t\tthis.select.addClass( ""ui-select-nativeonly"" );\n\t\t}\n\n\t\t// Add counter for multi selects\n\t\tif ( this.isMultiple ) {\n\t\t\tthis.buttonCount = $( ""<span>"" )\n\t\t\t\t.addClass( ""ui-li-count ui-btn-up-c ui-btn-corner-all"" )\n\t\t\t\t.hide()\n\t\t\t\t.appendTo( button.addClass('ui-li-has-count') );\n\t\t}\n\n\t\t// Disable if specified\n\t\tif ( options.disabled || this.element.attr('disabled')) {\n\t\t\tthis.disable();\n\t\t}\n\n\t\t// Events on native select\n\t\tthis.select.change( function() {\n\t\t\tself.refresh();\n\t\t});\n\n\t\tthis.build();\n\t},\n\n\tbuild: function() {\n\t\tvar self = this;\n\n\t\tthis.select\n\t\t\t.appendTo( self.button )\n\t\t\t.bind( ""vmousedown"", function() {\n\t\t\t\t// Add active class to button\n\t\t\t\tself.button.addClass( $.mobile.activeBtnClass );\n\t\t\t})\n            .bind( ""focus"", function() {\n                self.button.addClass( $.mobile.focusClass );\n            })\n            .bind( ""blur"", function() {\n                self.button.removeClass( $.mobile.focusClass );\n            })\n\t\t\t.bind( ""focus vmouseover"", function() {\n\t\t\t\tself.button.trigger( ""vmouseover"" );\n\t\t\t})\n\t\t\t.bind( ""vmousemove"", function() {\n\t\t\t\t// Remove active class on scroll/touchmove\n\t\t\t\tself.button.removeClass( $.mobile.activeBtnClass );\n\t\t\t})\n\t\t\t.bind( ""change blur vmouseout"", function() {\n\t\t\t\tself.button.trigger( ""vmouseout"" )\n\t\t\t\t\t.removeClass( $.mobile.activeBtnClass );\n\t\t\t})\n\t\t\t.bind( ""change blur"", function() {\n\t\t\t\tself.button.removeClass( ""ui-btn-down-"" + self.options.theme );\n\t\t\t});\n\n\t\t// In many situations, iOS will zoom into the select upon tap, this prevents that from happening\n\t\tself.button.bind( ""vmousedown"", function() {\n\t\t\tif( self.options.preventFocusZoom ){\n\t\t\t\t$.mobile.zoom.disable( true );\n\t\t\t}\n\t\t})\n\t\t.bind( ""mouseup"", function() {\n\t\t\tif( self.options.preventFocusZoom ){\n\t\t\t\t$.mobile.zoom.enable( true );\n\t\t\t}\n\t\t});\n\t},\n\n\tselected: function() {\n\t\treturn this._selectOptions().filter( "":selected"" );\n\t},\n\n\tselectedIndices: function() {\n\t\tvar self = this;\n\n\t\treturn this.selected().map( function() {\n\t\t\treturn self._selectOptions().index( this );\n\t\t}).get();\n\t},\n\n\tsetButtonText: function() {\n\t\tvar self = this, selected = this.selected();\n\n\t\tthis.button.find( "".ui-btn-text"" ).text( function() {\n\t\t\tif ( !self.isMultiple ) {\n\t\t\t\treturn selected.text();\n\t\t\t}\n\n\t\t\treturn selected.length ? selected.map( function() {\n\t\t\t\treturn $( this ).text();\n\t\t\t}).get().join( "", "" ) : self.placeholder;\n\t\t});\n\t},\n\n\tsetButtonCount: function() {\n\t\tvar selected = this.selected();\n\n\t\t// multiple count inside button\n\t\tif ( this.isMultiple ) {\n\t\t\tthis.buttonCount[ selected.length > 1 ? ""show"" : ""hide"" ]().text( selected.length );\n\t\t}\n\t},\n\n\trefresh: function() {\n\t\tthis.setButtonText();\n\t\tthis.setButtonCount();\n\t},\n\n\t// open and close preserved in native selects\n\t// to simplify users code when looping over selects\n\topen: $.noop,\n\tclose: $.noop,\n\n\tdisable: function() {\n\t\tthis._setDisabled( true );\n\t\tthis.button.addClass( ""ui-disabled"" );\n\t},\n\n\tenable: function() {\n\t\tthis._setDisabled( false );\n\t\tthis.button.removeClass( ""ui-disabled"" );\n\t}\n});\n\n//auto self-init widgets\n$( document ).bind( ""pagecreate create"", function( e ){\n\t$.mobile.selectmenu.prototype.enhanceWithin( e.target, true );\n});\n})( jQuery );\n\n/*\n* custom ""selectmenu"" plugin\n*/\n\n(function( $, undefined ) {\n\tvar extendSelect = function( widget ){\n\n\t\tvar select = widget.select,\n\t\t\tselectID  = widget.selectID,\n\t\t\tlabel = widget.label,\n\t\t\tthisPage = widget.select.closest( "".ui-page"" ),\n\t\t\tscreen = $( ""<div>"", {""class"": ""ui-selectmenu-screen ui-screen-hidden""} ).appendTo( thisPage ),\n\t\t\tselectOptions = widget._selectOptions(),\n\t\t\tisMultiple = widget.isMultiple = widget.select[ 0 ].multiple,\n\t\t\tbuttonId = selectID + ""-button"",\n\t\t\tmenuId = selectID + ""-menu"",\n\t\t\tmenuPage = $( ""<div data-"" + $.mobile.ns + ""role='dialog' data-"" +$.mobile.ns + ""theme='""+ widget.options.theme +""' data-"" +$.mobile.ns + ""overlay-theme='""+ widget.options.overlayTheme +""'>"" +\n\t\t\t\t""<div data-"" + $.mobile.ns + ""role='header'>"" +\n\t\t\t\t""<div class='ui-title'>"" + label.getEncodedText() + ""</div>""+\n\t\t\t\t""</div>""+\n\t\t\t\t""<div data-"" + $.mobile.ns + ""role='content'></div>""+\n\t\t\t\t""</div>"" ),\n\n\t\t\tlistbox =  $(""<div>"", { ""class"": ""ui-selectmenu ui-selectmenu-hidden ui-overlay-shadow ui-corner-all ui-body-"" + widget.options.overlayTheme + "" "" + $.mobile.defaultDialogTransition } ).insertAfter(screen),\n\n\t\t\tlist = $( ""<ul>"", {\n\t\t\t\t""class"": ""ui-selectmenu-list"",\n\t\t\t\t""id"": menuId,\n\t\t\t\t""role"": ""listbox"",\n\t\t\t\t""aria-labelledby"": buttonId\n\t\t\t}).attr( ""data-"" + $.mobile.ns + ""theme"", widget.options.theme ).appendTo( listbox ),\n\n\t\t\theader = $( ""<div>"", {\n\t\t\t\t""class"": ""ui-header ui-bar-"" + widget.options.theme\n\t\t\t}).prependTo( listbox ),\n\n\t\t\theaderTitle = $( ""<h1>"", {\n\t\t\t\t""class"": ""ui-title""\n\t\t\t}).appendTo( header ),\n\n\t\t\tmenuPageContent,\n\t\t\tmenuPageClose,\n\t\t\theaderClose;\n\n\t\tif( widget.isMultiple ) {\n\t\t\theaderClose = $( ""<a>"", {\n\t\t\t\t""text"": widget.options.closeText,\n\t\t\t\t""href"": ""#"",\n\t\t\t\t""class"": ""ui-btn-left""\n\t\t\t}).attr( ""data-"" + $.mobile.ns + ""iconpos"", ""notext"" ).attr( ""data-"" + $.mobile.ns + ""icon"", ""delete"" ).appendTo( header ).buttonMarkup();\n\t\t}\n\n\t\t$.extend( widget, {\n\t\t\tselect: widget.select,\n\t\t\tselectID: selectID,\n\t\t\tbuttonId: buttonId,\n\t\t\tmenuId: menuId,\n\t\t\tthisPage: thisPage,\n\t\t\tmenuPage: menuPage,\n\t\t\tlabel: label,\n\t\t\tscreen: screen,\n\t\t\tselectOptions: selectOptions,\n\t\t\tisMultiple: isMultiple,\n\t\t\ttheme: widget.options.theme,\n\t\t\tlistbox: listbox,\n\t\t\tlist: list,\n\t\t\theader: header,\n\t\t\theaderTitle: headerTitle,\n\t\t\theaderClose: headerClose,\n\t\t\tmenuPageContent: menuPageContent,\n\t\t\tmenuPageClose: menuPageClose,\n\t\t\tplaceholder: """",\n\n\t\t\tbuild: function() {\n\t\t\t\tvar self = this;\n\n\t\t\t\t// Create list from select, update state\n\t\t\t\tself.refresh();\n\n\t\t\t\tself.select.attr( ""tabindex"", ""-1"" ).focus(function() {\n\t\t\t\t\t$( this ).blur();\n\t\t\t\t\tself.button.focus();\n\t\t\t\t});\n\n\t\t\t\t// Button events\n\t\t\t\tself.button.bind( ""vclick keydown"" , function( event ) {\n\t\t\t\t\tif ( event.type == ""vclick"" ||\n\t\t\t\t\t\t\t event.keyCode && ( event.keyCode === $.mobile.keyCode.ENTER ||\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tevent.keyCode === $.mobile.keyCode.SPACE ) ) {\n\n\t\t\t\t\t\tself.open();\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Events for list items\n\t\t\t\tself.list.attr( ""role"", ""listbox"" )\n\t\t\t\t\t.bind( ""focusin"", function( e ){\n\t\t\t\t\t\t$( e.target )\n\t\t\t\t\t\t\t.attr( ""tabindex"", ""0"" )\n\t\t\t\t\t\t\t.trigger( ""vmouseover"" );\n\n\t\t\t\t\t})\n\t\t\t\t\t.bind( ""focusout"", function( e ){\n\t\t\t\t\t\t$( e.target )\n\t\t\t\t\t\t\t.attr( ""tabindex"", ""-1"" )\n\t\t\t\t\t\t\t.trigger( ""vmouseout"" );\n\t\t\t\t\t})\n\t\t\t\t\t.delegate( ""li:not(.ui-disabled, .ui-li-divider)"", ""click"", function( event ) {\n\n\t\t\t\t\t\t// index of option tag to be selected\n\t\t\t\t\t\tvar oldIndex = self.select[ 0 ].selectedIndex,\n\t\t\t\t\t\t\tnewIndex = self.list.find( ""li:not(.ui-li-divider)"" ).index( this ),\n\t\t\t\t\t\t\toption = self._selectOptions().eq( newIndex )[ 0 ];\n\n\t\t\t\t\t\t// toggle selected status on the tag for multi selects\n\t\t\t\t\t\toption.selected = self.isMultiple ? !option.selected : true;\n\n\t\t\t\t\t\t// toggle checkbox class for multiple selects\n\t\t\t\t\t\tif ( self.isMultiple ) {\n\t\t\t\t\t\t\t$( this ).find( "".ui-icon"" )\n\t\t\t\t\t\t\t\t.toggleClass( ""ui-icon-checkbox-on"", option.selected )\n\t\t\t\t\t\t\t\t.toggleClass( ""ui-icon-checkbox-off"", !option.selected );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// trigger change if value changed\n\t\t\t\t\t\tif ( self.isMultiple || oldIndex !== newIndex ) {\n\t\t\t\t\t\t\tself.select.trigger( ""change"" );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//hide custom select for single selects only\n\t\t\t\t\t\tif ( !self.isMultiple ) {\n\t\t\t\t\t\t\tself.close();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t})\n\t\t\t\t\t.keydown(function( event ) {  //keyboard events for menu items\n\t\t\t\t\t\tvar target = $( event.target ),\n\t\t\t\t\t\t\tli = target.closest( ""li"" ),\n\t\t\t\t\t\t\tprev, next;\n\n\t\t\t\t\t\t// switch logic based on which key was pressed\n\t\t\t\t\t\tswitch ( event.keyCode ) {\n\t\t\t\t\t\t\t// up or left arrow keys\n\t\t\t\t\t\t case 38:\n\t\t\t\t\t\t\tprev = li.prev().not( "".ui-selectmenu-placeholder"" );\n\n\t\t\t\t\t\t\tif( prev.is( "".ui-li-divider"" ) ) {\n\t\t\t\t\t\t\t\tprev = prev.prev();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// if there's a previous option, focus it\n\t\t\t\t\t\t\tif ( prev.length ) {\n\t\t\t\t\t\t\t\ttarget\n\t\t\t\t\t\t\t\t\t.blur()\n\t\t\t\t\t\t\t\t\t.attr( ""tabindex"", ""-1"" );\n\n\t\t\t\t\t\t\t\tprev.addClass( ""ui-btn-down-"" + widget.options.theme ).find( ""a"" ).first().focus();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t// down or right arrow keys\n\t\t\t\t\t\t case 40:\n\t\t\t\t\t\t\tnext = li.next();\n\n\t\t\t\t\t\t\tif( next.is( "".ui-li-divider"" ) ) {\n\t\t\t\t\t\t\t\tnext = next.next();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// if there's a next option, focus it\n\t\t\t\t\t\t\tif ( next.length ) {\n\t\t\t\t\t\t\t\ttarget\n\t\t\t\t\t\t\t\t\t.blur()\n\t\t\t\t\t\t\t\t\t.attr( ""tabindex"", ""-1"" );\n\n\t\t\t\t\t\t\t\tnext.addClass( ""ui-btn-down-"" + widget.options.theme ).find( ""a"" ).first().focus();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t// If enter or space is pressed, trigger click\n\t\t\t\t\t\t case 13:\n\t\t\t\t\t\t case 32:\n\t\t\t\t\t\t\ttarget.trigger( ""click"" );\n\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t// button refocus ensures proper height calculation\n\t\t\t\t// by removing the inline style and ensuring page inclusion\n\t\t\t\tself.menuPage.bind( ""pagehide"", function() {\n\t\t\t\t\tself.list.appendTo( self.listbox );\n\t\t\t\t\tself._focusButton();\n\n\t\t\t\t\t// TODO centralize page removal binding / handling in the page plugin.\n\t\t\t\t\t// Suggestion from @jblas to do refcounting\n\t\t\t\t\t//\n\t\t\t\t\t// TODO extremely confusing dependency on the open method where the pagehide.remove\n\t\t\t\t\t// bindings are stripped to prevent the parent page from disappearing. The way\n\t\t\t\t\t// we're keeping pages in the DOM right now sucks\n\t\t\t\t\t//\n\t\t\t\t\t// rebind the page remove that was unbound in the open function\n\t\t\t\t\t// to allow for the parent page removal from actions other than the use\n\t\t\t\t\t// of a dialog sized custom select\n\t\t\t\t\t//\n\t\t\t\t\t// doing this here provides for the back button on the custom select dialog\n\t\t\t\t\t$.mobile._bindPageRemove.call( self.thisPage );\n\t\t\t\t});\n\n\t\t\t\t// Events on ""screen"" overlay\n\t\t\t\tself.screen.bind( ""vclick"", function( event ) {\n\t\t\t\t\tself.close();\n\t\t\t\t});\n\n\t\t\t\t// Close button on small overlays\n\t\t\t\tif( self.isMultiple ){\n\t\t\t\t\tself.headerClose.click( function() {\n\t\t\t\t\t\tif ( self.menuType == ""overlay"" ) {\n\t\t\t\t\t\t\tself.close();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// track this dependency so that when the parent page\n\t\t\t\t// is removed on pagehide it will also remove the menupage\n\t\t\t\tself.thisPage.addDependents( this.menuPage );\n\t\t\t},\n\n\t\t\t_isRebuildRequired: function() {\n\t\t\t\tvar list = this.list.find( ""li"" ),\n\t\t\t\t\toptions = this._selectOptions();\n\n\t\t\t\t// TODO exceedingly naive method to determine difference\n\t\t\t\t// ignores value changes etc in favor of a forcedRebuild\n\t\t\t\t// from the user in the refresh method\n\t\t\t\treturn options.text() !== list.text();\n\t\t\t},\n\n\t\t\trefresh: function( forceRebuild , foo ){\n\t\t\t\tvar self = this,\n\t\t\t\tselect = this.element,\n\t\t\t\tisMultiple = this.isMultiple,\n\t\t\t\toptions = this._selectOptions(),\n\t\t\t\tselected = this.selected(),\n\t\t\t\t// return an array of all selected index's\n\t\t\t\tindicies = this.selectedIndices();\n\n\t\t\t\tif (  forceRebuild || this._isRebuildRequired() ) {\n\t\t\t\t\tself._buildList();\n\t\t\t\t}\n\n\t\t\t\tself.setButtonText();\n\t\t\t\tself.setButtonCount();\n\n\t\t\t\tself.list.find( ""li:not(.ui-li-divider)"" )\n\t\t\t\t\t.removeClass( $.mobile.activeBtnClass )\n\t\t\t\t\t.attr( ""aria-selected"", false )\n\t\t\t\t\t.each(function( i ) {\n\n\t\t\t\t\t\tif ( $.inArray( i, indicies ) > -1 ) {\n\t\t\t\t\t\t\tvar item = $( this );\n\n\t\t\t\t\t\t\t// Aria selected attr\n\t\t\t\t\t\t\titem.attr( ""aria-selected"", true );\n\n\t\t\t\t\t\t\t// Multiple selects: add the ""on"" checkbox state to the icon\n\t\t\t\t\t\t\tif ( self.isMultiple ) {\n\t\t\t\t\t\t\t\titem.find( "".ui-icon"" ).removeClass( ""ui-icon-checkbox-off"" ).addClass( ""ui-icon-checkbox-on"" );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif( item.is( "".ui-selectmenu-placeholder"" ) ) {\n\t\t\t\t\t\t\t\t\titem.next().addClass( $.mobile.activeBtnClass );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\titem.addClass( $.mobile.activeBtnClass );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t},\n\n\t\t\tclose: function() {\n\t\t\t\tif ( this.options.disabled || !this.isOpen ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar self = this;\n\n\t\t\t\tif ( self.menuType == ""page"" ) {\n\t\t\t\t\t// doesn't solve the possible issue with calling change page\n\t\t\t\t\t// where the objects don't define data urls which prevents dialog key\n\t\t\t\t\t// stripping - changePage has incoming refactor\n\t\t\t\t\twindow.history.back();\n\t\t\t\t} else {\n\t\t\t\t\tself.screen.addClass( ""ui-screen-hidden"" );\n\t\t\t\t\tself.listbox.addClass( ""ui-selectmenu-hidden"" ).removeAttr( ""style"" ).removeClass( ""in"" );\n\t\t\t\t\tself.list.appendTo( self.listbox );\n\t\t\t\t\tself._focusButton();\n\t\t\t\t}\n\n\t\t\t\t// allow the dialog to be closed again\n\t\t\t\tself.isOpen = false;\n\t\t\t},\n\n\t\t\topen: function() {\n\t\t\t\tif ( this.options.disabled ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar self = this,\n          $window = $( window ),\n          selfListParent = self.list.parent(),\n\t\t\t\t\tmenuHeight = selfListParent.outerHeight(),\n\t\t\t\t\tmenuWidth = selfListParent.outerWidth(),\n\t\t\t\t\tactivePage = $( "".ui-page-active"" ),\n\t\t\t\t\ttScrollElem = activePage,\n\t\t\t\t\tscrollTop = $window.scrollTop(),\n\t\t\t\t\tbtnOffset = self.button.offset().top,\n\t\t\t\t\tscreenHeight = $window.height(),\n\t\t\t\t\tscreenWidth = $window.width();\n\n\t\t\t\t//add active class to button\n\t\t\t\tself.button.addClass( $.mobile.activeBtnClass );\n\n\t\t\t\t//remove after delay\n\t\t\t\tsetTimeout( function() {\n\t\t\t\t\tself.button.removeClass( $.mobile.activeBtnClass );\n\t\t\t\t}, 300);\n\n\t\t\t\tfunction focusMenuItem() {\n\t\t\t\t\tself.list.find( ""."" + $.mobile.activeBtnClass + "" a"" ).focus();\n\t\t\t\t}\n\n\t\t\t\tif ( menuHeight > screenHeight - 80 || !$.support.scrollTop ) {\n\n\t\t\t\t\tself.menuPage.appendTo( $.mobile.pageContainer ).page();\n\t\t\t\t\tself.menuPageContent = menuPage.find( "".ui-content"" );\n\t\t\t\t\tself.menuPageClose = menuPage.find( "".ui-header a"" );\n\n\t\t\t\t\t// prevent the parent page from being removed from the DOM,\n\t\t\t\t\t// otherwise the results of selecting a list item in the dialog\n\t\t\t\t\t// fall into a black hole\n\t\t\t\t\tself.thisPage.unbind( ""pagehide.remove"" );\n\n\t\t\t\t\t//for WebOS/Opera Mini (set lastscroll using button offset)\n\t\t\t\t\tif ( scrollTop == 0 && btnOffset > screenHeight ) {\n\t\t\t\t\t\tself.thisPage.one( ""pagehide"", function() {\n\t\t\t\t\t\t\t$( this ).jqmData( ""lastScroll"", btnOffset );\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tself.menuPage.one( ""pageshow"", function() {\n\t\t\t\t\t\tfocusMenuItem();\n\t\t\t\t\t\tself.isOpen = true;\n\t\t\t\t\t});\n\n\t\t\t\t\tself.menuType = ""page"";\n\t\t\t\t\tself.menuPageContent.append( self.list );\n\t\t\t\t\tself.menuPage.find(""div .ui-title"").text(self.label.text());\n\t\t\t\t\t$.mobile.changePage( self.menuPage, {\n\t\t\t\t\t\ttransition: $.mobile.defaultDialogTransition\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tself.menuType = ""overlay"";\n\n\t\t\t\t\tself.screen.height( $(document).height() )\n\t\t\t\t\t\t.removeClass( ""ui-screen-hidden"" );\n\n\t\t\t\t\t// Try and center the overlay over the button\n\t\t\t\t\tvar roomtop = btnOffset - scrollTop,\n\t\t\t\t\t\troombot = scrollTop + screenHeight - btnOffset,\n\t\t\t\t\t\thalfheight = menuHeight / 2,\n\t\t\t\t\t\tmaxwidth = parseFloat( self.list.parent().css( ""max-width"" ) ),\n\t\t\t\t\t\tnewtop, newleft;\n\n\t\t\t\t\tif ( roomtop > menuHeight / 2 && roombot > menuHeight / 2 ) {\n\t\t\t\t\t\tnewtop = btnOffset + ( self.button.outerHeight() / 2 ) - halfheight;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 30px tolerance off the edges\n\t\t\t\t\t\tnewtop = roomtop > roombot ? scrollTop + screenHeight - menuHeight - 30 : scrollTop + 30;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the menuwidth is smaller than the screen center is\n\t\t\t\t\tif ( menuWidth < maxwidth ) {\n\t\t\t\t\t\tnewleft = ( screenWidth - menuWidth ) / 2;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t//otherwise insure a >= 30px offset from the left\n\t\t\t\t\t\tnewleft = self.button.offset().left + self.button.outerWidth() / 2 - menuWidth / 2;\n\n\t\t\t\t\t\t// 30px tolerance off the edges\n\t\t\t\t\t\tif ( newleft < 30 ) {\n\t\t\t\t\t\t\tnewleft = 30;\n\t\t\t\t\t\t} else if ( (newleft + menuWidth) > screenWidth ) {\n\t\t\t\t\t\t\tnewleft = screenWidth - menuWidth - 30;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tself.listbox.append( self.list )\n\t\t\t\t\t\t.removeClass( ""ui-selectmenu-hidden"" )\n\t\t\t\t\t\t.css({\n\t\t\t\t\t\t\ttop: newtop,\n\t\t\t\t\t\t\tleft: newleft\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.addClass( ""in"" );\n\n\t\t\t\t\tfocusMenuItem();\n\n\t\t\t\t\t// duplicate with value set in page show for dialog sized selects\n\t\t\t\t\tself.isOpen = true;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t_buildList: function() {\n\t\t\t\tvar self = this,\n\t\t\t\t\to = this.options,\n\t\t\t\t\tplaceholder = this.placeholder,\n\t\t\t\t\tneedPlaceholder = true,\n\t\t\t\t\toptgroups = [],\n\t\t\t\t\tlis = [],\n\t\t\t\t\tdataIcon = self.isMultiple ? ""checkbox-off"" : ""false"";\n\n\t\t\t\tself.list.empty().filter( "".ui-listview"" ).listview( ""destroy"" );\n\n\t\t\t\tvar $options = self.select.find(""option""),\n\t\t\t\t\tnumOptions = $options.length,\n\t\t\t\t\tselect = this.select[ 0 ],\n\t\t\t\t\tdataPrefix = 'data-' + $.mobile.ns,\n\t\t\t\t\tdataIndexAttr = dataPrefix + 'option-index',\n\t\t\t\t\tdataIconAttr = dataPrefix + 'icon',\n\t\t\t\t\tdataRoleAttr = dataPrefix + 'role',\n\t\t\t\t\tfragment = document.createDocumentFragment(),\n\t\t\t\t\toptGroup;\n\n\t\t\t\tfor (var i = 0; i < numOptions;i++){\n\t\t\t\t\tvar option = $options[i],\n\t\t\t\t\t\t$option = $(option),\n\t\t\t\t\t\tparent = option.parentNode,\n\t\t\t\t\t\ttext = $option.text(),\n\t\t\t\t\t\tanchor  = document.createElement('a'),\n\t\t\t\t\t\tclasses = [];\n\n\t\t\t\t\tanchor.setAttribute('href','#');\n\t\t\t\t\tanchor.appendChild(document.createTextNode(text));\n\n\t\t\t\t\t// Are we inside an optgroup?\n\t\t\t\t\tif (parent !== select && parent.nodeName.toLowerCase() === ""optgroup""){\n\t\t\t\t\t\tvar optLabel = parent.getAttribute('label');\n\t\t\t\t\t\tif ( optLabel != optGroup) {\n\t\t\t\t\t\t\tvar divider = document.createElement('li');\n\t\t\t\t\t\t\tdivider.setAttribute(dataRoleAttr,'list-divider');\n\t\t\t\t\t\t\tdivider.setAttribute('role','option');\n\t\t\t\t\t\t\tdivider.setAttribute('tabindex','-1');\n\t\t\t\t\t\t\tdivider.appendChild(document.createTextNode(optLabel));\n\t\t\t\t\t\t\tfragment.appendChild(divider);\n\t\t\t\t\t\t\toptGroup = optLabel;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (needPlaceholder && (!option.getAttribute( ""value"" ) || text.length == 0 || $option.jqmData( ""placeholder"" ))) {\n\t\t\t\t\t\tneedPlaceholder = false;\n\t\t\t\t\t\tif ( o.hidePlaceholderMenuItems ) {\n\t\t\t\t\t\t\tclasses.push( ""ui-selectmenu-placeholder"" );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!placeholder) {\n\t\t\t\t\t\t\tplaceholder = self.placeholder = text;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvar item = document.createElement('li');\n\t\t\t\t\tif ( option.disabled ) {\n\t\t\t\t\t\tclasses.push( ""ui-disabled"" );\n\t\t\t\t\t\titem.setAttribute('aria-disabled',true);\n\t\t\t\t\t}\n\t\t\t\t\titem.setAttribute(dataIndexAttr,i);\n\t\t\t\t\titem.setAttribute(dataIconAttr,dataIcon);\n\t\t\t\t\titem.className = classes.join("" "");\n\t\t\t\t\titem.setAttribute('role','option');\n\t\t\t\t\tanchor.setAttribute('tabindex','-1');\n\t\t\t\t\titem.appendChild(anchor);\n\t\t\t\t\tfragment.appendChild(item);\n\t\t\t\t}\n\n\t\t\t\tself.list[0].appendChild(fragment);\n\n\t\t\t\t// Hide header if it's not a multiselect and there's no placeholder\n\t\t\t\tif ( !this.isMultiple && !placeholder.length ) {\n\t\t\t\t\tthis.header.hide();\n\t\t\t\t} else {\n\t\t\t\t\tthis.headerTitle.text( this.placeholder );\n\t\t\t\t}\n\n\t\t\t\t// Now populated, create listview\n\t\t\t\tself.list.listview();\n\t\t\t},\n\n\t\t\t_button: function(){\n\t\t\t\treturn $( ""<a>"", {\n\t\t\t\t\t""href"": ""#"",\n\t\t\t\t\t""role"": ""button"",\n\t\t\t\t\t// TODO value is undefined at creation\n\t\t\t\t\t""id"": this.buttonId,\n\t\t\t\t\t""aria-haspopup"": ""true"",\n\n\t\t\t\t\t// TODO value is undefined at creation\n\t\t\t\t\t""aria-owns"": this.menuId\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n\n\t// issue #3894 - core doesn't triggered events on disabled delegates\n\t$( document ).bind( ""selectmenubeforecreate"", function( event ){\n\t\tvar selectmenuWidget = $( event.target ).data( ""selectmenu"" );\n\n\t\tif( !selectmenuWidget.options.nativeMenu ){\n\t\t\textendSelect( selectmenuWidget );\n\t\t}\n\t});\n})( jQuery );\n\n(function( $, undefined ) {\n\n\n\t$.widget( ""mobile.fixedtoolbar"", $.mobile.widget, {\n\t\toptions: {\n\t\t\tvisibleOnPageShow: true,\n\t\t\tdisablePageZoom: true,\n\t\t\ttransition: ""slide"", //can be none, fade, slide (slide maps to slideup or slidedown)\n\t\t\tfullscreen: false,\n\t\t\ttapToggle: true,\n\t\t\ttapToggleBlacklist: ""a, input, select, textarea, .ui-header-fixed, .ui-footer-fixed"",\n\t\t\thideDuringFocus: ""input, textarea, select"",\n\t\t\tupdatePagePadding: true,\n\t\t\ttrackPersistentToolbars: true,\n\n\t\t\t// Browser detection! Weeee, here we go...\n\t\t\t// Unfortunately, position:fixed is costly, not to mention probably impossible, to feature-detect accurately.\n\t\t\t// Some tests exist, but they currently return false results in critical devices and browsers, which could lead to a broken experience.\n\t\t\t// Testing fixed positioning is also pretty obtrusive to page load, requiring injected elements and scrolling the window\n\t\t\t// The following function serves to rule out some popular browsers with known fixed-positioning issues\n\t\t\t// This is a plugin option like any other, so feel free to improve or overwrite it\n\t\t\tsupportBlacklist: function(){\n\t\t\t\tvar w = window,\n\t\t\t\t\tua = navigator.userAgent,\n\t\t\t\t\tplatform = navigator.platform,\n\t\t\t\t\t// Rendering engine is Webkit, and capture major version\n\t\t\t\t\twkmatch = ua.match( /AppleWebKit\\/([0-9]+)/ ),\n\t\t\t\t\twkversion = !!wkmatch && wkmatch[ 1 ],\n\t\t\t\t\tffmatch = ua.match( /Fennec\\/([0-9]+)/ ),\n\t\t\t\t\tffversion = !!ffmatch && ffmatch[ 1 ],\n\t\t\t\t\toperammobilematch = ua.match( /Opera Mobi\\/([0-9]+)/ ),\n\t\t\t\t\tomversion = !!operammobilematch && operammobilematch[ 1 ];\n\n\t\t\t\tif(\n\t\t\t\t\t// iOS 4.3 and older : Platform is iPhone/Pad/Touch and Webkit version is less than 534 (ios5)\n\t\t\t\t\t( ( platform.indexOf( ""iPhone"" ) > -1 || platform.indexOf( ""iPad"" ) > -1  || platform.indexOf( ""iPod"" ) > -1 ) && wkversion && wkversion < 534 )\n\t\t\t\t\t||\n\t\t\t\t\t// Opera Mini\n\t\t\t\t\t( w.operamini && ({}).toString.call( w.operamini ) === ""[object OperaMini]"" )\n\t\t\t\t\t||\n\t\t\t\t\t( operammobilematch && omversion < 7458 )\n\t\t\t\t\t||\n\t\t\t\t\t//Android lte 2.1: Platform is Android and Webkit version is less than 533 (Android 2.2)\n\t\t\t\t\t( ua.indexOf( ""Android"" ) > -1 && wkversion && wkversion < 533 )\n\t\t\t\t\t||\n\t\t\t\t\t// Firefox Mobile before 6.0 -\n\t\t\t\t\t( ffversion && ffversion < 6 )\n\t\t\t\t\t||\n\t\t\t\t\t// WebOS less than 3\n\t\t\t\t\t( ""palmGetResource"" in window && wkversion && wkversion < 534 )\n\t\t\t\t\t||\n\t\t\t\t\t// MeeGo\n\t\t\t\t\t( ua.indexOf( ""MeeGo"" ) > -1 && ua.indexOf( ""NokiaBrowser/8.5.0"" ) > -1 )\n\t\t\t\t){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tinitSelector: "":jqmData(position='fixed')""\n\t\t},\n\n\t\t_create: function() {\n\n\t\t\tvar self = this,\n\t\t\t\to = self.options,\n\t\t\t\t$el = self.element,\n\t\t\t\ttbtype = $el.is( "":jqmData(role='header')"" ) ? ""header"" : ""footer"",\n\t\t\t\t$page = $el.closest("".ui-page"");\n\n\t\t\t// Feature detecting support for\n\t\t\tif( o.supportBlacklist() ){\n\t\t\t\tself.destroy();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$el.addClass( ""ui-""+ tbtype +""-fixed"" );\n\n\t\t\t// ""fullscreen"" overlay positioning\n\t\t\tif( o.fullscreen ){\n\t\t\t\t$el.addClass( ""ui-""+ tbtype +""-fullscreen"" );\n\t\t\t\t$page.addClass( ""ui-page-"" + tbtype + ""-fullscreen"" );\n\t\t\t}\n\t\t\t// If not fullscreen, add class to page to set top or bottom padding\n\t\t\telse{\n\t\t\t\t$page.addClass( ""ui-page-"" + tbtype + ""-fixed"" );\n\t\t\t}\n\n\t\t\tself._addTransitionClass();\n\t\t\tself._bindPageEvents();\n\t\t\tself._bindToggleHandlers();\n\t\t},\n\n\t\t_addTransitionClass: function(){\n\t\t\tvar tclass = this.options.transition;\n\n\t\t\tif( tclass && tclass !== ""none"" ){\n\t\t\t\t// use appropriate slide for header or footer\n\t\t\t\tif( tclass === ""slide"" ){\n\t\t\t\t\ttclass = this.element.is( "".ui-header"" ) ? ""slidedown"" : ""slideup"";\n\t\t\t\t}\n\n\t\t\t\tthis.element.addClass( tclass );\n\t\t\t}\n\t\t},\n\n\t\t_bindPageEvents: function(){\n\t\t\tvar self = this,\n\t\t\t\to = self.options,\n\t\t\t\t$el = self.element;\n\n\t\t\t//page event bindings\n\t\t\t// Fixed toolbars require page zoom to be disabled, otherwise usability issues crop up\n\t\t\t// This method is meant to disable zoom while a fixed-positioned toolbar page is visible\n\t\t\t$el.closest( "".ui-page"" )\n\t\t\t\t.bind( ""pagebeforeshow"", function(){\n\t\t\t\t\tif( o.disablePageZoom ){\n\t\t\t\t\t\t$.mobile.zoom.disable( true );\n\t\t\t\t\t}\n\t\t\t\t\tif( !o.visibleOnPageShow ){\n\t\t\t\t\t\tself.hide( true );\n\t\t\t\t\t}\n\t\t\t\t} )\n\t\t\t\t.bind( ""webkitAnimationStart animationstart updatelayout"", function(){\n\t\t\t\t\tif( o.updatePagePadding ){\n\t\t\t\t\t\tself.updatePagePadding();\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.bind( ""pageshow"", function(){\n\t\t\t\t\tself.updatePagePadding();\n\t\t\t\t\tif( o.updatePagePadding ){\n\t\t\t\t\t\t$( window ).bind( ""throttledresize."" + self.widgetName, function(){\n\t\t\t\t\t\t \tself.updatePagePadding();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.bind( ""pagebeforehide"", function( e, ui ){\n\t\t\t\t\tif( o.disablePageZoom ){\n\t\t\t\t\t\t$.mobile.zoom.enable( true );\n\t\t\t\t\t}\n\t\t\t\t\tif( o.updatePagePadding ){\n\t\t\t\t\t\t$( window ).unbind( ""throttledresize."" + self.widgetName );\n\t\t\t\t\t}\n\n\t\t\t\t\tif( o.trackPersistentToolbars ){\n\t\t\t\t\t\tvar thisFooter = $( "".ui-footer-fixed:jqmData(id)"", this ),\n\t\t\t\t\t\t\tthisHeader = $( "".ui-header-fixed:jqmData(id)"", this ),\n\t\t\t\t\t\t\tnextFooter = thisFooter.length && ui.nextPage && $( "".ui-footer-fixed:jqmData(id='"" + thisFooter.jqmData( ""id"" ) + ""')"", ui.nextPage ),\n\t\t\t\t\t\t\tnextHeader = thisHeader.length && ui.nextPage && $( "".ui-header-fixed:jqmData(id='"" + thisHeader.jqmData( ""id"" ) + ""')"", ui.nextPage );\n\n\t\t\t\t\t\tnextFooter = nextFooter || $();\n\n\t\t\t\t\t\t\tif( nextFooter.length || nextHeader.length ){\n\n\t\t\t\t\t\t\t\tnextFooter.add( nextHeader ).appendTo( $.mobile.pageContainer );\n\n\t\t\t\t\t\t\t\tui.nextPage.one( ""pageshow"", function(){\n\t\t\t\t\t\t\t\t\tnextFooter.add( nextHeader ).appendTo( this );\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t},\n\n\t\t_visible: true,\n\n\t\t// This will set the content element's top or bottom padding equal to the toolbar's height\n\t\tupdatePagePadding: function() {\n\t\t\tvar $el = this.element,\n\t\t\t\theader = $el.is( "".ui-header"" );\n\n\t\t\t// This behavior only applies to ""fixed"", not ""fullscreen""\n\t\t\tif( this.options.fullscreen ){ return; }\n\n\t\t\t$el.closest( "".ui-page"" ).css( ""padding-"" + ( header ? ""top"" : ""bottom"" ), $el.outerHeight() );\n\t\t},\n\t\t\n\t\t_useTransition: function( notransition ){\n\t\t\tvar $win = $( window ),\n\t\t\t\t$el = this.element,\n\t\t\t\tscroll = $win.scrollTop(),\n\t\t\t\telHeight = $el.height(),\n\t\t\t\tpHeight = $el.closest( "".ui-page"" ).height(),\n\t\t\t\tviewportHeight = $.mobile.getScreenHeight(),\n\t\t\t\ttbtype = $el.is( "":jqmData(role='header')"" ) ? ""header"" : ""footer"";\n\t\t\t\t\n\t\t\treturn !notransition &&\n\t\t\t\t( this.options.transition && this.options.transition !== ""none"" &&\n\t\t\t\t(\n\t\t\t\t\t( tbtype === ""header"" && !this.options.fullscreen && scroll > elHeight ) ||\n\t\t\t\t\t( tbtype === ""footer"" && !this.options.fullscreen && scroll + viewportHeight < pHeight - elHeight )\n\t\t\t\t) || this.options.fullscreen\n\t\t\t\t);\n\t\t},\n\n\t\tshow: function( notransition ){\n\t\t\tvar hideClass = ""ui-fixed-hidden"",\n\t\t\t\t$el = this.element;\n\n\t\t\t\tif( this._useTransition( notransition ) ){\n\t\t\t\t$el\n\t\t\t\t\t.removeClass( ""out "" + hideClass )\n\t\t\t\t\t.addClass( ""in"" );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$el.removeClass( hideClass );\n\t\t\t}\n\t\t\tthis._visible = true;\n\t\t},\n\n\t\thide: function( notransition ){\n\t\t\tvar hideClass = ""ui-fixed-hidden"",\n\t\t\t\t$el = this.element,\n\t\t\t\t// if it's a slide transition, our new transitions need the reverse class as well to slide outward\n\t\t\t\toutclass = ""out"" + ( this.options.transition === ""slide"" ? "" reverse"" : """" );\n\n\t\t\tif( this._useTransition( notransition ) ){\n\t\t\t\t$el\n\t\t\t\t\t.addClass( outclass )\n\t\t\t\t\t.removeClass( ""in"" )\n\t\t\t\t\t.animationComplete( function(){\n\t\t\t\t\t\t$el.addClass( hideClass ).removeClass( outclass );\n\t\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$el.addClass( hideClass ).removeClass( outclass );\n\t\t\t}\n\t\t\tthis._visible = false;\n\t\t},\n\n\t\ttoggle: function(){\n\t\t\tthis[ this._visible ? ""hide"" : ""show"" ]();\n\t\t},\n\n\t\t_bindToggleHandlers: function(){\n\t\t\tvar self = this,\n\t\t\t\to = self.options,\n\t\t\t\t$el = self.element;\n\n\t\t\t// tap toggle\n\t\t\t$el.closest( "".ui-page"" )\n\t\t\t\t.bind( ""vclick"", function( e ){\n\t\t\t\t\tif( o.tapToggle && !$( e.target ).closest( o.tapToggleBlacklist ).length ){\n\t\t\t\t\t\tself.toggle();\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.bind( ""focusin focusout"", function( e ){\n\t\t\t\t\tif( screen.width < 500 && $( e.target ).is( o.hideDuringFocus ) && !$( e.target ).closest( "".ui-header-fixed, .ui-footer-fixed"" ).length ){\n\t\t\t\t\t\tself[ ( e.type === ""focusin"" && self._visible ) ? ""hide"" : ""show"" ]();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t},\n\n\t\tdestroy: function(){\n\t\t\tthis.element.removeClass( ""ui-header-fixed ui-footer-fixed ui-header-fullscreen ui-footer-fullscreen in out fade slidedown slideup ui-fixed-hidden"" );\n\t\t\tthis.element.closest( "".ui-page"" ).removeClass( ""ui-page-header-fixed ui-page-footer-fixed ui-page-header-fullscreen ui-page-footer-fullscreen"" );\n\t\t}\n\n\t});\n\n\t//auto self-init widgets\n\t$( document )\n\t\t.bind( ""pagecreate create"", function( e ){\n\t\t\t\n\t\t\t// DEPRECATED in 1.1: support for data-fullscreen=true|false on the page element.\n\t\t\t// This line ensures it still works, but we recommend moving the attribute to the toolbars themselves.\n\t\t\tif( $( e.target ).jqmData( ""fullscreen"" ) ){\n\t\t\t\t$( $.mobile.fixedtoolbar.prototype.options.initSelector, e.target ).not( "":jqmData(fullscreen)"" ).jqmData( ""fullscreen"", true );\n\t\t\t}\n\t\t\t\n\t\t\t$.mobile.fixedtoolbar.prototype.enhanceWithin( e.target );\n\t\t});\n\n})( jQuery );\n\n( function( $, window ) {\n\t\n\t// This fix addresses an iOS bug, so return early if the UA claims it's something else.\n\tif( !(/iPhone|iPad|iPod/.test( navigator.platform ) && navigator.userAgent.indexOf( ""AppleWebKit"" ) > -1 ) ){\n\t\treturn;\n\t}\n\t\n    var zoom = $.mobile.zoom,\n\t\tevt, x, y, z, aig;\n\t\n    function checkTilt( e ){\n\t\tevt = e.originalEvent;\n\t\taig = evt.accelerationIncludingGravity;\n\t\t\n\t\tx = Math.abs( aig.x );\n\t\ty = Math.abs( aig.y );\n\t\tz = Math.abs( aig.z );\n\t\t\t\t\n\t\t// If portrait orientation and in one of the danger zones\n        if( !window.orientation && ( x > 7 || ( ( z > 6 && y < 8 || z < 8 && y > 6 ) && x > 5 ) ) ){\n\t\t\tif( zoom.enabled ){\n\t\t\t\tzoom.disable();\n\t\t\t}        \t\n        }\n\t\telse if( !zoom.enabled ){\n\t\t\tzoom.enable();\n        }\n    }\n\n    $( window )\n\t\t.bind( ""orientationchange.iosorientationfix"", zoom.enable )\n\t\t.bind( ""devicemotion.iosorientationfix"", checkTilt );\n\n}( jQuery, this ));\n\n( function( $, window, undefined ) {\n\tvar\t$html = $( ""html"" ),\n\t\t\t$head = $( ""head"" ),\n\t\t\t$window = $( window );\n\n \t// trigger mobileinit event - useful hook for configuring $.mobile settings before they're used\n\t$( window.document ).trigger( ""mobileinit"" );\n\n\t// support conditions\n\t// if device support condition(s) aren't met, leave things as they are -> a basic, usable experience,\n\t// otherwise, proceed with the enhancements\n\tif ( !$.mobile.gradeA() ) {\n\t\treturn;\n\t}\n\n\t// override ajaxEnabled on platforms that have known conflicts with hash history updates\n\t// or generally work better browsing in regular http for full page refreshes (BB5, Opera Mini)\n\tif ( $.mobile.ajaxBlacklist ) {\n\t\t$.mobile.ajaxEnabled = false;\n\t}\n\n\t// Add mobile, initial load ""rendering"" classes to docEl\n\t$html.addClass( ""ui-mobile ui-mobile-rendering"" );\n\n\t// This is a fallback. If anything goes wrong (JS errors, etc), or events don't fire,\n\t// this ensures the rendering class is removed after 5 seconds, so content is visible and accessible\n\tsetTimeout( hideRenderingClass, 5000 );\n\n\t// loading div which appears during Ajax requests\n\t// will not appear if $.mobile.loadingMessage is false\n\tvar loaderClass = ""ui-loader"",\n\t\t$loader = $( ""<div class='"" + loaderClass + ""'><span class='ui-icon ui-icon-loading'></span><h1></h1></div>"" );\n\n\t// For non-fixed supportin browsers. Position at y center (if scrollTop supported), above the activeBtn (if defined), or just 100px from top\n\tfunction fakeFixLoader(){\n\t\tvar activeBtn = $( ""."" + $.mobile.activeBtnClass ).first();\n\n\t\t$loader\n\t\t\t.css({\n\t\t\t\ttop: $.support.scrollTop && $window.scrollTop() + $window.height() / 2 ||\n\t\t\t\tactiveBtn.length && activeBtn.offset().top || 100\n\t\t\t});\n\t}\n\n\t// check position of loader to see if it appears to be ""fixed"" to center\n\t// if not, use abs positioning\n\tfunction checkLoaderPosition(){\n\t\tvar offset = $loader.offset(),\n\t\t\tscrollTop = $window.scrollTop(),\n\t\t\tscreenHeight = $.mobile.getScreenHeight();\n\n\t\tif( offset.top < scrollTop || (offset.top - scrollTop) > screenHeight ) {\n\t\t\t$loader.addClass( ""ui-loader-fakefix"" );\n\t\t\tfakeFixLoader();\n\t\t\t$window\n\t\t\t\t.unbind( ""scroll"", checkLoaderPosition )\n\t\t\t\t.bind( ""scroll"", fakeFixLoader );\n\t\t}\n\t}\n\n\t//remove initial build class (only present on first pageshow)\n\tfunction hideRenderingClass(){\n\t\t$html.removeClass( ""ui-mobile-rendering"" );\n\t}\n\n\t$.extend($.mobile, {\n\t\t// turn on/off page loading message.\n\t\tshowPageLoadingMsg: function( theme, msgText, textonly ) {\n\t\t\t$html.addClass( ""ui-loading"" );\n\n\t\t\tif ( $.mobile.loadingMessage ) {\n\t\t\t\t// text visibility from argument takes priority\n\t\t\t\tvar textVisible = textonly || $.mobile.loadingMessageTextVisible;\n\n\t\t\t\ttheme = theme || $.mobile.loadingMessageTheme,\n\n\t\t\t\t$loader\n\t\t\t\t\t.attr( ""class"", loaderClass + "" ui-corner-all ui-body-"" + ( theme || ""a"" ) + "" ui-loader-"" + ( textVisible ? ""verbose"" : ""default"" ) + ( textonly ? "" ui-loader-textonly"" : """" ) )\n\t\t\t\t\t.find( ""h1"" )\n\t\t\t\t\t\t.text( msgText || $.mobile.loadingMessage )\n\t\t\t\t\t\t.end()\n\t\t\t\t\t.appendTo( $.mobile.pageContainer );\n\n\t\t\t\tcheckLoaderPosition();\n\t\t\t\t$window.bind( ""scroll"", checkLoaderPosition );\n\t\t\t}\n\t\t},\n\n\t\thidePageLoadingMsg: function() {\n\t\t\t$html.removeClass( ""ui-loading"" );\n\n\t\t\tif( $.mobile.loadingMessage ){\n\t\t\t\t$loader.removeClass( ""ui-loader-fakefix"" );\n\t\t\t}\n\n\t\t\t$( window ).unbind( ""scroll"", fakeFixLoader );\n\t\t\t$( window ).unbind( ""scroll"", checkLoaderPosition );\n\t\t},\n\n\t\t// find and enhance the pages in the dom and transition to the first page.\n\t\tinitializePage: function() {\n\t\t\t// find present pages\n\t\t\tvar $pages = $( "":jqmData(role='page'), :jqmData(role='dialog')"" );\n\n\t\t\t// if no pages are found, create one with body's inner html\n\t\t\tif ( !$pages.length ) {\n\t\t\t\t$pages = $( ""body"" ).wrapInner( ""<div data-"" + $.mobile.ns + ""role='page'></div>"" ).children( 0 );\n\t\t\t}\n\n\t\t\t// add dialogs, set data-url attrs\n\t\t\t$pages.each(function() {\n\t\t\t\tvar $this = $(this);\n\n\t\t\t\t// unless the data url is already set set it to the pathname\n\t\t\t\tif ( !$this.jqmData(""url"") ) {\n\t\t\t\t\t$this.attr( ""data-"" + $.mobile.ns + ""url"", $this.attr( ""id"" ) || location.pathname + location.search );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// define first page in dom case one backs out to the directory root (not always the first page visited, but defined as fallback)\n\t\t\t$.mobile.firstPage = $pages.first();\n\n\t\t\t// define page container\n\t\t\t$.mobile.pageContainer = $pages.first().parent().addClass( ""ui-mobile-viewport"" );\n\n\t\t\t// alert listeners that the pagecontainer has been determined for binding\n\t\t\t// to events triggered on it\n\t\t\t$window.trigger( ""pagecontainercreate"" );\n\n\t\t\t// cue page loading message\n\t\t\t$.mobile.showPageLoadingMsg();\n\n\t\t\t//remove initial build class (only present on first pageshow)\n\t\t\thideRenderingClass();\n\n\t\t\t// if hashchange listening is disabled or there's no hash deeplink, change to the first page in the DOM\n\t\t\tif ( !$.mobile.hashListeningEnabled || !$.mobile.path.stripHash( location.hash ) ) {\n\t\t\t\t$.mobile.changePage( $.mobile.firstPage, { transition: ""none"", reverse: true, changeHash: false, fromHashChange: true } );\n\t\t\t}\n\t\t\t// otherwise, trigger a hashchange to load a deeplink\n\t\t\telse {\n\t\t\t\t$window.trigger( ""hashchange"", [ true ] );\n\t\t\t}\n\t\t}\n\t});\n\n\t// initialize events now, after mobileinit has occurred\n\t$.mobile._registerInternalEvents();\n\n\t// check which scrollTop value should be used by scrolling to 1 immediately at domready\n\t// then check what the scroll top is. Android will report 0... others 1\n\t// note that this initial scroll won't hide the address bar. It's just for the check.\n\t$(function() {\n\t\twindow.scrollTo( 0, 1 );\n\n\t\t// if defaultHomeScroll hasn't been set yet, see if scrollTop is 1\n\t\t// it should be 1 in most browsers, but android treats 1 as 0 (for hiding addr bar)\n\t\t// so if it's 1, use 0 from now on\n\t\t$.mobile.defaultHomeScroll = ( !$.support.scrollTop || $(window).scrollTop() === 1 ) ? 0 : 1;\n\n\n\t\t// TODO: Implement a proper registration mechanism with dependency handling in order to not have exceptions like the one below\n\t\t//auto self-init widgets for those widgets that have a soft dependency on others\n\t\tif ( $.fn.controlgroup ) {\n\t\t\t$( document ).bind( ""pagecreate create"", function( e ){\n\t\t\t\t$( "":jqmData(role='controlgroup')"", e.target )\n\t\t\t\t\t.jqmEnhanceable()\n\t\t\t\t\t.controlgroup({ excludeInvisible: false });\n\t\t\t});\n\t\t}\n\n\t\t//dom-ready inits\n\t\tif( $.mobile.autoInitializePage ){\n\t\t\t$.mobile.initializePage();\n\t\t}\n\n\t\t// window load event\n\t\t// hide iOS browser chrome on load\n\t\t$window.load( $.mobile.silentScroll );\n\t});\n}( jQuery, this ));\n\n\n}));\n\n----------------------------------- SOURCE END -------------------------------------",1342853383312
error,log,,,"Error in JSDT Core during reconcile",1342853383312
error,log,,,"Problems occurred when invoking code from plug-in: ""org.eclipse.wst.jsdt.ui"".",1342853383531
error,log,,,"Error in JSDT Core during AST creation",1342853383531
activated,editor,org.eclipse.wst.html.ui,1.0.602.v201202091936,"org.eclipse.wst.html.core.htmlsource.source",1342853387671
closed,editor,org.eclipse.wst.jsdt.ui,1.1.102.v201201131900,"org.eclipse.wst.jsdt.ui.CompilationUnitEditor",1342853387671
activated,editor,org.eclipse.wst.html.ui,1.0.602.v201202091936,"org.eclipse.wst.html.core.htmlsource.source",1342853389828
closed,editor,org.eclipse.wst.html.ui,1.0.602.v201202091936,"org.eclipse.wst.html.core.htmlsource.source",1342853389828
closed,editor,org.eclipse.jst.jsp.ui,1.1.602.v201112071516,"org.eclipse.jst.jsp.core.jspsource.source",1342853391109
